// file: pkg/queue/proto/stream_messages_request.proto
// version: 1.1.0
// Request to stream messages from a queue or topic

edition = "2023";

package gcommon.v1.queue;

import "google/protobuf/timestamp.proto";
import "pkg/queue/proto/ack_level.proto";
import "pkg/queue/proto/offset_type.proto";
import "pkg/queue/proto/stream_config.proto";
option go_package = "github.com/jdfalk/gcommon/pkg/queue/proto";



// StreamMessagesRequest initiates a message stream from a queue or topic
message StreamMessagesRequest {
  // Topic or queue identifier to stream from
  string topic = 1;

  // Consumer group ID for coordinated consumption
  string consumer_group_id = 2;

  // Individual consumer ID within the group
  string consumer_id = 3;

  // Starting offset configuration
  OffsetConfig offset_config = 4;

  // Maximum number of messages to stream
  int64 max_messages = 5;

  // Maximum time to keep stream open (milliseconds)
  int32 stream_timeout_ms = 6;

  // Acknowledgment level required
  AckLevel ack_level = 7;

  // Batch size for message delivery
  int32 batch_size = 8;

  // Message filter criteria
  MessageFilter filter = 9;

  // Auto-acknowledge messages after delivery
  bool auto_acknowledge = 10;

  // Pause stream on error
  bool pause_on_error = 11;

  // Include message metadata in stream
  bool include_metadata = 12;

  // Specific partition IDs to stream from (empty = all partitions)
  repeated int32 partition_ids = 13;

  // Stream configuration options
  StreamConfig stream_config = 14;
}

// Offset configuration for stream starting point
message OffsetConfig {
  // Offset type (earliest, latest, timestamp, specific)
  OffsetType offset_type = 1;

  // Specific offset value (when offset_type = specific)
  int64 offset_value = 2;

  // Timestamp to start from (when offset_type = timestamp)
  google.protobuf.Timestamp start_timestamp = 3;

  // Reset to beginning if offset not found
  bool reset_on_not_found = 4;
}

// Message filtering criteria
message MessageFilter {
  // Filter by message headers
  map<string, string> header_filters = 1;

  // Filter by message properties
  map<string, string> property_filters = 2;

  // Minimum message priority
  int32 min_priority = 3;

  // Maximum message age (seconds)
  int32 max_age_seconds = 4;

  // Content type filter
  string content_type = 5;

  // Custom filter expression
  string filter_expression = 6;
}

// Flow control configuration
message FlowControlConfig {
  // Enable flow control
  bool enabled = 1;

  // Maximum outstanding messages
  int32 max_outstanding_messages = 2;

  // Maximum outstanding bytes
  int64 max_outstanding_bytes = 3;

  // Flow control algorithm (token_bucket, leaky_bucket, sliding_window)
  string algorithm = 4;
}
