// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: pkg/queue/proto/queue.proto

package proto

import (
	context "context"
	requests "github.com/jdfalk/gcommon/pkg/queue/proto/requests"
	responses "github.com/jdfalk/gcommon/pkg/queue/proto/responses"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	QueueService_SendMessage_FullMethodName          = "/gcommon.v1.queue.QueueService/SendMessage"
	QueueService_SendMessages_FullMethodName         = "/gcommon.v1.queue.QueueService/SendMessages"
	QueueService_ReceiveMessage_FullMethodName       = "/gcommon.v1.queue.QueueService/ReceiveMessage"
	QueueService_ReceiveMessages_FullMethodName      = "/gcommon.v1.queue.QueueService/ReceiveMessages"
	QueueService_AckMessage_FullMethodName           = "/gcommon.v1.queue.QueueService/AckMessage"
	QueueService_NackMessage_FullMethodName          = "/gcommon.v1.queue.QueueService/NackMessage"
	QueueService_Publish_FullMethodName              = "/gcommon.v1.queue.QueueService/Publish"
	QueueService_Subscribe_FullMethodName            = "/gcommon.v1.queue.QueueService/Subscribe"
	QueueService_Unsubscribe_FullMethodName          = "/gcommon.v1.queue.QueueService/Unsubscribe"
	QueueService_GetMessage_FullMethodName           = "/gcommon.v1.queue.QueueService/GetMessage"
	QueueService_ListMessages_FullMethodName         = "/gcommon.v1.queue.QueueService/ListMessages"
	QueueService_GetQueueStats_FullMethodName        = "/gcommon.v1.queue.QueueService/GetQueueStats"
	QueueService_GetSubscriptionStats_FullMethodName = "/gcommon.v1.queue.QueueService/GetSubscriptionStats"
)

// QueueServiceClient is the client API for QueueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// QueueService provides message queuing and pub/sub functionality
type QueueServiceClient interface {
	// Send a message to a queue
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
	// Send multiple messages in batch
	SendMessages(ctx context.Context, in *SendMessagesRequest, opts ...grpc.CallOption) (*SendMessagesResponse, error)
	// Receive a message from a queue
	ReceiveMessage(ctx context.Context, in *ReceiveMessageRequest, opts ...grpc.CallOption) (*ReceiveMessageResponse, error)
	// Receive multiple messages in batch
	ReceiveMessages(ctx context.Context, in *ReceiveMessagesRequest, opts ...grpc.CallOption) (*ReceiveMessagesResponse, error)
	// Acknowledge message processing
	AckMessage(ctx context.Context, in *AckMessageRequest, opts ...grpc.CallOption) (*AckMessageResponse, error)
	// Negative acknowledge message (requeue)
	NackMessage(ctx context.Context, in *NackMessageRequest, opts ...grpc.CallOption) (*NackMessageResponse, error)
	// Publish a message to a topic
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
	// Subscribe to a topic
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MessageEvent], error)
	// Unsubscribe from a topic
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// Get message by ID
	GetMessage(ctx context.Context, in *GetMessageRequest, opts ...grpc.CallOption) (*GetMessageResponse, error)
	// List messages in a queue
	ListMessages(ctx context.Context, in *ListMessagesRequest, opts ...grpc.CallOption) (*ListMessagesResponse, error)
	// Get queue statistics
	GetQueueStats(ctx context.Context, in *requests.GetQueueStatsRequest, opts ...grpc.CallOption) (*responses.GetQueueStatsResponse, error)
	// Get subscription statistics
	GetSubscriptionStats(ctx context.Context, in *GetSubscriptionStatsRequest, opts ...grpc.CallOption) (*GetSubscriptionStatsResponse, error)
}

type queueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQueueServiceClient(cc grpc.ClientConnInterface) QueueServiceClient {
	return &queueServiceClient{cc}
}

func (c *queueServiceClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMessageResponse)
	err := c.cc.Invoke(ctx, QueueService_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) SendMessages(ctx context.Context, in *SendMessagesRequest, opts ...grpc.CallOption) (*SendMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMessagesResponse)
	err := c.cc.Invoke(ctx, QueueService_SendMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) ReceiveMessage(ctx context.Context, in *ReceiveMessageRequest, opts ...grpc.CallOption) (*ReceiveMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReceiveMessageResponse)
	err := c.cc.Invoke(ctx, QueueService_ReceiveMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) ReceiveMessages(ctx context.Context, in *ReceiveMessagesRequest, opts ...grpc.CallOption) (*ReceiveMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReceiveMessagesResponse)
	err := c.cc.Invoke(ctx, QueueService_ReceiveMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) AckMessage(ctx context.Context, in *AckMessageRequest, opts ...grpc.CallOption) (*AckMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckMessageResponse)
	err := c.cc.Invoke(ctx, QueueService_AckMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) NackMessage(ctx context.Context, in *NackMessageRequest, opts ...grpc.CallOption) (*NackMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NackMessageResponse)
	err := c.cc.Invoke(ctx, QueueService_NackMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, QueueService_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MessageEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &QueueService_ServiceDesc.Streams[0], QueueService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, MessageEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QueueService_SubscribeClient = grpc.ServerStreamingClient[MessageEvent]

func (c *queueServiceClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, QueueService_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetMessage(ctx context.Context, in *GetMessageRequest, opts ...grpc.CallOption) (*GetMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessageResponse)
	err := c.cc.Invoke(ctx, QueueService_GetMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) ListMessages(ctx context.Context, in *ListMessagesRequest, opts ...grpc.CallOption) (*ListMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMessagesResponse)
	err := c.cc.Invoke(ctx, QueueService_ListMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetQueueStats(ctx context.Context, in *requests.GetQueueStatsRequest, opts ...grpc.CallOption) (*responses.GetQueueStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(responses.GetQueueStatsResponse)
	err := c.cc.Invoke(ctx, QueueService_GetQueueStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetSubscriptionStats(ctx context.Context, in *GetSubscriptionStatsRequest, opts ...grpc.CallOption) (*GetSubscriptionStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSubscriptionStatsResponse)
	err := c.cc.Invoke(ctx, QueueService_GetSubscriptionStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueueServiceServer is the server API for QueueService service.
// All implementations should embed UnimplementedQueueServiceServer
// for forward compatibility.
//
// QueueService provides message queuing and pub/sub functionality
type QueueServiceServer interface {
	// Send a message to a queue
	SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error)
	// Send multiple messages in batch
	SendMessages(context.Context, *SendMessagesRequest) (*SendMessagesResponse, error)
	// Receive a message from a queue
	ReceiveMessage(context.Context, *ReceiveMessageRequest) (*ReceiveMessageResponse, error)
	// Receive multiple messages in batch
	ReceiveMessages(context.Context, *ReceiveMessagesRequest) (*ReceiveMessagesResponse, error)
	// Acknowledge message processing
	AckMessage(context.Context, *AckMessageRequest) (*AckMessageResponse, error)
	// Negative acknowledge message (requeue)
	NackMessage(context.Context, *NackMessageRequest) (*NackMessageResponse, error)
	// Publish a message to a topic
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
	// Subscribe to a topic
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[MessageEvent]) error
	// Unsubscribe from a topic
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// Get message by ID
	GetMessage(context.Context, *GetMessageRequest) (*GetMessageResponse, error)
	// List messages in a queue
	ListMessages(context.Context, *ListMessagesRequest) (*ListMessagesResponse, error)
	// Get queue statistics
	GetQueueStats(context.Context, *requests.GetQueueStatsRequest) (*responses.GetQueueStatsResponse, error)
	// Get subscription statistics
	GetSubscriptionStats(context.Context, *GetSubscriptionStatsRequest) (*GetSubscriptionStatsResponse, error)
}

// UnimplementedQueueServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQueueServiceServer struct{}

func (UnimplementedQueueServiceServer) SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedQueueServiceServer) SendMessages(context.Context, *SendMessagesRequest) (*SendMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessages not implemented")
}
func (UnimplementedQueueServiceServer) ReceiveMessage(context.Context, *ReceiveMessageRequest) (*ReceiveMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveMessage not implemented")
}
func (UnimplementedQueueServiceServer) ReceiveMessages(context.Context, *ReceiveMessagesRequest) (*ReceiveMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveMessages not implemented")
}
func (UnimplementedQueueServiceServer) AckMessage(context.Context, *AckMessageRequest) (*AckMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckMessage not implemented")
}
func (UnimplementedQueueServiceServer) NackMessage(context.Context, *NackMessageRequest) (*NackMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NackMessage not implemented")
}
func (UnimplementedQueueServiceServer) Publish(context.Context, *PublishRequest) (*PublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedQueueServiceServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[MessageEvent]) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedQueueServiceServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedQueueServiceServer) GetMessage(context.Context, *GetMessageRequest) (*GetMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMessage not implemented")
}
func (UnimplementedQueueServiceServer) ListMessages(context.Context, *ListMessagesRequest) (*ListMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMessages not implemented")
}
func (UnimplementedQueueServiceServer) GetQueueStats(context.Context, *requests.GetQueueStatsRequest) (*responses.GetQueueStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueueStats not implemented")
}
func (UnimplementedQueueServiceServer) GetSubscriptionStats(context.Context, *GetSubscriptionStatsRequest) (*GetSubscriptionStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscriptionStats not implemented")
}
func (UnimplementedQueueServiceServer) testEmbeddedByValue() {}

// UnsafeQueueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueueServiceServer will
// result in compilation errors.
type UnsafeQueueServiceServer interface {
	mustEmbedUnimplementedQueueServiceServer()
}

func RegisterQueueServiceServer(s grpc.ServiceRegistrar, srv QueueServiceServer) {
	// If the following call pancis, it indicates UnimplementedQueueServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&QueueService_ServiceDesc, srv)
}

func _QueueService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_SendMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).SendMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_SendMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).SendMessages(ctx, req.(*SendMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_ReceiveMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).ReceiveMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_ReceiveMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).ReceiveMessage(ctx, req.(*ReceiveMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_ReceiveMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).ReceiveMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_ReceiveMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).ReceiveMessages(ctx, req.(*ReceiveMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_AckMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).AckMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_AckMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).AckMessage(ctx, req.(*AckMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_NackMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NackMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).NackMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_NackMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).NackMessage(ctx, req.(*NackMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueueServiceServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, MessageEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QueueService_SubscribeServer = grpc.ServerStreamingServer[MessageEvent]

func _QueueService_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_GetMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetMessage(ctx, req.(*GetMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_ListMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).ListMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_ListMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).ListMessages(ctx, req.(*ListMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetQueueStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(requests.GetQueueStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetQueueStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_GetQueueStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetQueueStats(ctx, req.(*requests.GetQueueStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetSubscriptionStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscriptionStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetSubscriptionStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_GetSubscriptionStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetSubscriptionStats(ctx, req.(*GetSubscriptionStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// QueueService_ServiceDesc is the grpc.ServiceDesc for QueueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gcommon.v1.queue.QueueService",
	HandlerType: (*QueueServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _QueueService_SendMessage_Handler,
		},
		{
			MethodName: "SendMessages",
			Handler:    _QueueService_SendMessages_Handler,
		},
		{
			MethodName: "ReceiveMessage",
			Handler:    _QueueService_ReceiveMessage_Handler,
		},
		{
			MethodName: "ReceiveMessages",
			Handler:    _QueueService_ReceiveMessages_Handler,
		},
		{
			MethodName: "AckMessage",
			Handler:    _QueueService_AckMessage_Handler,
		},
		{
			MethodName: "NackMessage",
			Handler:    _QueueService_NackMessage_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _QueueService_Publish_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _QueueService_Unsubscribe_Handler,
		},
		{
			MethodName: "GetMessage",
			Handler:    _QueueService_GetMessage_Handler,
		},
		{
			MethodName: "ListMessages",
			Handler:    _QueueService_ListMessages_Handler,
		},
		{
			MethodName: "GetQueueStats",
			Handler:    _QueueService_GetQueueStats_Handler,
		},
		{
			MethodName: "GetSubscriptionStats",
			Handler:    _QueueService_GetSubscriptionStats_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _QueueService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/queue/proto/queue.proto",
}

const (
	QueueAdminService_CreateQueue_FullMethodName               = "/gcommon.v1.queue.QueueAdminService/CreateQueue"
	QueueAdminService_UpdateQueue_FullMethodName               = "/gcommon.v1.queue.QueueAdminService/UpdateQueue"
	QueueAdminService_DeleteQueue_FullMethodName               = "/gcommon.v1.queue.QueueAdminService/DeleteQueue"
	QueueAdminService_ListQueues_FullMethodName                = "/gcommon.v1.queue.QueueAdminService/ListQueues"
	QueueAdminService_CreateTopic_FullMethodName               = "/gcommon.v1.queue.QueueAdminService/CreateTopic"
	QueueAdminService_UpdateTopic_FullMethodName               = "/gcommon.v1.queue.QueueAdminService/UpdateTopic"
	QueueAdminService_DeleteTopic_FullMethodName               = "/gcommon.v1.queue.QueueAdminService/DeleteTopic"
	QueueAdminService_ListTopics_FullMethodName                = "/gcommon.v1.queue.QueueAdminService/ListTopics"
	QueueAdminService_CreateSubscription_FullMethodName        = "/gcommon.v1.queue.QueueAdminService/CreateSubscription"
	QueueAdminService_UpdateSubscription_FullMethodName        = "/gcommon.v1.queue.QueueAdminService/UpdateSubscription"
	QueueAdminService_DeleteSubscription_FullMethodName        = "/gcommon.v1.queue.QueueAdminService/DeleteSubscription"
	QueueAdminService_ListSubscriptions_FullMethodName         = "/gcommon.v1.queue.QueueAdminService/ListSubscriptions"
	QueueAdminService_PurgeQueue_FullMethodName                = "/gcommon.v1.queue.QueueAdminService/PurgeQueue"
	QueueAdminService_GetDeadLetterMessages_FullMethodName     = "/gcommon.v1.queue.QueueAdminService/GetDeadLetterMessages"
	QueueAdminService_RequeueDeadLetterMessages_FullMethodName = "/gcommon.v1.queue.QueueAdminService/RequeueDeadLetterMessages"
	QueueAdminService_GetSystemHealth_FullMethodName           = "/gcommon.v1.queue.QueueAdminService/GetSystemHealth"
)

// QueueAdminServiceClient is the client API for QueueAdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// QueueAdminService provides queue administration and management
type QueueAdminServiceClient interface {
	// Create a queue
	CreateQueue(ctx context.Context, in *CreateQueueRequest, opts ...grpc.CallOption) (*CreateQueueResponse, error)
	// Update a queue
	UpdateQueue(ctx context.Context, in *UpdateQueueRequest, opts ...grpc.CallOption) (*UpdateQueueResponse, error)
	// Delete a queue
	DeleteQueue(ctx context.Context, in *DeleteQueueRequest, opts ...grpc.CallOption) (*responses.DeleteQueueResponse, error)
	// List queues
	ListQueues(ctx context.Context, in *ListQueuesRequest, opts ...grpc.CallOption) (*ListQueuesResponse, error)
	// Create a topic
	CreateTopic(ctx context.Context, in *CreateTopicRequest, opts ...grpc.CallOption) (*CreateTopicResponse, error)
	// Update a topic
	UpdateTopic(ctx context.Context, in *UpdateTopicRequest, opts ...grpc.CallOption) (*UpdateTopicResponse, error)
	// Delete a topic
	DeleteTopic(ctx context.Context, in *DeleteTopicRequest, opts ...grpc.CallOption) (*responses.DeleteTopicResponse, error)
	// List topics
	ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error)
	// Create a subscription
	CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*CreateSubscriptionResponse, error)
	// Update a subscription
	UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*UpdateSubscriptionResponse, error)
	// Delete a subscription
	DeleteSubscription(ctx context.Context, in *DeleteSubscriptionRequest, opts ...grpc.CallOption) (*responses.DeleteSubscriptionResponse, error)
	// List subscriptions
	ListSubscriptions(ctx context.Context, in *ListSubscriptionsRequest, opts ...grpc.CallOption) (*ListSubscriptionsResponse, error)
	// Purge messages from a queue
	PurgeQueue(ctx context.Context, in *PurgeQueueRequest, opts ...grpc.CallOption) (*PurgeQueueResponse, error)
	// Get dead letter queue messages
	GetDeadLetterMessages(ctx context.Context, in *GetDeadLetterMessagesRequest, opts ...grpc.CallOption) (*GetDeadLetterMessagesResponse, error)
	// Requeue dead letter messages
	RequeueDeadLetterMessages(ctx context.Context, in *RequeueDeadLetterMessagesRequest, opts ...grpc.CallOption) (*RequeueDeadLetterMessagesResponse, error)
	// Get system health
	GetSystemHealth(ctx context.Context, in *GetSystemHealthRequest, opts ...grpc.CallOption) (*GetSystemHealthResponse, error)
}

type queueAdminServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQueueAdminServiceClient(cc grpc.ClientConnInterface) QueueAdminServiceClient {
	return &queueAdminServiceClient{cc}
}

func (c *queueAdminServiceClient) CreateQueue(ctx context.Context, in *CreateQueueRequest, opts ...grpc.CallOption) (*CreateQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateQueueResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_CreateQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) UpdateQueue(ctx context.Context, in *UpdateQueueRequest, opts ...grpc.CallOption) (*UpdateQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateQueueResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_UpdateQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) DeleteQueue(ctx context.Context, in *DeleteQueueRequest, opts ...grpc.CallOption) (*responses.DeleteQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(responses.DeleteQueueResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_DeleteQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) ListQueues(ctx context.Context, in *ListQueuesRequest, opts ...grpc.CallOption) (*ListQueuesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListQueuesResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_ListQueues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) CreateTopic(ctx context.Context, in *CreateTopicRequest, opts ...grpc.CallOption) (*CreateTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTopicResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_CreateTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) UpdateTopic(ctx context.Context, in *UpdateTopicRequest, opts ...grpc.CallOption) (*UpdateTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTopicResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_UpdateTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) DeleteTopic(ctx context.Context, in *DeleteTopicRequest, opts ...grpc.CallOption) (*responses.DeleteTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(responses.DeleteTopicResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_DeleteTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTopicsResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_ListTopics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*CreateSubscriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSubscriptionResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_CreateSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*UpdateSubscriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSubscriptionResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_UpdateSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) DeleteSubscription(ctx context.Context, in *DeleteSubscriptionRequest, opts ...grpc.CallOption) (*responses.DeleteSubscriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(responses.DeleteSubscriptionResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_DeleteSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) ListSubscriptions(ctx context.Context, in *ListSubscriptionsRequest, opts ...grpc.CallOption) (*ListSubscriptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSubscriptionsResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_ListSubscriptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) PurgeQueue(ctx context.Context, in *PurgeQueueRequest, opts ...grpc.CallOption) (*PurgeQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PurgeQueueResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_PurgeQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) GetDeadLetterMessages(ctx context.Context, in *GetDeadLetterMessagesRequest, opts ...grpc.CallOption) (*GetDeadLetterMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDeadLetterMessagesResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_GetDeadLetterMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) RequeueDeadLetterMessages(ctx context.Context, in *RequeueDeadLetterMessagesRequest, opts ...grpc.CallOption) (*RequeueDeadLetterMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequeueDeadLetterMessagesResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_RequeueDeadLetterMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueAdminServiceClient) GetSystemHealth(ctx context.Context, in *GetSystemHealthRequest, opts ...grpc.CallOption) (*GetSystemHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSystemHealthResponse)
	err := c.cc.Invoke(ctx, QueueAdminService_GetSystemHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueueAdminServiceServer is the server API for QueueAdminService service.
// All implementations should embed UnimplementedQueueAdminServiceServer
// for forward compatibility.
//
// QueueAdminService provides queue administration and management
type QueueAdminServiceServer interface {
	// Create a queue
	CreateQueue(context.Context, *CreateQueueRequest) (*CreateQueueResponse, error)
	// Update a queue
	UpdateQueue(context.Context, *UpdateQueueRequest) (*UpdateQueueResponse, error)
	// Delete a queue
	DeleteQueue(context.Context, *DeleteQueueRequest) (*responses.DeleteQueueResponse, error)
	// List queues
	ListQueues(context.Context, *ListQueuesRequest) (*ListQueuesResponse, error)
	// Create a topic
	CreateTopic(context.Context, *CreateTopicRequest) (*CreateTopicResponse, error)
	// Update a topic
	UpdateTopic(context.Context, *UpdateTopicRequest) (*UpdateTopicResponse, error)
	// Delete a topic
	DeleteTopic(context.Context, *DeleteTopicRequest) (*responses.DeleteTopicResponse, error)
	// List topics
	ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error)
	// Create a subscription
	CreateSubscription(context.Context, *CreateSubscriptionRequest) (*CreateSubscriptionResponse, error)
	// Update a subscription
	UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*UpdateSubscriptionResponse, error)
	// Delete a subscription
	DeleteSubscription(context.Context, *DeleteSubscriptionRequest) (*responses.DeleteSubscriptionResponse, error)
	// List subscriptions
	ListSubscriptions(context.Context, *ListSubscriptionsRequest) (*ListSubscriptionsResponse, error)
	// Purge messages from a queue
	PurgeQueue(context.Context, *PurgeQueueRequest) (*PurgeQueueResponse, error)
	// Get dead letter queue messages
	GetDeadLetterMessages(context.Context, *GetDeadLetterMessagesRequest) (*GetDeadLetterMessagesResponse, error)
	// Requeue dead letter messages
	RequeueDeadLetterMessages(context.Context, *RequeueDeadLetterMessagesRequest) (*RequeueDeadLetterMessagesResponse, error)
	// Get system health
	GetSystemHealth(context.Context, *GetSystemHealthRequest) (*GetSystemHealthResponse, error)
}

// UnimplementedQueueAdminServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQueueAdminServiceServer struct{}

func (UnimplementedQueueAdminServiceServer) CreateQueue(context.Context, *CreateQueueRequest) (*CreateQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQueue not implemented")
}
func (UnimplementedQueueAdminServiceServer) UpdateQueue(context.Context, *UpdateQueueRequest) (*UpdateQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQueue not implemented")
}
func (UnimplementedQueueAdminServiceServer) DeleteQueue(context.Context, *DeleteQueueRequest) (*responses.DeleteQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQueue not implemented")
}
func (UnimplementedQueueAdminServiceServer) ListQueues(context.Context, *ListQueuesRequest) (*ListQueuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListQueues not implemented")
}
func (UnimplementedQueueAdminServiceServer) CreateTopic(context.Context, *CreateTopicRequest) (*CreateTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTopic not implemented")
}
func (UnimplementedQueueAdminServiceServer) UpdateTopic(context.Context, *UpdateTopicRequest) (*UpdateTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTopic not implemented")
}
func (UnimplementedQueueAdminServiceServer) DeleteTopic(context.Context, *DeleteTopicRequest) (*responses.DeleteTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTopic not implemented")
}
func (UnimplementedQueueAdminServiceServer) ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTopics not implemented")
}
func (UnimplementedQueueAdminServiceServer) CreateSubscription(context.Context, *CreateSubscriptionRequest) (*CreateSubscriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubscription not implemented")
}
func (UnimplementedQueueAdminServiceServer) UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*UpdateSubscriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubscription not implemented")
}
func (UnimplementedQueueAdminServiceServer) DeleteSubscription(context.Context, *DeleteSubscriptionRequest) (*responses.DeleteSubscriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubscription not implemented")
}
func (UnimplementedQueueAdminServiceServer) ListSubscriptions(context.Context, *ListSubscriptionsRequest) (*ListSubscriptionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSubscriptions not implemented")
}
func (UnimplementedQueueAdminServiceServer) PurgeQueue(context.Context, *PurgeQueueRequest) (*PurgeQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PurgeQueue not implemented")
}
func (UnimplementedQueueAdminServiceServer) GetDeadLetterMessages(context.Context, *GetDeadLetterMessagesRequest) (*GetDeadLetterMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeadLetterMessages not implemented")
}
func (UnimplementedQueueAdminServiceServer) RequeueDeadLetterMessages(context.Context, *RequeueDeadLetterMessagesRequest) (*RequeueDeadLetterMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequeueDeadLetterMessages not implemented")
}
func (UnimplementedQueueAdminServiceServer) GetSystemHealth(context.Context, *GetSystemHealthRequest) (*GetSystemHealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemHealth not implemented")
}
func (UnimplementedQueueAdminServiceServer) testEmbeddedByValue() {}

// UnsafeQueueAdminServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueueAdminServiceServer will
// result in compilation errors.
type UnsafeQueueAdminServiceServer interface {
	mustEmbedUnimplementedQueueAdminServiceServer()
}

func RegisterQueueAdminServiceServer(s grpc.ServiceRegistrar, srv QueueAdminServiceServer) {
	// If the following call pancis, it indicates UnimplementedQueueAdminServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&QueueAdminService_ServiceDesc, srv)
}

func _QueueAdminService_CreateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).CreateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_CreateQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).CreateQueue(ctx, req.(*CreateQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_UpdateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).UpdateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_UpdateQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).UpdateQueue(ctx, req.(*UpdateQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_DeleteQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).DeleteQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_DeleteQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).DeleteQueue(ctx, req.(*DeleteQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_ListQueues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListQueuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).ListQueues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_ListQueues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).ListQueues(ctx, req.(*ListQueuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_CreateTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).CreateTopic(ctx, req.(*CreateTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_UpdateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).UpdateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_UpdateTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).UpdateTopic(ctx, req.(*UpdateTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_DeleteTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).DeleteTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_DeleteTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).DeleteTopic(ctx, req.(*DeleteTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_ListTopics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).ListTopics(ctx, req.(*ListTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_CreateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).CreateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_CreateSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).CreateSubscription(ctx, req.(*CreateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_UpdateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).UpdateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_UpdateSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).UpdateSubscription(ctx, req.(*UpdateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_DeleteSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).DeleteSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_DeleteSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).DeleteSubscription(ctx, req.(*DeleteSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_ListSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubscriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).ListSubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_ListSubscriptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).ListSubscriptions(ctx, req.(*ListSubscriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_PurgeQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PurgeQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).PurgeQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_PurgeQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).PurgeQueue(ctx, req.(*PurgeQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_GetDeadLetterMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeadLetterMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).GetDeadLetterMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_GetDeadLetterMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).GetDeadLetterMessages(ctx, req.(*GetDeadLetterMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_RequeueDeadLetterMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequeueDeadLetterMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).RequeueDeadLetterMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_RequeueDeadLetterMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).RequeueDeadLetterMessages(ctx, req.(*RequeueDeadLetterMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueAdminService_GetSystemHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueAdminServiceServer).GetSystemHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueAdminService_GetSystemHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueAdminServiceServer).GetSystemHealth(ctx, req.(*GetSystemHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// QueueAdminService_ServiceDesc is the grpc.ServiceDesc for QueueAdminService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueueAdminService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gcommon.v1.queue.QueueAdminService",
	HandlerType: (*QueueAdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateQueue",
			Handler:    _QueueAdminService_CreateQueue_Handler,
		},
		{
			MethodName: "UpdateQueue",
			Handler:    _QueueAdminService_UpdateQueue_Handler,
		},
		{
			MethodName: "DeleteQueue",
			Handler:    _QueueAdminService_DeleteQueue_Handler,
		},
		{
			MethodName: "ListQueues",
			Handler:    _QueueAdminService_ListQueues_Handler,
		},
		{
			MethodName: "CreateTopic",
			Handler:    _QueueAdminService_CreateTopic_Handler,
		},
		{
			MethodName: "UpdateTopic",
			Handler:    _QueueAdminService_UpdateTopic_Handler,
		},
		{
			MethodName: "DeleteTopic",
			Handler:    _QueueAdminService_DeleteTopic_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _QueueAdminService_ListTopics_Handler,
		},
		{
			MethodName: "CreateSubscription",
			Handler:    _QueueAdminService_CreateSubscription_Handler,
		},
		{
			MethodName: "UpdateSubscription",
			Handler:    _QueueAdminService_UpdateSubscription_Handler,
		},
		{
			MethodName: "DeleteSubscription",
			Handler:    _QueueAdminService_DeleteSubscription_Handler,
		},
		{
			MethodName: "ListSubscriptions",
			Handler:    _QueueAdminService_ListSubscriptions_Handler,
		},
		{
			MethodName: "PurgeQueue",
			Handler:    _QueueAdminService_PurgeQueue_Handler,
		},
		{
			MethodName: "GetDeadLetterMessages",
			Handler:    _QueueAdminService_GetDeadLetterMessages_Handler,
		},
		{
			MethodName: "RequeueDeadLetterMessages",
			Handler:    _QueueAdminService_RequeueDeadLetterMessages_Handler,
		},
		{
			MethodName: "GetSystemHealth",
			Handler:    _QueueAdminService_GetSystemHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/queue/proto/queue.proto",
}

const (
	WorkflowService_StartWorkflow_FullMethodName  = "/gcommon.v1.queue.WorkflowService/StartWorkflow"
	WorkflowService_GetWorkflow_FullMethodName    = "/gcommon.v1.queue.WorkflowService/GetWorkflow"
	WorkflowService_ListWorkflows_FullMethodName  = "/gcommon.v1.queue.WorkflowService/ListWorkflows"
	WorkflowService_CancelWorkflow_FullMethodName = "/gcommon.v1.queue.WorkflowService/CancelWorkflow"
	WorkflowService_PauseWorkflow_FullMethodName  = "/gcommon.v1.queue.WorkflowService/PauseWorkflow"
	WorkflowService_ResumeWorkflow_FullMethodName = "/gcommon.v1.queue.WorkflowService/ResumeWorkflow"
	WorkflowService_CompleteTask_FullMethodName   = "/gcommon.v1.queue.WorkflowService/CompleteTask"
	WorkflowService_FailTask_FullMethodName       = "/gcommon.v1.queue.WorkflowService/FailTask"
	WorkflowService_GetTask_FullMethodName        = "/gcommon.v1.queue.WorkflowService/GetTask"
	WorkflowService_ListTasks_FullMethodName      = "/gcommon.v1.queue.WorkflowService/ListTasks"
)

// WorkflowServiceClient is the client API for WorkflowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// WorkflowService provides workflow orchestration functionality
type WorkflowServiceClient interface {
	// Start a workflow
	StartWorkflow(ctx context.Context, in *StartWorkflowRequest, opts ...grpc.CallOption) (*StartWorkflowResponse, error)
	// Get workflow status
	GetWorkflow(ctx context.Context, in *GetWorkflowRequest, opts ...grpc.CallOption) (*GetWorkflowResponse, error)
	// List workflows
	ListWorkflows(ctx context.Context, in *ListWorkflowsRequest, opts ...grpc.CallOption) (*ListWorkflowsResponse, error)
	// Cancel a workflow
	CancelWorkflow(ctx context.Context, in *CancelWorkflowRequest, opts ...grpc.CallOption) (*CancelWorkflowResponse, error)
	// Pause a workflow
	PauseWorkflow(ctx context.Context, in *PauseWorkflowRequest, opts ...grpc.CallOption) (*PauseWorkflowResponse, error)
	// Resume a workflow
	ResumeWorkflow(ctx context.Context, in *ResumeWorkflowRequest, opts ...grpc.CallOption) (*ResumeWorkflowResponse, error)
	// Complete a task
	CompleteTask(ctx context.Context, in *CompleteTaskRequest, opts ...grpc.CallOption) (*CompleteTaskResponse, error)
	// Fail a task
	FailTask(ctx context.Context, in *FailTaskRequest, opts ...grpc.CallOption) (*FailTaskResponse, error)
	// Get task status
	GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskResponse, error)
	// List tasks
	ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error)
}

type workflowServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowServiceClient(cc grpc.ClientConnInterface) WorkflowServiceClient {
	return &workflowServiceClient{cc}
}

func (c *workflowServiceClient) StartWorkflow(ctx context.Context, in *StartWorkflowRequest, opts ...grpc.CallOption) (*StartWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartWorkflowResponse)
	err := c.cc.Invoke(ctx, WorkflowService_StartWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkflow(ctx context.Context, in *GetWorkflowRequest, opts ...grpc.CallOption) (*GetWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkflowResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListWorkflows(ctx context.Context, in *ListWorkflowsRequest, opts ...grpc.CallOption) (*ListWorkflowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkflowsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListWorkflows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) CancelWorkflow(ctx context.Context, in *CancelWorkflowRequest, opts ...grpc.CallOption) (*CancelWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelWorkflowResponse)
	err := c.cc.Invoke(ctx, WorkflowService_CancelWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PauseWorkflow(ctx context.Context, in *PauseWorkflowRequest, opts ...grpc.CallOption) (*PauseWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseWorkflowResponse)
	err := c.cc.Invoke(ctx, WorkflowService_PauseWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ResumeWorkflow(ctx context.Context, in *ResumeWorkflowRequest, opts ...grpc.CallOption) (*ResumeWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResumeWorkflowResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ResumeWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) CompleteTask(ctx context.Context, in *CompleteTaskRequest, opts ...grpc.CallOption) (*CompleteTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompleteTaskResponse)
	err := c.cc.Invoke(ctx, WorkflowService_CompleteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) FailTask(ctx context.Context, in *FailTaskRequest, opts ...grpc.CallOption) (*FailTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FailTaskResponse)
	err := c.cc.Invoke(ctx, WorkflowService_FailTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTaskResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTasksResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowServiceServer is the server API for WorkflowService service.
// All implementations should embed UnimplementedWorkflowServiceServer
// for forward compatibility.
//
// WorkflowService provides workflow orchestration functionality
type WorkflowServiceServer interface {
	// Start a workflow
	StartWorkflow(context.Context, *StartWorkflowRequest) (*StartWorkflowResponse, error)
	// Get workflow status
	GetWorkflow(context.Context, *GetWorkflowRequest) (*GetWorkflowResponse, error)
	// List workflows
	ListWorkflows(context.Context, *ListWorkflowsRequest) (*ListWorkflowsResponse, error)
	// Cancel a workflow
	CancelWorkflow(context.Context, *CancelWorkflowRequest) (*CancelWorkflowResponse, error)
	// Pause a workflow
	PauseWorkflow(context.Context, *PauseWorkflowRequest) (*PauseWorkflowResponse, error)
	// Resume a workflow
	ResumeWorkflow(context.Context, *ResumeWorkflowRequest) (*ResumeWorkflowResponse, error)
	// Complete a task
	CompleteTask(context.Context, *CompleteTaskRequest) (*CompleteTaskResponse, error)
	// Fail a task
	FailTask(context.Context, *FailTaskRequest) (*FailTaskResponse, error)
	// Get task status
	GetTask(context.Context, *GetTaskRequest) (*GetTaskResponse, error)
	// List tasks
	ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error)
}

// UnimplementedWorkflowServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowServiceServer struct{}

func (UnimplementedWorkflowServiceServer) StartWorkflow(context.Context, *StartWorkflowRequest) (*StartWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkflow not implemented")
}
func (UnimplementedWorkflowServiceServer) GetWorkflow(context.Context, *GetWorkflowRequest) (*GetWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflow not implemented")
}
func (UnimplementedWorkflowServiceServer) ListWorkflows(context.Context, *ListWorkflowsRequest) (*ListWorkflowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflows not implemented")
}
func (UnimplementedWorkflowServiceServer) CancelWorkflow(context.Context, *CancelWorkflowRequest) (*CancelWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelWorkflow not implemented")
}
func (UnimplementedWorkflowServiceServer) PauseWorkflow(context.Context, *PauseWorkflowRequest) (*PauseWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseWorkflow not implemented")
}
func (UnimplementedWorkflowServiceServer) ResumeWorkflow(context.Context, *ResumeWorkflowRequest) (*ResumeWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeWorkflow not implemented")
}
func (UnimplementedWorkflowServiceServer) CompleteTask(context.Context, *CompleteTaskRequest) (*CompleteTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteTask not implemented")
}
func (UnimplementedWorkflowServiceServer) FailTask(context.Context, *FailTaskRequest) (*FailTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FailTask not implemented")
}
func (UnimplementedWorkflowServiceServer) GetTask(context.Context, *GetTaskRequest) (*GetTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTask not implemented")
}
func (UnimplementedWorkflowServiceServer) ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedWorkflowServiceServer) testEmbeddedByValue() {}

// UnsafeWorkflowServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowServiceServer will
// result in compilation errors.
type UnsafeWorkflowServiceServer interface {
	mustEmbedUnimplementedWorkflowServiceServer()
}

func RegisterWorkflowServiceServer(s grpc.ServiceRegistrar, srv WorkflowServiceServer) {
	// If the following call pancis, it indicates UnimplementedWorkflowServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkflowService_ServiceDesc, srv)
}

func _WorkflowService_StartWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).StartWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_StartWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).StartWorkflow(ctx, req.(*StartWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkflow(ctx, req.(*GetWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListWorkflows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListWorkflows(ctx, req.(*ListWorkflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_CancelWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).CancelWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_CancelWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).CancelWorkflow(ctx, req.(*CancelWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PauseWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PauseWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_PauseWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PauseWorkflow(ctx, req.(*PauseWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ResumeWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ResumeWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ResumeWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ResumeWorkflow(ctx, req.(*ResumeWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_CompleteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).CompleteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_CompleteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).CompleteTask(ctx, req.(*CompleteTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_FailTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).FailTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_FailTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).FailTask(ctx, req.(*FailTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetTask(ctx, req.(*GetTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListTasks(ctx, req.(*ListTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkflowService_ServiceDesc is the grpc.ServiceDesc for WorkflowService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gcommon.v1.queue.WorkflowService",
	HandlerType: (*WorkflowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartWorkflow",
			Handler:    _WorkflowService_StartWorkflow_Handler,
		},
		{
			MethodName: "GetWorkflow",
			Handler:    _WorkflowService_GetWorkflow_Handler,
		},
		{
			MethodName: "ListWorkflows",
			Handler:    _WorkflowService_ListWorkflows_Handler,
		},
		{
			MethodName: "CancelWorkflow",
			Handler:    _WorkflowService_CancelWorkflow_Handler,
		},
		{
			MethodName: "PauseWorkflow",
			Handler:    _WorkflowService_PauseWorkflow_Handler,
		},
		{
			MethodName: "ResumeWorkflow",
			Handler:    _WorkflowService_ResumeWorkflow_Handler,
		},
		{
			MethodName: "CompleteTask",
			Handler:    _WorkflowService_CompleteTask_Handler,
		},
		{
			MethodName: "FailTask",
			Handler:    _WorkflowService_FailTask_Handler,
		},
		{
			MethodName: "GetTask",
			Handler:    _WorkflowService_GetTask_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _WorkflowService_ListTasks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/queue/proto/queue.proto",
}
