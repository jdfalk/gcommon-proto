// file: pkg/queue/proto/consumer_group.proto
// version: 1.1.0
// Consumer group management for queue message consumption

edition = "2023";

package gcommon.v1.queue;

import "google/protobuf/timestamp.proto";
import "pkg/queue/proto/load_balancing_strategy.proto";
import "pkg/queue/proto/subscribe_request.proto";
import "pkg/queue/proto/consumer_state.proto";

option go_package = "github.com/jdfalk/gcommon/pkg/queue/queuepb";

// ConsumerGroup represents a group of consumers that coordinate message consumption
message ConsumerGroup {
  // Unique identifier for the consumer group
  string group_id = 1;

  // Group name (human-readable)
  string group_name = 2;

  // Topic or queue this group is consuming from
  string topic = 3;

  // Consumer group configuration
  ConsumerGroupConfig config = 4;

  // Current group state
  ConsumerGroupState state = 5;

  // List of active consumers in the group
  repeated Consumer consumers = 6;

  // Partition assignments
  repeated PartitionAssignment partition_assignments = 7;

  // Group coordinator information
  GroupCoordinator coordinator = 8;

  // Consumer group statistics
  ConsumerGroupStats stats = 9;

  // Group metadata
  map<string, string> metadata = 10;

  // Creation timestamp
  google.protobuf.Timestamp created_at = 11;

  // Last updated timestamp
  google.protobuf.Timestamp updated_at = 12;
}

// Consumer group configuration
message ConsumerGroupConfig {
  // Load balancing strategy for partition assignment
  LoadBalancingStrategy load_balancing_strategy = 1;

  // Rebalance strategy when consumers join/leave
  RebalanceStrategy rebalance_strategy = 2;

  // Session timeout for consumer heartbeats (milliseconds)
  int32 session_timeout_ms = 3;

  // Heartbeat interval (milliseconds)
  int32 heartbeat_interval_ms = 4;

  // Maximum poll interval (milliseconds)
  int32 max_poll_interval_ms = 5;

  // Auto-commit configuration
  AutoCommitConfig auto_commit = 6;

  // Offset reset strategy for new consumers
  OffsetResetStrategy offset_reset_strategy = 7;

  // Maximum number of consumers allowed in the group
  int32 max_consumers = 8;

  // Enable exactly-once semantics
  bool exactly_once_enabled = 9;

  // Dead letter queue configuration
  DeadLetterQueueConfig dlq_config = 10;
}

// Rebalance strategy for consumer group changes
enum RebalanceStrategy {
  REBALANCE_STRATEGY_UNSPECIFIED = 0;
  REBALANCE_STRATEGY_EAGER = 1;               // Stop all consumers, then reassign
  REBALANCE_STRATEGY_COOPERATIVE = 2;         // Incremental cooperative rebalancing
  REBALANCE_STRATEGY_STATIC = 3;              // Static assignment (no rebalancing)
}

// Auto-commit configuration
message AutoCommitConfig {
  // Enable auto-commit of offsets
  bool enabled = 1;

  // Auto-commit interval (milliseconds)
  int32 interval_ms = 2;

  // Commit on message processing completion
  bool commit_on_completion = 3;

  // Batch size for auto-commit
  int32 batch_size = 4;
}

// Offset reset strategy for new consumers
enum OffsetResetStrategy {
  OFFSET_RESET_STRATEGY_UNSPECIFIED = 0;
  OFFSET_RESET_STRATEGY_EARLIEST = 1;         // Start from earliest available offset
  OFFSET_RESET_STRATEGY_LATEST = 2;           // Start from latest offset
  OFFSET_RESET_STRATEGY_NONE = 3;             // Fail if no committed offset
  OFFSET_RESET_STRATEGY_TIMESTAMP = 4;        // Start from specific timestamp
}

// Retry delay configuration
message RetryDelayConfig {
  // Initial retry delay (milliseconds)
  int32 initial_delay_ms = 1;

  // Maximum retry delay (milliseconds)
  int32 max_delay_ms = 2;

  // Backoff multiplier for exponential backoff
  double backoff_multiplier = 3;

  // Enable jitter for retry delays
  bool jitter_enabled = 4;
}

// Consumer group state
enum ConsumerGroupState {
  CONSUMER_GROUP_STATE_UNSPECIFIED = 0;
  CONSUMER_GROUP_STATE_STABLE = 1;            // Group is stable with assigned partitions
  CONSUMER_GROUP_STATE_PREPARING_REBALANCE = 2; // Preparing for rebalance
  CONSUMER_GROUP_STATE_COMPLETING_REBALANCE = 3; // Completing rebalance operation
  CONSUMER_GROUP_STATE_DEAD = 4;              // Group has no active consumers
  CONSUMER_GROUP_STATE_EMPTY = 5;             // Group exists but no consumers
}

// Individual consumer in the group
message Consumer {
  // Unique consumer identifier
  string consumer_id = 1;

  // Consumer client information
  ConsumerClient client_info = 2;

  // Consumer state
  ConsumerState state = 3;

  // Assigned partitions
  repeated int32 assigned_partitions = 4;

  // Consumer configuration
  ConsumerConfig config = 5;

  // Consumer statistics
  ConsumerStats stats = 6;

  // Last heartbeat timestamp
  google.protobuf.Timestamp last_heartbeat = 7;

  // Join timestamp
  google.protobuf.Timestamp joined_at = 8;
}

// Consumer client information
message ConsumerClient {
  // Client ID
  string client_id = 1;

  // Client host/IP address
  string client_host = 2;

  // Client application name
  string client_app = 3;

  // Client version
  string client_version = 4;

  // Client rack (for rack-aware assignment)
  string client_rack = 5;
}

// Individual consumer configuration
message ConsumerConfig {
  // Consumer timeout (milliseconds)
  int32 timeout_ms = 1;

  // Maximum messages to poll at once
  int32 max_poll_records = 2;

  // Fetch minimum bytes
  int32 fetch_min_bytes = 3;

  // Fetch maximum wait time (milliseconds)
  int32 fetch_max_wait_ms = 4;

  // Enable auto-offset reset
  bool auto_offset_reset = 5;

  // Consumer priority (for priority-based assignment)
  int32 priority = 6;
}

// Consumer statistics
message ConsumerStats {
  // Messages consumed
  int64 messages_consumed = 1;

  // Bytes consumed
  int64 bytes_consumed = 2;

  // Average consumption rate (messages/second)
  double consumption_rate = 3;

  // Lag behind latest offset
  int64 lag = 4;

  // Processing errors
  int64 processing_errors = 5;

  // Last consumption timestamp
  google.protobuf.Timestamp last_consumption = 6;
}

// Partition assignment for the group
message PartitionAssignment {
  // Partition ID
  int32 partition_id = 1;

  // Assigned consumer ID
  string consumer_id = 2;

  // Current offset position
  int64 current_offset = 3;

  // Committed offset
  int64 committed_offset = 4;

  // High water mark (latest available offset)
  int64 high_water_mark = 5;

  // Assignment timestamp
  google.protobuf.Timestamp assigned_at = 6;

  // Last commit timestamp
  google.protobuf.Timestamp last_commit = 7;
}

// Group coordinator information
message GroupCoordinator {
  // Coordinator node ID
  string node_id = 1;

  // Coordinator host
  string host = 2;

  // Coordinator port
  int32 port = 3;

  // Coordinator state
  CoordinatorState state = 4;

  // Leadership epoch
  int64 epoch = 5;
}

// Coordinator state
enum CoordinatorState {
  COORDINATOR_STATE_UNSPECIFIED = 0;
  COORDINATOR_STATE_ACTIVE = 1;               // Coordinator is active
  COORDINATOR_STATE_LOADING = 2;              // Coordinator is loading metadata
  COORDINATOR_STATE_NOT_COORDINATOR = 3;      // Node is not the coordinator
}

// Consumer group statistics
message ConsumerGroupStats {
  // Total number of active consumers
  int32 active_consumers = 1;

  // Total number of assigned partitions
  int32 assigned_partitions = 2;

  // Total messages consumed by the group
  int64 total_messages_consumed = 3;

  // Total bytes consumed by the group
  int64 total_bytes_consumed = 4;

  // Average group consumption rate (messages/second)
  double group_consumption_rate = 5;

  // Total group lag
  int64 total_lag = 6;

  // Rebalance statistics
  RebalanceStats rebalance_stats = 7;

  // Error statistics
  ErrorStats error_stats = 8;
}

// Rebalance statistics
message RebalanceStats {
  // Total number of rebalances
  int64 total_rebalances = 1;

  // Last rebalance timestamp
  google.protobuf.Timestamp last_rebalance = 2;

  // Average rebalance duration (milliseconds)
  int64 avg_rebalance_duration_ms = 3;

  // Failed rebalances
  int64 failed_rebalances = 4;
}

// Error statistics
message ErrorStats {
  // Total processing errors
  int64 total_errors = 1;

  // Connection errors
  int64 connection_errors = 2;

  // Timeout errors
  int64 timeout_errors = 3;

  // Serialization errors
  int64 serialization_errors = 4;

  // Last error timestamp
  google.protobuf.Timestamp last_error = 5;
}
