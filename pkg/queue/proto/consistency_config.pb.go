// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: pkg/queue/proto/consistency_config.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	_ "google.golang.org/protobuf/types/gofeaturespb"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Replication consistency level
type ReplicationLevel int32

const (
	ReplicationLevel_REPLICATION_LEVEL_UNSPECIFIED ReplicationLevel = 0
	ReplicationLevel_REPLICATION_LEVEL_ONE         ReplicationLevel = 1 // At least one replica
	ReplicationLevel_REPLICATION_LEVEL_QUORUM      ReplicationLevel = 2 // Majority of replicas
	ReplicationLevel_REPLICATION_LEVEL_ALL         ReplicationLevel = 3 // All replicas
)

// Enum value maps for ReplicationLevel.
var (
	ReplicationLevel_name = map[int32]string{
		0: "REPLICATION_LEVEL_UNSPECIFIED",
		1: "REPLICATION_LEVEL_ONE",
		2: "REPLICATION_LEVEL_QUORUM",
		3: "REPLICATION_LEVEL_ALL",
	}
	ReplicationLevel_value = map[string]int32{
		"REPLICATION_LEVEL_UNSPECIFIED": 0,
		"REPLICATION_LEVEL_ONE":         1,
		"REPLICATION_LEVEL_QUORUM":      2,
		"REPLICATION_LEVEL_ALL":         3,
	}
)

func (x ReplicationLevel) Enum() *ReplicationLevel {
	p := new(ReplicationLevel)
	*p = x
	return p
}

func (x ReplicationLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReplicationLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[0].Descriptor()
}

func (ReplicationLevel) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[0]
}

func (x ReplicationLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Read consistency level
type ReadLevel int32

const (
	ReadLevel_READ_LEVEL_UNSPECIFIED       ReadLevel = 0
	ReadLevel_READ_LEVEL_EVENTUAL          ReadLevel = 1 // Eventually consistent reads
	ReadLevel_READ_LEVEL_STRONG            ReadLevel = 2 // Strongly consistent reads
	ReadLevel_READ_LEVEL_BOUNDED_STALENESS ReadLevel = 3 // Bounded staleness reads
	ReadLevel_READ_LEVEL_SESSION           ReadLevel = 4 // Session consistency
)

// Enum value maps for ReadLevel.
var (
	ReadLevel_name = map[int32]string{
		0: "READ_LEVEL_UNSPECIFIED",
		1: "READ_LEVEL_EVENTUAL",
		2: "READ_LEVEL_STRONG",
		3: "READ_LEVEL_BOUNDED_STALENESS",
		4: "READ_LEVEL_SESSION",
	}
	ReadLevel_value = map[string]int32{
		"READ_LEVEL_UNSPECIFIED":       0,
		"READ_LEVEL_EVENTUAL":          1,
		"READ_LEVEL_STRONG":            2,
		"READ_LEVEL_BOUNDED_STALENESS": 3,
		"READ_LEVEL_SESSION":           4,
	}
)

func (x ReadLevel) Enum() *ReadLevel {
	p := new(ReadLevel)
	*p = x
	return p
}

func (x ReadLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReadLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[1].Descriptor()
}

func (ReadLevel) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[1]
}

func (x ReadLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Write consistency level
type WriteLevel int32

const (
	WriteLevel_WRITE_LEVEL_UNSPECIFIED WriteLevel = 0
	WriteLevel_WRITE_LEVEL_ASYNC       WriteLevel = 1 // Asynchronous writes
	WriteLevel_WRITE_LEVEL_SYNC_ONE    WriteLevel = 2 // Synchronous to one replica
	WriteLevel_WRITE_LEVEL_SYNC_QUORUM WriteLevel = 3 // Synchronous to quorum
	WriteLevel_WRITE_LEVEL_SYNC_ALL    WriteLevel = 4 // Synchronous to all replicas
)

// Enum value maps for WriteLevel.
var (
	WriteLevel_name = map[int32]string{
		0: "WRITE_LEVEL_UNSPECIFIED",
		1: "WRITE_LEVEL_ASYNC",
		2: "WRITE_LEVEL_SYNC_ONE",
		3: "WRITE_LEVEL_SYNC_QUORUM",
		4: "WRITE_LEVEL_SYNC_ALL",
	}
	WriteLevel_value = map[string]int32{
		"WRITE_LEVEL_UNSPECIFIED": 0,
		"WRITE_LEVEL_ASYNC":       1,
		"WRITE_LEVEL_SYNC_ONE":    2,
		"WRITE_LEVEL_SYNC_QUORUM": 3,
		"WRITE_LEVEL_SYNC_ALL":    4,
	}
)

func (x WriteLevel) Enum() *WriteLevel {
	p := new(WriteLevel)
	*p = x
	return p
}

func (x WriteLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WriteLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[2].Descriptor()
}

func (WriteLevel) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[2]
}

func (x WriteLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Conflict detection strategy
type ConflictStrategy int32

const (
	ConflictStrategy_CONFLICT_STRATEGY_UNSPECIFIED  ConflictStrategy = 0
	ConflictStrategy_CONFLICT_STRATEGY_TIMESTAMP    ConflictStrategy = 1 // Timestamp-based detection
	ConflictStrategy_CONFLICT_STRATEGY_VECTOR_CLOCK ConflictStrategy = 2 // Vector clock-based detection
	ConflictStrategy_CONFLICT_STRATEGY_CAUSAL       ConflictStrategy = 3 // Causal consistency detection
)

// Enum value maps for ConflictStrategy.
var (
	ConflictStrategy_name = map[int32]string{
		0: "CONFLICT_STRATEGY_UNSPECIFIED",
		1: "CONFLICT_STRATEGY_TIMESTAMP",
		2: "CONFLICT_STRATEGY_VECTOR_CLOCK",
		3: "CONFLICT_STRATEGY_CAUSAL",
	}
	ConflictStrategy_value = map[string]int32{
		"CONFLICT_STRATEGY_UNSPECIFIED":  0,
		"CONFLICT_STRATEGY_TIMESTAMP":    1,
		"CONFLICT_STRATEGY_VECTOR_CLOCK": 2,
		"CONFLICT_STRATEGY_CAUSAL":       3,
	}
)

func (x ConflictStrategy) Enum() *ConflictStrategy {
	p := new(ConflictStrategy)
	*p = x
	return p
}

func (x ConflictStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConflictStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[3].Descriptor()
}

func (ConflictStrategy) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[3]
}

func (x ConflictStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Ordering guarantee level
type OrderingLevel int32

const (
	OrderingLevel_ORDERING_LEVEL_UNSPECIFIED OrderingLevel = 0
	OrderingLevel_ORDERING_LEVEL_NONE        OrderingLevel = 1 // No ordering guarantees
	OrderingLevel_ORDERING_LEVEL_PARTIAL     OrderingLevel = 2 // Partial ordering
	OrderingLevel_ORDERING_LEVEL_TOTAL       OrderingLevel = 3 // Total ordering
)

// Enum value maps for OrderingLevel.
var (
	OrderingLevel_name = map[int32]string{
		0: "ORDERING_LEVEL_UNSPECIFIED",
		1: "ORDERING_LEVEL_NONE",
		2: "ORDERING_LEVEL_PARTIAL",
		3: "ORDERING_LEVEL_TOTAL",
	}
	OrderingLevel_value = map[string]int32{
		"ORDERING_LEVEL_UNSPECIFIED": 0,
		"ORDERING_LEVEL_NONE":        1,
		"ORDERING_LEVEL_PARTIAL":     2,
		"ORDERING_LEVEL_TOTAL":       3,
	}
)

func (x OrderingLevel) Enum() *OrderingLevel {
	p := new(OrderingLevel)
	*p = x
	return p
}

func (x OrderingLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderingLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[4].Descriptor()
}

func (OrderingLevel) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[4]
}

func (x OrderingLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Conflict resolution strategy
type ResolutionStrategy int32

const (
	ResolutionStrategy_RESOLUTION_STRATEGY_UNSPECIFIED       ResolutionStrategy = 0
	ResolutionStrategy_RESOLUTION_STRATEGY_LAST_WRITER_WINS  ResolutionStrategy = 1 // Last writer wins
	ResolutionStrategy_RESOLUTION_STRATEGY_FIRST_WRITER_WINS ResolutionStrategy = 2 // First writer wins
	ResolutionStrategy_RESOLUTION_STRATEGY_MERGE             ResolutionStrategy = 3 // Automatic merge
	ResolutionStrategy_RESOLUTION_STRATEGY_CUSTOM            ResolutionStrategy = 4 // Custom resolution function
	ResolutionStrategy_RESOLUTION_STRATEGY_MULTI_VALUE       ResolutionStrategy = 5 // Keep all conflicting values
)

// Enum value maps for ResolutionStrategy.
var (
	ResolutionStrategy_name = map[int32]string{
		0: "RESOLUTION_STRATEGY_UNSPECIFIED",
		1: "RESOLUTION_STRATEGY_LAST_WRITER_WINS",
		2: "RESOLUTION_STRATEGY_FIRST_WRITER_WINS",
		3: "RESOLUTION_STRATEGY_MERGE",
		4: "RESOLUTION_STRATEGY_CUSTOM",
		5: "RESOLUTION_STRATEGY_MULTI_VALUE",
	}
	ResolutionStrategy_value = map[string]int32{
		"RESOLUTION_STRATEGY_UNSPECIFIED":       0,
		"RESOLUTION_STRATEGY_LAST_WRITER_WINS":  1,
		"RESOLUTION_STRATEGY_FIRST_WRITER_WINS": 2,
		"RESOLUTION_STRATEGY_MERGE":             3,
		"RESOLUTION_STRATEGY_CUSTOM":            4,
		"RESOLUTION_STRATEGY_MULTI_VALUE":       5,
	}
)

func (x ResolutionStrategy) Enum() *ResolutionStrategy {
	p := new(ResolutionStrategy)
	*p = x
	return p
}

func (x ResolutionStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResolutionStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[5].Descriptor()
}

func (ResolutionStrategy) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[5]
}

func (x ResolutionStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// ConsistencyConfig configures data consistency and messaging guarantees
type ConsistencyConfig struct {
	state                         protoimpl.MessageState  `protogen:"opaque.v1"`
	xxx_hidden_DurabilityLevel    DurabilityLevel         `protobuf:"varint,1,opt,name=durability_level,json=durabilityLevel,enum=gcommon.v1.queue.DurabilityLevel"`
	xxx_hidden_AckLevel           AckLevel                `protobuf:"varint,2,opt,name=ack_level,json=ackLevel,enum=gcommon.v1.queue.AckLevel"`
	xxx_hidden_Replication        *ReplicationConsistency `protobuf:"bytes,3,opt,name=replication"`
	xxx_hidden_ReadConsistency    *ReadConsistency        `protobuf:"bytes,4,opt,name=read_consistency,json=readConsistency"`
	xxx_hidden_WriteConsistency   *WriteConsistency       `protobuf:"bytes,5,opt,name=write_consistency,json=writeConsistency"`
	xxx_hidden_Ordering           *OrderingConfig         `protobuf:"bytes,6,opt,name=ordering"`
	xxx_hidden_ConflictResolution *ConflictResolution     `protobuf:"bytes,7,opt,name=conflict_resolution,json=conflictResolution"`
	xxx_hidden_Validation         *ConsistencyValidation  `protobuf:"bytes,8,opt,name=validation"`
	XXX_raceDetectHookData        protoimpl.RaceDetectHookData
	XXX_presence                  [1]uint32
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *ConsistencyConfig) Reset() {
	*x = ConsistencyConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConsistencyConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConsistencyConfig) ProtoMessage() {}

func (x *ConsistencyConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ConsistencyConfig) GetDurabilityLevel() DurabilityLevel {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 0) {
			return x.xxx_hidden_DurabilityLevel
		}
	}
	return DurabilityLevel_DURABILITY_LEVEL_UNSPECIFIED
}

func (x *ConsistencyConfig) GetAckLevel() AckLevel {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 1) {
			return x.xxx_hidden_AckLevel
		}
	}
	return AckLevel_ACK_LEVEL_UNSPECIFIED
}

func (x *ConsistencyConfig) GetReplication() *ReplicationConsistency {
	if x != nil {
		return x.xxx_hidden_Replication
	}
	return nil
}

func (x *ConsistencyConfig) GetReadConsistency() *ReadConsistency {
	if x != nil {
		return x.xxx_hidden_ReadConsistency
	}
	return nil
}

func (x *ConsistencyConfig) GetWriteConsistency() *WriteConsistency {
	if x != nil {
		return x.xxx_hidden_WriteConsistency
	}
	return nil
}

func (x *ConsistencyConfig) GetOrdering() *OrderingConfig {
	if x != nil {
		return x.xxx_hidden_Ordering
	}
	return nil
}

func (x *ConsistencyConfig) GetConflictResolution() *ConflictResolution {
	if x != nil {
		return x.xxx_hidden_ConflictResolution
	}
	return nil
}

func (x *ConsistencyConfig) GetValidation() *ConsistencyValidation {
	if x != nil {
		return x.xxx_hidden_Validation
	}
	return nil
}

func (x *ConsistencyConfig) SetDurabilityLevel(v DurabilityLevel) {
	x.xxx_hidden_DurabilityLevel = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 8)
}

func (x *ConsistencyConfig) SetAckLevel(v AckLevel) {
	x.xxx_hidden_AckLevel = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 8)
}

func (x *ConsistencyConfig) SetReplication(v *ReplicationConsistency) {
	x.xxx_hidden_Replication = v
}

func (x *ConsistencyConfig) SetReadConsistency(v *ReadConsistency) {
	x.xxx_hidden_ReadConsistency = v
}

func (x *ConsistencyConfig) SetWriteConsistency(v *WriteConsistency) {
	x.xxx_hidden_WriteConsistency = v
}

func (x *ConsistencyConfig) SetOrdering(v *OrderingConfig) {
	x.xxx_hidden_Ordering = v
}

func (x *ConsistencyConfig) SetConflictResolution(v *ConflictResolution) {
	x.xxx_hidden_ConflictResolution = v
}

func (x *ConsistencyConfig) SetValidation(v *ConsistencyValidation) {
	x.xxx_hidden_Validation = v
}

func (x *ConsistencyConfig) HasDurabilityLevel() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *ConsistencyConfig) HasAckLevel() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *ConsistencyConfig) HasReplication() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Replication != nil
}

func (x *ConsistencyConfig) HasReadConsistency() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_ReadConsistency != nil
}

func (x *ConsistencyConfig) HasWriteConsistency() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_WriteConsistency != nil
}

func (x *ConsistencyConfig) HasOrdering() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Ordering != nil
}

func (x *ConsistencyConfig) HasConflictResolution() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_ConflictResolution != nil
}

func (x *ConsistencyConfig) HasValidation() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Validation != nil
}

func (x *ConsistencyConfig) ClearDurabilityLevel() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_DurabilityLevel = DurabilityLevel_DURABILITY_LEVEL_UNSPECIFIED
}

func (x *ConsistencyConfig) ClearAckLevel() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_AckLevel = AckLevel_ACK_LEVEL_UNSPECIFIED
}

func (x *ConsistencyConfig) ClearReplication() {
	x.xxx_hidden_Replication = nil
}

func (x *ConsistencyConfig) ClearReadConsistency() {
	x.xxx_hidden_ReadConsistency = nil
}

func (x *ConsistencyConfig) ClearWriteConsistency() {
	x.xxx_hidden_WriteConsistency = nil
}

func (x *ConsistencyConfig) ClearOrdering() {
	x.xxx_hidden_Ordering = nil
}

func (x *ConsistencyConfig) ClearConflictResolution() {
	x.xxx_hidden_ConflictResolution = nil
}

func (x *ConsistencyConfig) ClearValidation() {
	x.xxx_hidden_Validation = nil
}

type ConsistencyConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Durability level for message persistence
	DurabilityLevel *DurabilityLevel
	// Acknowledgment level required for message delivery
	AckLevel *AckLevel
	// Replication configuration
	Replication *ReplicationConsistency
	// Read consistency settings
	ReadConsistency *ReadConsistency
	// Write consistency settings
	WriteConsistency *WriteConsistency
	// Ordering guarantees
	Ordering *OrderingConfig
	// Conflict resolution settings
	ConflictResolution *ConflictResolution
	// Consistency validation settings
	Validation *ConsistencyValidation
}

func (b0 ConsistencyConfig_builder) Build() *ConsistencyConfig {
	m0 := &ConsistencyConfig{}
	b, x := &b0, m0
	_, _ = b, x
	if b.DurabilityLevel != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 8)
		x.xxx_hidden_DurabilityLevel = *b.DurabilityLevel
	}
	if b.AckLevel != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 8)
		x.xxx_hidden_AckLevel = *b.AckLevel
	}
	x.xxx_hidden_Replication = b.Replication
	x.xxx_hidden_ReadConsistency = b.ReadConsistency
	x.xxx_hidden_WriteConsistency = b.WriteConsistency
	x.xxx_hidden_Ordering = b.Ordering
	x.xxx_hidden_ConflictResolution = b.ConflictResolution
	x.xxx_hidden_Validation = b.Validation
	return m0
}

// Replication consistency configuration
type ReplicationConsistency struct {
	state                            protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_MinWriteReplicas      int32                  `protobuf:"varint,1,opt,name=min_write_replicas,json=minWriteReplicas"`
	xxx_hidden_MinReadReplicas       int32                  `protobuf:"varint,2,opt,name=min_read_replicas,json=minReadReplicas"`
	xxx_hidden_ReplicationFactor     int32                  `protobuf:"varint,3,opt,name=replication_factor,json=replicationFactor"`
	xxx_hidden_ReplicationLevel      ReplicationLevel       `protobuf:"varint,4,opt,name=replication_level,json=replicationLevel,enum=gcommon.v1.queue.ReplicationLevel"`
	xxx_hidden_AntiEntropyEnabled    bool                   `protobuf:"varint,5,opt,name=anti_entropy_enabled,json=antiEntropyEnabled"`
	xxx_hidden_RepairIntervalSeconds int32                  `protobuf:"varint,6,opt,name=repair_interval_seconds,json=repairIntervalSeconds"`
	XXX_raceDetectHookData           protoimpl.RaceDetectHookData
	XXX_presence                     [1]uint32
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *ReplicationConsistency) Reset() {
	*x = ReplicationConsistency{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationConsistency) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationConsistency) ProtoMessage() {}

func (x *ReplicationConsistency) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ReplicationConsistency) GetMinWriteReplicas() int32 {
	if x != nil {
		return x.xxx_hidden_MinWriteReplicas
	}
	return 0
}

func (x *ReplicationConsistency) GetMinReadReplicas() int32 {
	if x != nil {
		return x.xxx_hidden_MinReadReplicas
	}
	return 0
}

func (x *ReplicationConsistency) GetReplicationFactor() int32 {
	if x != nil {
		return x.xxx_hidden_ReplicationFactor
	}
	return 0
}

func (x *ReplicationConsistency) GetReplicationLevel() ReplicationLevel {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 3) {
			return x.xxx_hidden_ReplicationLevel
		}
	}
	return ReplicationLevel_REPLICATION_LEVEL_UNSPECIFIED
}

func (x *ReplicationConsistency) GetAntiEntropyEnabled() bool {
	if x != nil {
		return x.xxx_hidden_AntiEntropyEnabled
	}
	return false
}

func (x *ReplicationConsistency) GetRepairIntervalSeconds() int32 {
	if x != nil {
		return x.xxx_hidden_RepairIntervalSeconds
	}
	return 0
}

func (x *ReplicationConsistency) SetMinWriteReplicas(v int32) {
	x.xxx_hidden_MinWriteReplicas = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 6)
}

func (x *ReplicationConsistency) SetMinReadReplicas(v int32) {
	x.xxx_hidden_MinReadReplicas = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 6)
}

func (x *ReplicationConsistency) SetReplicationFactor(v int32) {
	x.xxx_hidden_ReplicationFactor = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 6)
}

func (x *ReplicationConsistency) SetReplicationLevel(v ReplicationLevel) {
	x.xxx_hidden_ReplicationLevel = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 6)
}

func (x *ReplicationConsistency) SetAntiEntropyEnabled(v bool) {
	x.xxx_hidden_AntiEntropyEnabled = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 6)
}

func (x *ReplicationConsistency) SetRepairIntervalSeconds(v int32) {
	x.xxx_hidden_RepairIntervalSeconds = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 5, 6)
}

func (x *ReplicationConsistency) HasMinWriteReplicas() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *ReplicationConsistency) HasMinReadReplicas() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *ReplicationConsistency) HasReplicationFactor() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *ReplicationConsistency) HasReplicationLevel() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *ReplicationConsistency) HasAntiEntropyEnabled() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *ReplicationConsistency) HasRepairIntervalSeconds() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 5)
}

func (x *ReplicationConsistency) ClearMinWriteReplicas() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_MinWriteReplicas = 0
}

func (x *ReplicationConsistency) ClearMinReadReplicas() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_MinReadReplicas = 0
}

func (x *ReplicationConsistency) ClearReplicationFactor() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_ReplicationFactor = 0
}

func (x *ReplicationConsistency) ClearReplicationLevel() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_ReplicationLevel = ReplicationLevel_REPLICATION_LEVEL_UNSPECIFIED
}

func (x *ReplicationConsistency) ClearAntiEntropyEnabled() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_AntiEntropyEnabled = false
}

func (x *ReplicationConsistency) ClearRepairIntervalSeconds() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 5)
	x.xxx_hidden_RepairIntervalSeconds = 0
}

type ReplicationConsistency_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Minimum number of replicas that must acknowledge writes
	MinWriteReplicas *int32
	// Minimum number of replicas that must be available for reads
	MinReadReplicas *int32
	// Replication factor (total number of replicas)
	ReplicationFactor *int32
	// Consistency level for replication
	ReplicationLevel *ReplicationLevel
	// Enable anti-entropy repair
	AntiEntropyEnabled *bool
	// Anti-entropy repair interval (seconds)
	RepairIntervalSeconds *int32
}

func (b0 ReplicationConsistency_builder) Build() *ReplicationConsistency {
	m0 := &ReplicationConsistency{}
	b, x := &b0, m0
	_, _ = b, x
	if b.MinWriteReplicas != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 6)
		x.xxx_hidden_MinWriteReplicas = *b.MinWriteReplicas
	}
	if b.MinReadReplicas != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 6)
		x.xxx_hidden_MinReadReplicas = *b.MinReadReplicas
	}
	if b.ReplicationFactor != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 6)
		x.xxx_hidden_ReplicationFactor = *b.ReplicationFactor
	}
	if b.ReplicationLevel != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 6)
		x.xxx_hidden_ReplicationLevel = *b.ReplicationLevel
	}
	if b.AntiEntropyEnabled != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 6)
		x.xxx_hidden_AntiEntropyEnabled = *b.AntiEntropyEnabled
	}
	if b.RepairIntervalSeconds != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 5, 6)
		x.xxx_hidden_RepairIntervalSeconds = *b.RepairIntervalSeconds
	}
	return m0
}

// Read consistency configuration
type ReadConsistency struct {
	state                     protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Level          ReadLevel              `protobuf:"varint,1,opt,name=level,enum=gcommon.v1.queue.ReadLevel"`
	xxx_hidden_MaxStalenessMs int64                  `protobuf:"varint,2,opt,name=max_staleness_ms,json=maxStalenessMs"`
	xxx_hidden_ReadYourWrites bool                   `protobuf:"varint,3,opt,name=read_your_writes,json=readYourWrites"`
	xxx_hidden_MonotonicReads bool                   `protobuf:"varint,4,opt,name=monotonic_reads,json=monotonicReads"`
	xxx_hidden_TimeoutMs      int32                  `protobuf:"varint,5,opt,name=timeout_ms,json=timeoutMs"`
	xxx_hidden_RetryConfig    *ReadRetryConfig       `protobuf:"bytes,6,opt,name=retry_config,json=retryConfig"`
	XXX_raceDetectHookData    protoimpl.RaceDetectHookData
	XXX_presence              [1]uint32
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *ReadConsistency) Reset() {
	*x = ReadConsistency{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadConsistency) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadConsistency) ProtoMessage() {}

func (x *ReadConsistency) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ReadConsistency) GetLevel() ReadLevel {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 0) {
			return x.xxx_hidden_Level
		}
	}
	return ReadLevel_READ_LEVEL_UNSPECIFIED
}

func (x *ReadConsistency) GetMaxStalenessMs() int64 {
	if x != nil {
		return x.xxx_hidden_MaxStalenessMs
	}
	return 0
}

func (x *ReadConsistency) GetReadYourWrites() bool {
	if x != nil {
		return x.xxx_hidden_ReadYourWrites
	}
	return false
}

func (x *ReadConsistency) GetMonotonicReads() bool {
	if x != nil {
		return x.xxx_hidden_MonotonicReads
	}
	return false
}

func (x *ReadConsistency) GetTimeoutMs() int32 {
	if x != nil {
		return x.xxx_hidden_TimeoutMs
	}
	return 0
}

func (x *ReadConsistency) GetRetryConfig() *ReadRetryConfig {
	if x != nil {
		return x.xxx_hidden_RetryConfig
	}
	return nil
}

func (x *ReadConsistency) SetLevel(v ReadLevel) {
	x.xxx_hidden_Level = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 6)
}

func (x *ReadConsistency) SetMaxStalenessMs(v int64) {
	x.xxx_hidden_MaxStalenessMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 6)
}

func (x *ReadConsistency) SetReadYourWrites(v bool) {
	x.xxx_hidden_ReadYourWrites = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 6)
}

func (x *ReadConsistency) SetMonotonicReads(v bool) {
	x.xxx_hidden_MonotonicReads = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 6)
}

func (x *ReadConsistency) SetTimeoutMs(v int32) {
	x.xxx_hidden_TimeoutMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 6)
}

func (x *ReadConsistency) SetRetryConfig(v *ReadRetryConfig) {
	x.xxx_hidden_RetryConfig = v
}

func (x *ReadConsistency) HasLevel() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *ReadConsistency) HasMaxStalenessMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *ReadConsistency) HasReadYourWrites() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *ReadConsistency) HasMonotonicReads() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *ReadConsistency) HasTimeoutMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *ReadConsistency) HasRetryConfig() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_RetryConfig != nil
}

func (x *ReadConsistency) ClearLevel() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Level = ReadLevel_READ_LEVEL_UNSPECIFIED
}

func (x *ReadConsistency) ClearMaxStalenessMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_MaxStalenessMs = 0
}

func (x *ReadConsistency) ClearReadYourWrites() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_ReadYourWrites = false
}

func (x *ReadConsistency) ClearMonotonicReads() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_MonotonicReads = false
}

func (x *ReadConsistency) ClearTimeoutMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_TimeoutMs = 0
}

func (x *ReadConsistency) ClearRetryConfig() {
	x.xxx_hidden_RetryConfig = nil
}

type ReadConsistency_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Read consistency level
	Level *ReadLevel
	// Maximum staleness allowed for reads (milliseconds)
	MaxStalenessMs *int64
	// Enable read-your-writes consistency
	ReadYourWrites *bool
	// Enable monotonic read consistency
	MonotonicReads *bool
	// Timeout for read operations (milliseconds)
	TimeoutMs *int32
	// Retry configuration for read failures
	RetryConfig *ReadRetryConfig
}

func (b0 ReadConsistency_builder) Build() *ReadConsistency {
	m0 := &ReadConsistency{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Level != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 6)
		x.xxx_hidden_Level = *b.Level
	}
	if b.MaxStalenessMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 6)
		x.xxx_hidden_MaxStalenessMs = *b.MaxStalenessMs
	}
	if b.ReadYourWrites != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 6)
		x.xxx_hidden_ReadYourWrites = *b.ReadYourWrites
	}
	if b.MonotonicReads != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 6)
		x.xxx_hidden_MonotonicReads = *b.MonotonicReads
	}
	if b.TimeoutMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 6)
		x.xxx_hidden_TimeoutMs = *b.TimeoutMs
	}
	x.xxx_hidden_RetryConfig = b.RetryConfig
	return m0
}

// Write consistency configuration
type WriteConsistency struct {
	state                        protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Level             WriteLevel             `protobuf:"varint,1,opt,name=level,enum=gcommon.v1.queue.WriteLevel"`
	xxx_hidden_SyncReplication   *SyncReplication       `protobuf:"bytes,2,opt,name=sync_replication,json=syncReplication"`
	xxx_hidden_ConflictDetection *ConflictDetection     `protobuf:"bytes,3,opt,name=conflict_detection,json=conflictDetection"`
	xxx_hidden_TimeoutMs         int32                  `protobuf:"varint,4,opt,name=timeout_ms,json=timeoutMs"`
	xxx_hidden_RetryConfig       *WriteRetryConfig      `protobuf:"bytes,5,opt,name=retry_config,json=retryConfig"`
	XXX_raceDetectHookData       protoimpl.RaceDetectHookData
	XXX_presence                 [1]uint32
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *WriteConsistency) Reset() {
	*x = WriteConsistency{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteConsistency) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteConsistency) ProtoMessage() {}

func (x *WriteConsistency) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *WriteConsistency) GetLevel() WriteLevel {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 0) {
			return x.xxx_hidden_Level
		}
	}
	return WriteLevel_WRITE_LEVEL_UNSPECIFIED
}

func (x *WriteConsistency) GetSyncReplication() *SyncReplication {
	if x != nil {
		return x.xxx_hidden_SyncReplication
	}
	return nil
}

func (x *WriteConsistency) GetConflictDetection() *ConflictDetection {
	if x != nil {
		return x.xxx_hidden_ConflictDetection
	}
	return nil
}

func (x *WriteConsistency) GetTimeoutMs() int32 {
	if x != nil {
		return x.xxx_hidden_TimeoutMs
	}
	return 0
}

func (x *WriteConsistency) GetRetryConfig() *WriteRetryConfig {
	if x != nil {
		return x.xxx_hidden_RetryConfig
	}
	return nil
}

func (x *WriteConsistency) SetLevel(v WriteLevel) {
	x.xxx_hidden_Level = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 5)
}

func (x *WriteConsistency) SetSyncReplication(v *SyncReplication) {
	x.xxx_hidden_SyncReplication = v
}

func (x *WriteConsistency) SetConflictDetection(v *ConflictDetection) {
	x.xxx_hidden_ConflictDetection = v
}

func (x *WriteConsistency) SetTimeoutMs(v int32) {
	x.xxx_hidden_TimeoutMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 5)
}

func (x *WriteConsistency) SetRetryConfig(v *WriteRetryConfig) {
	x.xxx_hidden_RetryConfig = v
}

func (x *WriteConsistency) HasLevel() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *WriteConsistency) HasSyncReplication() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_SyncReplication != nil
}

func (x *WriteConsistency) HasConflictDetection() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_ConflictDetection != nil
}

func (x *WriteConsistency) HasTimeoutMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *WriteConsistency) HasRetryConfig() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_RetryConfig != nil
}

func (x *WriteConsistency) ClearLevel() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Level = WriteLevel_WRITE_LEVEL_UNSPECIFIED
}

func (x *WriteConsistency) ClearSyncReplication() {
	x.xxx_hidden_SyncReplication = nil
}

func (x *WriteConsistency) ClearConflictDetection() {
	x.xxx_hidden_ConflictDetection = nil
}

func (x *WriteConsistency) ClearTimeoutMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_TimeoutMs = 0
}

func (x *WriteConsistency) ClearRetryConfig() {
	x.xxx_hidden_RetryConfig = nil
}

type WriteConsistency_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Write consistency level
	Level *WriteLevel
	// Synchronous replication requirements
	SyncReplication *SyncReplication
	// Write conflict detection
	ConflictDetection *ConflictDetection
	// Timeout for write operations (milliseconds)
	TimeoutMs *int32
	// Retry configuration for write failures
	RetryConfig *WriteRetryConfig
}

func (b0 WriteConsistency_builder) Build() *WriteConsistency {
	m0 := &WriteConsistency{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Level != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 5)
		x.xxx_hidden_Level = *b.Level
	}
	x.xxx_hidden_SyncReplication = b.SyncReplication
	x.xxx_hidden_ConflictDetection = b.ConflictDetection
	if b.TimeoutMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 5)
		x.xxx_hidden_TimeoutMs = *b.TimeoutMs
	}
	x.xxx_hidden_RetryConfig = b.RetryConfig
	return m0
}

// Synchronous replication configuration
type SyncReplication struct {
	state                      protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Enabled         bool                   `protobuf:"varint,1,opt,name=enabled"`
	xxx_hidden_MinSyncReplicas int32                  `protobuf:"varint,2,opt,name=min_sync_replicas,json=minSyncReplicas"`
	xxx_hidden_SyncTimeoutMs   int32                  `protobuf:"varint,3,opt,name=sync_timeout_ms,json=syncTimeoutMs"`
	xxx_hidden_FallbackToAsync bool                   `protobuf:"varint,4,opt,name=fallback_to_async,json=fallbackToAsync"`
	XXX_raceDetectHookData     protoimpl.RaceDetectHookData
	XXX_presence               [1]uint32
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *SyncReplication) Reset() {
	*x = SyncReplication{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncReplication) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncReplication) ProtoMessage() {}

func (x *SyncReplication) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SyncReplication) GetEnabled() bool {
	if x != nil {
		return x.xxx_hidden_Enabled
	}
	return false
}

func (x *SyncReplication) GetMinSyncReplicas() int32 {
	if x != nil {
		return x.xxx_hidden_MinSyncReplicas
	}
	return 0
}

func (x *SyncReplication) GetSyncTimeoutMs() int32 {
	if x != nil {
		return x.xxx_hidden_SyncTimeoutMs
	}
	return 0
}

func (x *SyncReplication) GetFallbackToAsync() bool {
	if x != nil {
		return x.xxx_hidden_FallbackToAsync
	}
	return false
}

func (x *SyncReplication) SetEnabled(v bool) {
	x.xxx_hidden_Enabled = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 4)
}

func (x *SyncReplication) SetMinSyncReplicas(v int32) {
	x.xxx_hidden_MinSyncReplicas = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 4)
}

func (x *SyncReplication) SetSyncTimeoutMs(v int32) {
	x.xxx_hidden_SyncTimeoutMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 4)
}

func (x *SyncReplication) SetFallbackToAsync(v bool) {
	x.xxx_hidden_FallbackToAsync = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 4)
}

func (x *SyncReplication) HasEnabled() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *SyncReplication) HasMinSyncReplicas() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *SyncReplication) HasSyncTimeoutMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *SyncReplication) HasFallbackToAsync() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *SyncReplication) ClearEnabled() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Enabled = false
}

func (x *SyncReplication) ClearMinSyncReplicas() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_MinSyncReplicas = 0
}

func (x *SyncReplication) ClearSyncTimeoutMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_SyncTimeoutMs = 0
}

func (x *SyncReplication) ClearFallbackToAsync() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_FallbackToAsync = false
}

type SyncReplication_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Enable synchronous replication
	Enabled *bool
	// Minimum synchronous replicas
	MinSyncReplicas *int32
	// Timeout for synchronous replication (milliseconds)
	SyncTimeoutMs *int32
	// Fallback to async on timeout
	FallbackToAsync *bool
}

func (b0 SyncReplication_builder) Build() *SyncReplication {
	m0 := &SyncReplication{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Enabled != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 4)
		x.xxx_hidden_Enabled = *b.Enabled
	}
	if b.MinSyncReplicas != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 4)
		x.xxx_hidden_MinSyncReplicas = *b.MinSyncReplicas
	}
	if b.SyncTimeoutMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 4)
		x.xxx_hidden_SyncTimeoutMs = *b.SyncTimeoutMs
	}
	if b.FallbackToAsync != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 4)
		x.xxx_hidden_FallbackToAsync = *b.FallbackToAsync
	}
	return m0
}

// Conflict detection configuration
type ConflictDetection struct {
	state                      protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Enabled         bool                   `protobuf:"varint,1,opt,name=enabled"`
	xxx_hidden_Strategy        ConflictStrategy       `protobuf:"varint,2,opt,name=strategy,enum=gcommon.v1.queue.ConflictStrategy"`
	xxx_hidden_VectorClock     *VectorClockConfig     `protobuf:"bytes,3,opt,name=vector_clock,json=vectorClock"`
	xxx_hidden_TimestampConfig *TimestampConfig       `protobuf:"bytes,4,opt,name=timestamp_config,json=timestampConfig"`
	XXX_raceDetectHookData     protoimpl.RaceDetectHookData
	XXX_presence               [1]uint32
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *ConflictDetection) Reset() {
	*x = ConflictDetection{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConflictDetection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConflictDetection) ProtoMessage() {}

func (x *ConflictDetection) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ConflictDetection) GetEnabled() bool {
	if x != nil {
		return x.xxx_hidden_Enabled
	}
	return false
}

func (x *ConflictDetection) GetStrategy() ConflictStrategy {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 1) {
			return x.xxx_hidden_Strategy
		}
	}
	return ConflictStrategy_CONFLICT_STRATEGY_UNSPECIFIED
}

func (x *ConflictDetection) GetVectorClock() *VectorClockConfig {
	if x != nil {
		return x.xxx_hidden_VectorClock
	}
	return nil
}

func (x *ConflictDetection) GetTimestampConfig() *TimestampConfig {
	if x != nil {
		return x.xxx_hidden_TimestampConfig
	}
	return nil
}

func (x *ConflictDetection) SetEnabled(v bool) {
	x.xxx_hidden_Enabled = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 4)
}

func (x *ConflictDetection) SetStrategy(v ConflictStrategy) {
	x.xxx_hidden_Strategy = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 4)
}

func (x *ConflictDetection) SetVectorClock(v *VectorClockConfig) {
	x.xxx_hidden_VectorClock = v
}

func (x *ConflictDetection) SetTimestampConfig(v *TimestampConfig) {
	x.xxx_hidden_TimestampConfig = v
}

func (x *ConflictDetection) HasEnabled() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *ConflictDetection) HasStrategy() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *ConflictDetection) HasVectorClock() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_VectorClock != nil
}

func (x *ConflictDetection) HasTimestampConfig() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_TimestampConfig != nil
}

func (x *ConflictDetection) ClearEnabled() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Enabled = false
}

func (x *ConflictDetection) ClearStrategy() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_Strategy = ConflictStrategy_CONFLICT_STRATEGY_UNSPECIFIED
}

func (x *ConflictDetection) ClearVectorClock() {
	x.xxx_hidden_VectorClock = nil
}

func (x *ConflictDetection) ClearTimestampConfig() {
	x.xxx_hidden_TimestampConfig = nil
}

type ConflictDetection_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Enable conflict detection
	Enabled *bool
	// Conflict detection strategy
	Strategy *ConflictStrategy
	// Vector clock configuration
	VectorClock *VectorClockConfig
	// Timestamp-based detection settings
	TimestampConfig *TimestampConfig
}

func (b0 ConflictDetection_builder) Build() *ConflictDetection {
	m0 := &ConflictDetection{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Enabled != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 4)
		x.xxx_hidden_Enabled = *b.Enabled
	}
	if b.Strategy != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 4)
		x.xxx_hidden_Strategy = *b.Strategy
	}
	x.xxx_hidden_VectorClock = b.VectorClock
	x.xxx_hidden_TimestampConfig = b.TimestampConfig
	return m0
}

// Vector clock configuration
type VectorClockConfig struct {
	state                  protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Enabled     bool                   `protobuf:"varint,1,opt,name=enabled"`
	xxx_hidden_Precision   *string                `protobuf:"bytes,2,opt,name=precision"`
	xxx_hidden_MaxDriftMs  int64                  `protobuf:"varint,3,opt,name=max_drift_ms,json=maxDriftMs"`
	XXX_raceDetectHookData protoimpl.RaceDetectHookData
	XXX_presence           [1]uint32
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *VectorClockConfig) Reset() {
	*x = VectorClockConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VectorClockConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VectorClockConfig) ProtoMessage() {}

func (x *VectorClockConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *VectorClockConfig) GetEnabled() bool {
	if x != nil {
		return x.xxx_hidden_Enabled
	}
	return false
}

func (x *VectorClockConfig) GetPrecision() string {
	if x != nil {
		if x.xxx_hidden_Precision != nil {
			return *x.xxx_hidden_Precision
		}
		return ""
	}
	return ""
}

func (x *VectorClockConfig) GetMaxDriftMs() int64 {
	if x != nil {
		return x.xxx_hidden_MaxDriftMs
	}
	return 0
}

func (x *VectorClockConfig) SetEnabled(v bool) {
	x.xxx_hidden_Enabled = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 3)
}

func (x *VectorClockConfig) SetPrecision(v string) {
	x.xxx_hidden_Precision = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 3)
}

func (x *VectorClockConfig) SetMaxDriftMs(v int64) {
	x.xxx_hidden_MaxDriftMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 3)
}

func (x *VectorClockConfig) HasEnabled() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *VectorClockConfig) HasPrecision() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *VectorClockConfig) HasMaxDriftMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *VectorClockConfig) ClearEnabled() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Enabled = false
}

func (x *VectorClockConfig) ClearPrecision() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_Precision = nil
}

func (x *VectorClockConfig) ClearMaxDriftMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_MaxDriftMs = 0
}

type VectorClockConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Enable vector clocks
	Enabled *bool
	// Clock precision (nanoseconds, microseconds, milliseconds)
	Precision *string
	// Maximum clock drift tolerance (milliseconds)
	MaxDriftMs *int64
}

func (b0 VectorClockConfig_builder) Build() *VectorClockConfig {
	m0 := &VectorClockConfig{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Enabled != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 3)
		x.xxx_hidden_Enabled = *b.Enabled
	}
	if b.Precision != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 3)
		x.xxx_hidden_Precision = b.Precision
	}
	if b.MaxDriftMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 3)
		x.xxx_hidden_MaxDriftMs = *b.MaxDriftMs
	}
	return m0
}

// Timestamp configuration
type TimestampConfig struct {
	state                          protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Source              *string                `protobuf:"bytes,1,opt,name=source"`
	xxx_hidden_SyncIntervalSeconds int32                  `protobuf:"varint,2,opt,name=sync_interval_seconds,json=syncIntervalSeconds"`
	xxx_hidden_MaxSkewMs           int64                  `protobuf:"varint,3,opt,name=max_skew_ms,json=maxSkewMs"`
	XXX_raceDetectHookData         protoimpl.RaceDetectHookData
	XXX_presence                   [1]uint32
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *TimestampConfig) Reset() {
	*x = TimestampConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimestampConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimestampConfig) ProtoMessage() {}

func (x *TimestampConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TimestampConfig) GetSource() string {
	if x != nil {
		if x.xxx_hidden_Source != nil {
			return *x.xxx_hidden_Source
		}
		return ""
	}
	return ""
}

func (x *TimestampConfig) GetSyncIntervalSeconds() int32 {
	if x != nil {
		return x.xxx_hidden_SyncIntervalSeconds
	}
	return 0
}

func (x *TimestampConfig) GetMaxSkewMs() int64 {
	if x != nil {
		return x.xxx_hidden_MaxSkewMs
	}
	return 0
}

func (x *TimestampConfig) SetSource(v string) {
	x.xxx_hidden_Source = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 3)
}

func (x *TimestampConfig) SetSyncIntervalSeconds(v int32) {
	x.xxx_hidden_SyncIntervalSeconds = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 3)
}

func (x *TimestampConfig) SetMaxSkewMs(v int64) {
	x.xxx_hidden_MaxSkewMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 3)
}

func (x *TimestampConfig) HasSource() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *TimestampConfig) HasSyncIntervalSeconds() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *TimestampConfig) HasMaxSkewMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *TimestampConfig) ClearSource() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Source = nil
}

func (x *TimestampConfig) ClearSyncIntervalSeconds() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_SyncIntervalSeconds = 0
}

func (x *TimestampConfig) ClearMaxSkewMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_MaxSkewMs = 0
}

type TimestampConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Timestamp source (system, ntp, atomic)
	Source *string
	// Clock synchronization interval (seconds)
	SyncIntervalSeconds *int32
	// Maximum timestamp skew tolerance (milliseconds)
	MaxSkewMs *int64
}

func (b0 TimestampConfig_builder) Build() *TimestampConfig {
	m0 := &TimestampConfig{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Source != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 3)
		x.xxx_hidden_Source = b.Source
	}
	if b.SyncIntervalSeconds != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 3)
		x.xxx_hidden_SyncIntervalSeconds = *b.SyncIntervalSeconds
	}
	if b.MaxSkewMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 3)
		x.xxx_hidden_MaxSkewMs = *b.MaxSkewMs
	}
	return m0
}

// Message ordering configuration
type OrderingConfig struct {
	state                        protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_GlobalOrdering    OrderingLevel          `protobuf:"varint,1,opt,name=global_ordering,json=globalOrdering,enum=gcommon.v1.queue.OrderingLevel"`
	xxx_hidden_PartitionOrdering OrderingLevel          `protobuf:"varint,2,opt,name=partition_ordering,json=partitionOrdering,enum=gcommon.v1.queue.OrderingLevel"`
	xxx_hidden_ProducerOrdering  OrderingLevel          `protobuf:"varint,3,opt,name=producer_ordering,json=producerOrdering,enum=gcommon.v1.queue.OrderingLevel"`
	xxx_hidden_CausalOrdering    bool                   `protobuf:"varint,4,opt,name=causal_ordering,json=causalOrdering"`
	xxx_hidden_OrderingTimeoutMs int32                  `protobuf:"varint,5,opt,name=ordering_timeout_ms,json=orderingTimeoutMs"`
	XXX_raceDetectHookData       protoimpl.RaceDetectHookData
	XXX_presence                 [1]uint32
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *OrderingConfig) Reset() {
	*x = OrderingConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderingConfig) ProtoMessage() {}

func (x *OrderingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *OrderingConfig) GetGlobalOrdering() OrderingLevel {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 0) {
			return x.xxx_hidden_GlobalOrdering
		}
	}
	return OrderingLevel_ORDERING_LEVEL_UNSPECIFIED
}

func (x *OrderingConfig) GetPartitionOrdering() OrderingLevel {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 1) {
			return x.xxx_hidden_PartitionOrdering
		}
	}
	return OrderingLevel_ORDERING_LEVEL_UNSPECIFIED
}

func (x *OrderingConfig) GetProducerOrdering() OrderingLevel {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 2) {
			return x.xxx_hidden_ProducerOrdering
		}
	}
	return OrderingLevel_ORDERING_LEVEL_UNSPECIFIED
}

func (x *OrderingConfig) GetCausalOrdering() bool {
	if x != nil {
		return x.xxx_hidden_CausalOrdering
	}
	return false
}

func (x *OrderingConfig) GetOrderingTimeoutMs() int32 {
	if x != nil {
		return x.xxx_hidden_OrderingTimeoutMs
	}
	return 0
}

func (x *OrderingConfig) SetGlobalOrdering(v OrderingLevel) {
	x.xxx_hidden_GlobalOrdering = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 5)
}

func (x *OrderingConfig) SetPartitionOrdering(v OrderingLevel) {
	x.xxx_hidden_PartitionOrdering = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 5)
}

func (x *OrderingConfig) SetProducerOrdering(v OrderingLevel) {
	x.xxx_hidden_ProducerOrdering = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 5)
}

func (x *OrderingConfig) SetCausalOrdering(v bool) {
	x.xxx_hidden_CausalOrdering = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 5)
}

func (x *OrderingConfig) SetOrderingTimeoutMs(v int32) {
	x.xxx_hidden_OrderingTimeoutMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 5)
}

func (x *OrderingConfig) HasGlobalOrdering() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *OrderingConfig) HasPartitionOrdering() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *OrderingConfig) HasProducerOrdering() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *OrderingConfig) HasCausalOrdering() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *OrderingConfig) HasOrderingTimeoutMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *OrderingConfig) ClearGlobalOrdering() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_GlobalOrdering = OrderingLevel_ORDERING_LEVEL_UNSPECIFIED
}

func (x *OrderingConfig) ClearPartitionOrdering() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_PartitionOrdering = OrderingLevel_ORDERING_LEVEL_UNSPECIFIED
}

func (x *OrderingConfig) ClearProducerOrdering() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_ProducerOrdering = OrderingLevel_ORDERING_LEVEL_UNSPECIFIED
}

func (x *OrderingConfig) ClearCausalOrdering() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_CausalOrdering = false
}

func (x *OrderingConfig) ClearOrderingTimeoutMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_OrderingTimeoutMs = 0
}

type OrderingConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Global ordering guarantee level
	GlobalOrdering *OrderingLevel
	// Per-partition ordering guarantee
	PartitionOrdering *OrderingLevel
	// Per-producer ordering guarantee
	ProducerOrdering *OrderingLevel
	// Enable causal ordering
	CausalOrdering *bool
	// Ordering timeout (milliseconds)
	OrderingTimeoutMs *int32
}

func (b0 OrderingConfig_builder) Build() *OrderingConfig {
	m0 := &OrderingConfig{}
	b, x := &b0, m0
	_, _ = b, x
	if b.GlobalOrdering != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 5)
		x.xxx_hidden_GlobalOrdering = *b.GlobalOrdering
	}
	if b.PartitionOrdering != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 5)
		x.xxx_hidden_PartitionOrdering = *b.PartitionOrdering
	}
	if b.ProducerOrdering != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 5)
		x.xxx_hidden_ProducerOrdering = *b.ProducerOrdering
	}
	if b.CausalOrdering != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 5)
		x.xxx_hidden_CausalOrdering = *b.CausalOrdering
	}
	if b.OrderingTimeoutMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 5)
		x.xxx_hidden_OrderingTimeoutMs = *b.OrderingTimeoutMs
	}
	return m0
}

// Conflict resolution configuration
type ConflictResolution struct {
	state                       protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Strategy         ResolutionStrategy     `protobuf:"varint,1,opt,name=strategy,enum=gcommon.v1.queue.ResolutionStrategy"`
	xxx_hidden_CustomResolution *CustomResolution      `protobuf:"bytes,2,opt,name=custom_resolution,json=customResolution"`
	xxx_hidden_LwwConfig        *LastWriterWins        `protobuf:"bytes,3,opt,name=lww_config,json=lwwConfig"`
	xxx_hidden_MultiValue       *MultiValueConfig      `protobuf:"bytes,4,opt,name=multi_value,json=multiValue"`
	XXX_raceDetectHookData      protoimpl.RaceDetectHookData
	XXX_presence                [1]uint32
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *ConflictResolution) Reset() {
	*x = ConflictResolution{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConflictResolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConflictResolution) ProtoMessage() {}

func (x *ConflictResolution) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ConflictResolution) GetStrategy() ResolutionStrategy {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 0) {
			return x.xxx_hidden_Strategy
		}
	}
	return ResolutionStrategy_RESOLUTION_STRATEGY_UNSPECIFIED
}

func (x *ConflictResolution) GetCustomResolution() *CustomResolution {
	if x != nil {
		return x.xxx_hidden_CustomResolution
	}
	return nil
}

func (x *ConflictResolution) GetLwwConfig() *LastWriterWins {
	if x != nil {
		return x.xxx_hidden_LwwConfig
	}
	return nil
}

func (x *ConflictResolution) GetMultiValue() *MultiValueConfig {
	if x != nil {
		return x.xxx_hidden_MultiValue
	}
	return nil
}

func (x *ConflictResolution) SetStrategy(v ResolutionStrategy) {
	x.xxx_hidden_Strategy = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 4)
}

func (x *ConflictResolution) SetCustomResolution(v *CustomResolution) {
	x.xxx_hidden_CustomResolution = v
}

func (x *ConflictResolution) SetLwwConfig(v *LastWriterWins) {
	x.xxx_hidden_LwwConfig = v
}

func (x *ConflictResolution) SetMultiValue(v *MultiValueConfig) {
	x.xxx_hidden_MultiValue = v
}

func (x *ConflictResolution) HasStrategy() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *ConflictResolution) HasCustomResolution() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_CustomResolution != nil
}

func (x *ConflictResolution) HasLwwConfig() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_LwwConfig != nil
}

func (x *ConflictResolution) HasMultiValue() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_MultiValue != nil
}

func (x *ConflictResolution) ClearStrategy() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Strategy = ResolutionStrategy_RESOLUTION_STRATEGY_UNSPECIFIED
}

func (x *ConflictResolution) ClearCustomResolution() {
	x.xxx_hidden_CustomResolution = nil
}

func (x *ConflictResolution) ClearLwwConfig() {
	x.xxx_hidden_LwwConfig = nil
}

func (x *ConflictResolution) ClearMultiValue() {
	x.xxx_hidden_MultiValue = nil
}

type ConflictResolution_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Conflict resolution strategy
	Strategy *ResolutionStrategy
	// Custom resolution function settings
	CustomResolution *CustomResolution
	// Last-writer-wins settings
	LwwConfig *LastWriterWins
	// Multi-value conflict handling
	MultiValue *MultiValueConfig
}

func (b0 ConflictResolution_builder) Build() *ConflictResolution {
	m0 := &ConflictResolution{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Strategy != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 4)
		x.xxx_hidden_Strategy = *b.Strategy
	}
	x.xxx_hidden_CustomResolution = b.CustomResolution
	x.xxx_hidden_LwwConfig = b.LwwConfig
	x.xxx_hidden_MultiValue = b.MultiValue
	return m0
}

// Custom conflict resolution configuration
type CustomResolution struct {
	state                   protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_FunctionName *string                `protobuf:"bytes,1,opt,name=function_name,json=functionName"`
	xxx_hidden_Parameters   map[string]string      `protobuf:"bytes,2,rep,name=parameters" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	xxx_hidden_TimeoutMs    int32                  `protobuf:"varint,3,opt,name=timeout_ms,json=timeoutMs"`
	XXX_raceDetectHookData  protoimpl.RaceDetectHookData
	XXX_presence            [1]uint32
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *CustomResolution) Reset() {
	*x = CustomResolution{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CustomResolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CustomResolution) ProtoMessage() {}

func (x *CustomResolution) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CustomResolution) GetFunctionName() string {
	if x != nil {
		if x.xxx_hidden_FunctionName != nil {
			return *x.xxx_hidden_FunctionName
		}
		return ""
	}
	return ""
}

func (x *CustomResolution) GetParameters() map[string]string {
	if x != nil {
		return x.xxx_hidden_Parameters
	}
	return nil
}

func (x *CustomResolution) GetTimeoutMs() int32 {
	if x != nil {
		return x.xxx_hidden_TimeoutMs
	}
	return 0
}

func (x *CustomResolution) SetFunctionName(v string) {
	x.xxx_hidden_FunctionName = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 3)
}

func (x *CustomResolution) SetParameters(v map[string]string) {
	x.xxx_hidden_Parameters = v
}

func (x *CustomResolution) SetTimeoutMs(v int32) {
	x.xxx_hidden_TimeoutMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 3)
}

func (x *CustomResolution) HasFunctionName() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *CustomResolution) HasTimeoutMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *CustomResolution) ClearFunctionName() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_FunctionName = nil
}

func (x *CustomResolution) ClearTimeoutMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_TimeoutMs = 0
}

type CustomResolution_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Resolution function name or identifier
	FunctionName *string
	// Function parameters
	Parameters map[string]string
	// Timeout for resolution function (milliseconds)
	TimeoutMs *int32
}

func (b0 CustomResolution_builder) Build() *CustomResolution {
	m0 := &CustomResolution{}
	b, x := &b0, m0
	_, _ = b, x
	if b.FunctionName != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 3)
		x.xxx_hidden_FunctionName = b.FunctionName
	}
	x.xxx_hidden_Parameters = b.Parameters
	if b.TimeoutMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 3)
		x.xxx_hidden_TimeoutMs = *b.TimeoutMs
	}
	return m0
}

// Last-writer-wins configuration
type LastWriterWins struct {
	state                         protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_UseServerTimestamp bool                   `protobuf:"varint,1,opt,name=use_server_timestamp,json=useServerTimestamp"`
	xxx_hidden_TimestampPrecision *string                `protobuf:"bytes,2,opt,name=timestamp_precision,json=timestampPrecision"`
	XXX_raceDetectHookData        protoimpl.RaceDetectHookData
	XXX_presence                  [1]uint32
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *LastWriterWins) Reset() {
	*x = LastWriterWins{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LastWriterWins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LastWriterWins) ProtoMessage() {}

func (x *LastWriterWins) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *LastWriterWins) GetUseServerTimestamp() bool {
	if x != nil {
		return x.xxx_hidden_UseServerTimestamp
	}
	return false
}

func (x *LastWriterWins) GetTimestampPrecision() string {
	if x != nil {
		if x.xxx_hidden_TimestampPrecision != nil {
			return *x.xxx_hidden_TimestampPrecision
		}
		return ""
	}
	return ""
}

func (x *LastWriterWins) SetUseServerTimestamp(v bool) {
	x.xxx_hidden_UseServerTimestamp = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 2)
}

func (x *LastWriterWins) SetTimestampPrecision(v string) {
	x.xxx_hidden_TimestampPrecision = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 2)
}

func (x *LastWriterWins) HasUseServerTimestamp() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *LastWriterWins) HasTimestampPrecision() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *LastWriterWins) ClearUseServerTimestamp() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_UseServerTimestamp = false
}

func (x *LastWriterWins) ClearTimestampPrecision() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_TimestampPrecision = nil
}

type LastWriterWins_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Use server timestamp instead of client timestamp
	UseServerTimestamp *bool
	// Timestamp precision for comparison
	TimestampPrecision *string
}

func (b0 LastWriterWins_builder) Build() *LastWriterWins {
	m0 := &LastWriterWins{}
	b, x := &b0, m0
	_, _ = b, x
	if b.UseServerTimestamp != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 2)
		x.xxx_hidden_UseServerTimestamp = *b.UseServerTimestamp
	}
	if b.TimestampPrecision != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 2)
		x.xxx_hidden_TimestampPrecision = b.TimestampPrecision
	}
	return m0
}

// Multi-value conflict configuration
type MultiValueConfig struct {
	state                      protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_MaxValues       int32                  `protobuf:"varint,1,opt,name=max_values,json=maxValues"`
	xxx_hidden_ValueTtlSeconds int32                  `protobuf:"varint,2,opt,name=value_ttl_seconds,json=valueTtlSeconds"`
	xxx_hidden_CleanupStrategy *string                `protobuf:"bytes,3,opt,name=cleanup_strategy,json=cleanupStrategy"`
	XXX_raceDetectHookData     protoimpl.RaceDetectHookData
	XXX_presence               [1]uint32
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *MultiValueConfig) Reset() {
	*x = MultiValueConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiValueConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiValueConfig) ProtoMessage() {}

func (x *MultiValueConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *MultiValueConfig) GetMaxValues() int32 {
	if x != nil {
		return x.xxx_hidden_MaxValues
	}
	return 0
}

func (x *MultiValueConfig) GetValueTtlSeconds() int32 {
	if x != nil {
		return x.xxx_hidden_ValueTtlSeconds
	}
	return 0
}

func (x *MultiValueConfig) GetCleanupStrategy() string {
	if x != nil {
		if x.xxx_hidden_CleanupStrategy != nil {
			return *x.xxx_hidden_CleanupStrategy
		}
		return ""
	}
	return ""
}

func (x *MultiValueConfig) SetMaxValues(v int32) {
	x.xxx_hidden_MaxValues = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 3)
}

func (x *MultiValueConfig) SetValueTtlSeconds(v int32) {
	x.xxx_hidden_ValueTtlSeconds = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 3)
}

func (x *MultiValueConfig) SetCleanupStrategy(v string) {
	x.xxx_hidden_CleanupStrategy = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 3)
}

func (x *MultiValueConfig) HasMaxValues() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *MultiValueConfig) HasValueTtlSeconds() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *MultiValueConfig) HasCleanupStrategy() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *MultiValueConfig) ClearMaxValues() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_MaxValues = 0
}

func (x *MultiValueConfig) ClearValueTtlSeconds() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_ValueTtlSeconds = 0
}

func (x *MultiValueConfig) ClearCleanupStrategy() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_CleanupStrategy = nil
}

type MultiValueConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Maximum number of concurrent values to keep
	MaxValues *int32
	// Value expiration time (seconds)
	ValueTtlSeconds *int32
	// Conflict value cleanup strategy
	CleanupStrategy *string
}

func (b0 MultiValueConfig_builder) Build() *MultiValueConfig {
	m0 := &MultiValueConfig{}
	b, x := &b0, m0
	_, _ = b, x
	if b.MaxValues != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 3)
		x.xxx_hidden_MaxValues = *b.MaxValues
	}
	if b.ValueTtlSeconds != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 3)
		x.xxx_hidden_ValueTtlSeconds = *b.ValueTtlSeconds
	}
	if b.CleanupStrategy != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 3)
		x.xxx_hidden_CleanupStrategy = b.CleanupStrategy
	}
	return m0
}

// Consistency validation configuration
type ConsistencyValidation struct {
	state                                protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Enabled                   bool                   `protobuf:"varint,1,opt,name=enabled"`
	xxx_hidden_ValidationIntervalSeconds int32                  `protobuf:"varint,2,opt,name=validation_interval_seconds,json=validationIntervalSeconds"`
	xxx_hidden_ValidationScope           *string                `protobuf:"bytes,3,opt,name=validation_scope,json=validationScope"`
	xxx_hidden_FailureActions            []string               `protobuf:"bytes,4,rep,name=failure_actions,json=failureActions"`
	xxx_hidden_TimeoutMs                 int32                  `protobuf:"varint,5,opt,name=timeout_ms,json=timeoutMs"`
	XXX_raceDetectHookData               protoimpl.RaceDetectHookData
	XXX_presence                         [1]uint32
	unknownFields                        protoimpl.UnknownFields
	sizeCache                            protoimpl.SizeCache
}

func (x *ConsistencyValidation) Reset() {
	*x = ConsistencyValidation{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConsistencyValidation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConsistencyValidation) ProtoMessage() {}

func (x *ConsistencyValidation) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ConsistencyValidation) GetEnabled() bool {
	if x != nil {
		return x.xxx_hidden_Enabled
	}
	return false
}

func (x *ConsistencyValidation) GetValidationIntervalSeconds() int32 {
	if x != nil {
		return x.xxx_hidden_ValidationIntervalSeconds
	}
	return 0
}

func (x *ConsistencyValidation) GetValidationScope() string {
	if x != nil {
		if x.xxx_hidden_ValidationScope != nil {
			return *x.xxx_hidden_ValidationScope
		}
		return ""
	}
	return ""
}

func (x *ConsistencyValidation) GetFailureActions() []string {
	if x != nil {
		return x.xxx_hidden_FailureActions
	}
	return nil
}

func (x *ConsistencyValidation) GetTimeoutMs() int32 {
	if x != nil {
		return x.xxx_hidden_TimeoutMs
	}
	return 0
}

func (x *ConsistencyValidation) SetEnabled(v bool) {
	x.xxx_hidden_Enabled = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 5)
}

func (x *ConsistencyValidation) SetValidationIntervalSeconds(v int32) {
	x.xxx_hidden_ValidationIntervalSeconds = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 5)
}

func (x *ConsistencyValidation) SetValidationScope(v string) {
	x.xxx_hidden_ValidationScope = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 5)
}

func (x *ConsistencyValidation) SetFailureActions(v []string) {
	x.xxx_hidden_FailureActions = v
}

func (x *ConsistencyValidation) SetTimeoutMs(v int32) {
	x.xxx_hidden_TimeoutMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 5)
}

func (x *ConsistencyValidation) HasEnabled() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *ConsistencyValidation) HasValidationIntervalSeconds() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *ConsistencyValidation) HasValidationScope() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *ConsistencyValidation) HasTimeoutMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *ConsistencyValidation) ClearEnabled() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Enabled = false
}

func (x *ConsistencyValidation) ClearValidationIntervalSeconds() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_ValidationIntervalSeconds = 0
}

func (x *ConsistencyValidation) ClearValidationScope() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_ValidationScope = nil
}

func (x *ConsistencyValidation) ClearTimeoutMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_TimeoutMs = 0
}

type ConsistencyValidation_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Enable consistency validation
	Enabled *bool
	// Validation interval (seconds)
	ValidationIntervalSeconds *int32
	// Validation scope (local, cluster, global)
	ValidationScope *string
	// Actions to take on validation failure
	FailureActions []string
	// Validation timeout (milliseconds)
	TimeoutMs *int32
}

func (b0 ConsistencyValidation_builder) Build() *ConsistencyValidation {
	m0 := &ConsistencyValidation{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Enabled != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 5)
		x.xxx_hidden_Enabled = *b.Enabled
	}
	if b.ValidationIntervalSeconds != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 5)
		x.xxx_hidden_ValidationIntervalSeconds = *b.ValidationIntervalSeconds
	}
	if b.ValidationScope != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 5)
		x.xxx_hidden_ValidationScope = b.ValidationScope
	}
	x.xxx_hidden_FailureActions = b.FailureActions
	if b.TimeoutMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 5)
		x.xxx_hidden_TimeoutMs = *b.TimeoutMs
	}
	return m0
}

// Read retry configuration
type ReadRetryConfig struct {
	state                            protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_MaxRetries            int32                  `protobuf:"varint,1,opt,name=max_retries,json=maxRetries"`
	xxx_hidden_InitialDelayMs        int32                  `protobuf:"varint,2,opt,name=initial_delay_ms,json=initialDelayMs"`
	xxx_hidden_MaxDelayMs            int32                  `protobuf:"varint,3,opt,name=max_delay_ms,json=maxDelayMs"`
	xxx_hidden_BackoffMultiplier     float64                `protobuf:"fixed64,4,opt,name=backoff_multiplier,json=backoffMultiplier"`
	xxx_hidden_RetryDifferentReplica bool                   `protobuf:"varint,5,opt,name=retry_different_replica,json=retryDifferentReplica"`
	XXX_raceDetectHookData           protoimpl.RaceDetectHookData
	XXX_presence                     [1]uint32
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *ReadRetryConfig) Reset() {
	*x = ReadRetryConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadRetryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadRetryConfig) ProtoMessage() {}

func (x *ReadRetryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ReadRetryConfig) GetMaxRetries() int32 {
	if x != nil {
		return x.xxx_hidden_MaxRetries
	}
	return 0
}

func (x *ReadRetryConfig) GetInitialDelayMs() int32 {
	if x != nil {
		return x.xxx_hidden_InitialDelayMs
	}
	return 0
}

func (x *ReadRetryConfig) GetMaxDelayMs() int32 {
	if x != nil {
		return x.xxx_hidden_MaxDelayMs
	}
	return 0
}

func (x *ReadRetryConfig) GetBackoffMultiplier() float64 {
	if x != nil {
		return x.xxx_hidden_BackoffMultiplier
	}
	return 0
}

func (x *ReadRetryConfig) GetRetryDifferentReplica() bool {
	if x != nil {
		return x.xxx_hidden_RetryDifferentReplica
	}
	return false
}

func (x *ReadRetryConfig) SetMaxRetries(v int32) {
	x.xxx_hidden_MaxRetries = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 5)
}

func (x *ReadRetryConfig) SetInitialDelayMs(v int32) {
	x.xxx_hidden_InitialDelayMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 5)
}

func (x *ReadRetryConfig) SetMaxDelayMs(v int32) {
	x.xxx_hidden_MaxDelayMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 5)
}

func (x *ReadRetryConfig) SetBackoffMultiplier(v float64) {
	x.xxx_hidden_BackoffMultiplier = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 5)
}

func (x *ReadRetryConfig) SetRetryDifferentReplica(v bool) {
	x.xxx_hidden_RetryDifferentReplica = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 5)
}

func (x *ReadRetryConfig) HasMaxRetries() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *ReadRetryConfig) HasInitialDelayMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *ReadRetryConfig) HasMaxDelayMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *ReadRetryConfig) HasBackoffMultiplier() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *ReadRetryConfig) HasRetryDifferentReplica() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *ReadRetryConfig) ClearMaxRetries() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_MaxRetries = 0
}

func (x *ReadRetryConfig) ClearInitialDelayMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_InitialDelayMs = 0
}

func (x *ReadRetryConfig) ClearMaxDelayMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_MaxDelayMs = 0
}

func (x *ReadRetryConfig) ClearBackoffMultiplier() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_BackoffMultiplier = 0
}

func (x *ReadRetryConfig) ClearRetryDifferentReplica() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_RetryDifferentReplica = false
}

type ReadRetryConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Maximum retry attempts
	MaxRetries *int32
	// Initial retry delay (milliseconds)
	InitialDelayMs *int32
	// Maximum retry delay (milliseconds)
	MaxDelayMs *int32
	// Backoff multiplier
	BackoffMultiplier *float64
	// Retry on different replica
	RetryDifferentReplica *bool
}

func (b0 ReadRetryConfig_builder) Build() *ReadRetryConfig {
	m0 := &ReadRetryConfig{}
	b, x := &b0, m0
	_, _ = b, x
	if b.MaxRetries != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 5)
		x.xxx_hidden_MaxRetries = *b.MaxRetries
	}
	if b.InitialDelayMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 5)
		x.xxx_hidden_InitialDelayMs = *b.InitialDelayMs
	}
	if b.MaxDelayMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 5)
		x.xxx_hidden_MaxDelayMs = *b.MaxDelayMs
	}
	if b.BackoffMultiplier != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 5)
		x.xxx_hidden_BackoffMultiplier = *b.BackoffMultiplier
	}
	if b.RetryDifferentReplica != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 5)
		x.xxx_hidden_RetryDifferentReplica = *b.RetryDifferentReplica
	}
	return m0
}

// Write retry configuration
type WriteRetryConfig struct {
	state                        protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_MaxRetries        int32                  `protobuf:"varint,1,opt,name=max_retries,json=maxRetries"`
	xxx_hidden_InitialDelayMs    int32                  `protobuf:"varint,2,opt,name=initial_delay_ms,json=initialDelayMs"`
	xxx_hidden_MaxDelayMs        int32                  `protobuf:"varint,3,opt,name=max_delay_ms,json=maxDelayMs"`
	xxx_hidden_BackoffMultiplier float64                `protobuf:"fixed64,4,opt,name=backoff_multiplier,json=backoffMultiplier"`
	xxx_hidden_IdempotentOnly    bool                   `protobuf:"varint,5,opt,name=idempotent_only,json=idempotentOnly"`
	XXX_raceDetectHookData       protoimpl.RaceDetectHookData
	XXX_presence                 [1]uint32
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *WriteRetryConfig) Reset() {
	*x = WriteRetryConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteRetryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteRetryConfig) ProtoMessage() {}

func (x *WriteRetryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *WriteRetryConfig) GetMaxRetries() int32 {
	if x != nil {
		return x.xxx_hidden_MaxRetries
	}
	return 0
}

func (x *WriteRetryConfig) GetInitialDelayMs() int32 {
	if x != nil {
		return x.xxx_hidden_InitialDelayMs
	}
	return 0
}

func (x *WriteRetryConfig) GetMaxDelayMs() int32 {
	if x != nil {
		return x.xxx_hidden_MaxDelayMs
	}
	return 0
}

func (x *WriteRetryConfig) GetBackoffMultiplier() float64 {
	if x != nil {
		return x.xxx_hidden_BackoffMultiplier
	}
	return 0
}

func (x *WriteRetryConfig) GetIdempotentOnly() bool {
	if x != nil {
		return x.xxx_hidden_IdempotentOnly
	}
	return false
}

func (x *WriteRetryConfig) SetMaxRetries(v int32) {
	x.xxx_hidden_MaxRetries = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 5)
}

func (x *WriteRetryConfig) SetInitialDelayMs(v int32) {
	x.xxx_hidden_InitialDelayMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 5)
}

func (x *WriteRetryConfig) SetMaxDelayMs(v int32) {
	x.xxx_hidden_MaxDelayMs = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 5)
}

func (x *WriteRetryConfig) SetBackoffMultiplier(v float64) {
	x.xxx_hidden_BackoffMultiplier = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 5)
}

func (x *WriteRetryConfig) SetIdempotentOnly(v bool) {
	x.xxx_hidden_IdempotentOnly = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 5)
}

func (x *WriteRetryConfig) HasMaxRetries() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *WriteRetryConfig) HasInitialDelayMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *WriteRetryConfig) HasMaxDelayMs() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *WriteRetryConfig) HasBackoffMultiplier() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *WriteRetryConfig) HasIdempotentOnly() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *WriteRetryConfig) ClearMaxRetries() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_MaxRetries = 0
}

func (x *WriteRetryConfig) ClearInitialDelayMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_InitialDelayMs = 0
}

func (x *WriteRetryConfig) ClearMaxDelayMs() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_MaxDelayMs = 0
}

func (x *WriteRetryConfig) ClearBackoffMultiplier() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_BackoffMultiplier = 0
}

func (x *WriteRetryConfig) ClearIdempotentOnly() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_IdempotentOnly = false
}

type WriteRetryConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Maximum retry attempts
	MaxRetries *int32
	// Initial retry delay (milliseconds)
	InitialDelayMs *int32
	// Maximum retry delay (milliseconds)
	MaxDelayMs *int32
	// Backoff multiplier
	BackoffMultiplier *float64
	// Retry idempotent operations only
	IdempotentOnly *bool
}

func (b0 WriteRetryConfig_builder) Build() *WriteRetryConfig {
	m0 := &WriteRetryConfig{}
	b, x := &b0, m0
	_, _ = b, x
	if b.MaxRetries != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 5)
		x.xxx_hidden_MaxRetries = *b.MaxRetries
	}
	if b.InitialDelayMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 5)
		x.xxx_hidden_InitialDelayMs = *b.InitialDelayMs
	}
	if b.MaxDelayMs != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 5)
		x.xxx_hidden_MaxDelayMs = *b.MaxDelayMs
	}
	if b.BackoffMultiplier != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 5)
		x.xxx_hidden_BackoffMultiplier = *b.BackoffMultiplier
	}
	if b.IdempotentOnly != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 5)
		x.xxx_hidden_IdempotentOnly = *b.IdempotentOnly
	}
	return m0
}

var File_pkg_queue_proto_consistency_config_proto protoreflect.FileDescriptor

const file_pkg_queue_proto_consistency_config_proto_rawDesc = "" +
	"\n" +
	"(pkg/queue/proto/consistency_config.proto\x12\x10gcommon.v1.queue\x1a!google/protobuf/go_features.proto\x1a\x1fpkg/queue/proto/ack_level.proto\x1a&pkg/queue/proto/durability_level.proto\"\xe3\x04\n" +
	"\x11ConsistencyConfig\x12L\n" +
	"\x10durability_level\x18\x01 \x01(\x0e2!.gcommon.v1.queue.DurabilityLevelR\x0fdurabilityLevel\x127\n" +
	"\tack_level\x18\x02 \x01(\x0e2\x1a.gcommon.v1.queue.AckLevelR\backLevel\x12J\n" +
	"\vreplication\x18\x03 \x01(\v2(.gcommon.v1.queue.ReplicationConsistencyR\vreplication\x12L\n" +
	"\x10read_consistency\x18\x04 \x01(\v2!.gcommon.v1.queue.ReadConsistencyR\x0freadConsistency\x12O\n" +
	"\x11write_consistency\x18\x05 \x01(\v2\".gcommon.v1.queue.WriteConsistencyR\x10writeConsistency\x12<\n" +
	"\bordering\x18\x06 \x01(\v2 .gcommon.v1.queue.OrderingConfigR\bordering\x12U\n" +
	"\x13conflict_resolution\x18\a \x01(\v2$.gcommon.v1.queue.ConflictResolutionR\x12conflictResolution\x12G\n" +
	"\n" +
	"validation\x18\b \x01(\v2'.gcommon.v1.queue.ConsistencyValidationR\n" +
	"validation\"\xdc\x02\n" +
	"\x16ReplicationConsistency\x12,\n" +
	"\x12min_write_replicas\x18\x01 \x01(\x05R\x10minWriteReplicas\x12*\n" +
	"\x11min_read_replicas\x18\x02 \x01(\x05R\x0fminReadReplicas\x12-\n" +
	"\x12replication_factor\x18\x03 \x01(\x05R\x11replicationFactor\x12O\n" +
	"\x11replication_level\x18\x04 \x01(\x0e2\".gcommon.v1.queue.ReplicationLevelR\x10replicationLevel\x120\n" +
	"\x14anti_entropy_enabled\x18\x05 \x01(\bR\x12antiEntropyEnabled\x126\n" +
	"\x17repair_interval_seconds\x18\x06 \x01(\x05R\x15repairIntervalSeconds\"\xa6\x02\n" +
	"\x0fReadConsistency\x121\n" +
	"\x05level\x18\x01 \x01(\x0e2\x1b.gcommon.v1.queue.ReadLevelR\x05level\x12(\n" +
	"\x10max_staleness_ms\x18\x02 \x01(\x03R\x0emaxStalenessMs\x12(\n" +
	"\x10read_your_writes\x18\x03 \x01(\bR\x0ereadYourWrites\x12'\n" +
	"\x0fmonotonic_reads\x18\x04 \x01(\bR\x0emonotonicReads\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x05 \x01(\x05R\ttimeoutMs\x12D\n" +
	"\fretry_config\x18\x06 \x01(\v2!.gcommon.v1.queue.ReadRetryConfigR\vretryConfig\"\xce\x02\n" +
	"\x10WriteConsistency\x122\n" +
	"\x05level\x18\x01 \x01(\x0e2\x1c.gcommon.v1.queue.WriteLevelR\x05level\x12L\n" +
	"\x10sync_replication\x18\x02 \x01(\v2!.gcommon.v1.queue.SyncReplicationR\x0fsyncReplication\x12R\n" +
	"\x12conflict_detection\x18\x03 \x01(\v2#.gcommon.v1.queue.ConflictDetectionR\x11conflictDetection\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x04 \x01(\x05R\ttimeoutMs\x12E\n" +
	"\fretry_config\x18\x05 \x01(\v2\".gcommon.v1.queue.WriteRetryConfigR\vretryConfig\"\xab\x01\n" +
	"\x0fSyncReplication\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12*\n" +
	"\x11min_sync_replicas\x18\x02 \x01(\x05R\x0fminSyncReplicas\x12&\n" +
	"\x0fsync_timeout_ms\x18\x03 \x01(\x05R\rsyncTimeoutMs\x12*\n" +
	"\x11fallback_to_async\x18\x04 \x01(\bR\x0ffallbackToAsync\"\x83\x02\n" +
	"\x11ConflictDetection\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12>\n" +
	"\bstrategy\x18\x02 \x01(\x0e2\".gcommon.v1.queue.ConflictStrategyR\bstrategy\x12F\n" +
	"\fvector_clock\x18\x03 \x01(\v2#.gcommon.v1.queue.VectorClockConfigR\vvectorClock\x12L\n" +
	"\x10timestamp_config\x18\x04 \x01(\v2!.gcommon.v1.queue.TimestampConfigR\x0ftimestampConfig\"m\n" +
	"\x11VectorClockConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1c\n" +
	"\tprecision\x18\x02 \x01(\tR\tprecision\x12 \n" +
	"\fmax_drift_ms\x18\x03 \x01(\x03R\n" +
	"maxDriftMs\"}\n" +
	"\x0fTimestampConfig\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x122\n" +
	"\x15sync_interval_seconds\x18\x02 \x01(\x05R\x13syncIntervalSeconds\x12\x1e\n" +
	"\vmax_skew_ms\x18\x03 \x01(\x03R\tmaxSkewMs\"\xd1\x02\n" +
	"\x0eOrderingConfig\x12H\n" +
	"\x0fglobal_ordering\x18\x01 \x01(\x0e2\x1f.gcommon.v1.queue.OrderingLevelR\x0eglobalOrdering\x12N\n" +
	"\x12partition_ordering\x18\x02 \x01(\x0e2\x1f.gcommon.v1.queue.OrderingLevelR\x11partitionOrdering\x12L\n" +
	"\x11producer_ordering\x18\x03 \x01(\x0e2\x1f.gcommon.v1.queue.OrderingLevelR\x10producerOrdering\x12'\n" +
	"\x0fcausal_ordering\x18\x04 \x01(\bR\x0ecausalOrdering\x12.\n" +
	"\x13ordering_timeout_ms\x18\x05 \x01(\x05R\x11orderingTimeoutMs\"\xad\x02\n" +
	"\x12ConflictResolution\x12@\n" +
	"\bstrategy\x18\x01 \x01(\x0e2$.gcommon.v1.queue.ResolutionStrategyR\bstrategy\x12O\n" +
	"\x11custom_resolution\x18\x02 \x01(\v2\".gcommon.v1.queue.CustomResolutionR\x10customResolution\x12?\n" +
	"\n" +
	"lww_config\x18\x03 \x01(\v2 .gcommon.v1.queue.LastWriterWinsR\tlwwConfig\x12C\n" +
	"\vmulti_value\x18\x04 \x01(\v2\".gcommon.v1.queue.MultiValueConfigR\n" +
	"multiValue\"\xe9\x01\n" +
	"\x10CustomResolution\x12#\n" +
	"\rfunction_name\x18\x01 \x01(\tR\ffunctionName\x12R\n" +
	"\n" +
	"parameters\x18\x02 \x03(\v22.gcommon.v1.queue.CustomResolution.ParametersEntryR\n" +
	"parameters\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x03 \x01(\x05R\ttimeoutMs\x1a=\n" +
	"\x0fParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"s\n" +
	"\x0eLastWriterWins\x120\n" +
	"\x14use_server_timestamp\x18\x01 \x01(\bR\x12useServerTimestamp\x12/\n" +
	"\x13timestamp_precision\x18\x02 \x01(\tR\x12timestampPrecision\"\x88\x01\n" +
	"\x10MultiValueConfig\x12\x1d\n" +
	"\n" +
	"max_values\x18\x01 \x01(\x05R\tmaxValues\x12*\n" +
	"\x11value_ttl_seconds\x18\x02 \x01(\x05R\x0fvalueTtlSeconds\x12)\n" +
	"\x10cleanup_strategy\x18\x03 \x01(\tR\x0fcleanupStrategy\"\xe4\x01\n" +
	"\x15ConsistencyValidation\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12>\n" +
	"\x1bvalidation_interval_seconds\x18\x02 \x01(\x05R\x19validationIntervalSeconds\x12)\n" +
	"\x10validation_scope\x18\x03 \x01(\tR\x0fvalidationScope\x12'\n" +
	"\x0ffailure_actions\x18\x04 \x03(\tR\x0efailureActions\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x05 \x01(\x05R\ttimeoutMs\"\xe5\x01\n" +
	"\x0fReadRetryConfig\x12\x1f\n" +
	"\vmax_retries\x18\x01 \x01(\x05R\n" +
	"maxRetries\x12(\n" +
	"\x10initial_delay_ms\x18\x02 \x01(\x05R\x0einitialDelayMs\x12 \n" +
	"\fmax_delay_ms\x18\x03 \x01(\x05R\n" +
	"maxDelayMs\x12-\n" +
	"\x12backoff_multiplier\x18\x04 \x01(\x01R\x11backoffMultiplier\x126\n" +
	"\x17retry_different_replica\x18\x05 \x01(\bR\x15retryDifferentReplica\"\xd7\x01\n" +
	"\x10WriteRetryConfig\x12\x1f\n" +
	"\vmax_retries\x18\x01 \x01(\x05R\n" +
	"maxRetries\x12(\n" +
	"\x10initial_delay_ms\x18\x02 \x01(\x05R\x0einitialDelayMs\x12 \n" +
	"\fmax_delay_ms\x18\x03 \x01(\x05R\n" +
	"maxDelayMs\x12-\n" +
	"\x12backoff_multiplier\x18\x04 \x01(\x01R\x11backoffMultiplier\x12'\n" +
	"\x0fidempotent_only\x18\x05 \x01(\bR\x0eidempotentOnly*\x89\x01\n" +
	"\x10ReplicationLevel\x12!\n" +
	"\x1dREPLICATION_LEVEL_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15REPLICATION_LEVEL_ONE\x10\x01\x12\x1c\n" +
	"\x18REPLICATION_LEVEL_QUORUM\x10\x02\x12\x19\n" +
	"\x15REPLICATION_LEVEL_ALL\x10\x03*\x91\x01\n" +
	"\tReadLevel\x12\x1a\n" +
	"\x16READ_LEVEL_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13READ_LEVEL_EVENTUAL\x10\x01\x12\x15\n" +
	"\x11READ_LEVEL_STRONG\x10\x02\x12 \n" +
	"\x1cREAD_LEVEL_BOUNDED_STALENESS\x10\x03\x12\x16\n" +
	"\x12READ_LEVEL_SESSION\x10\x04*\x91\x01\n" +
	"\n" +
	"WriteLevel\x12\x1b\n" +
	"\x17WRITE_LEVEL_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11WRITE_LEVEL_ASYNC\x10\x01\x12\x18\n" +
	"\x14WRITE_LEVEL_SYNC_ONE\x10\x02\x12\x1b\n" +
	"\x17WRITE_LEVEL_SYNC_QUORUM\x10\x03\x12\x18\n" +
	"\x14WRITE_LEVEL_SYNC_ALL\x10\x04*\x98\x01\n" +
	"\x10ConflictStrategy\x12!\n" +
	"\x1dCONFLICT_STRATEGY_UNSPECIFIED\x10\x00\x12\x1f\n" +
	"\x1bCONFLICT_STRATEGY_TIMESTAMP\x10\x01\x12\"\n" +
	"\x1eCONFLICT_STRATEGY_VECTOR_CLOCK\x10\x02\x12\x1c\n" +
	"\x18CONFLICT_STRATEGY_CAUSAL\x10\x03*~\n" +
	"\rOrderingLevel\x12\x1e\n" +
	"\x1aORDERING_LEVEL_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13ORDERING_LEVEL_NONE\x10\x01\x12\x1a\n" +
	"\x16ORDERING_LEVEL_PARTIAL\x10\x02\x12\x18\n" +
	"\x14ORDERING_LEVEL_TOTAL\x10\x03*\xf2\x01\n" +
	"\x12ResolutionStrategy\x12#\n" +
	"\x1fRESOLUTION_STRATEGY_UNSPECIFIED\x10\x00\x12(\n" +
	"$RESOLUTION_STRATEGY_LAST_WRITER_WINS\x10\x01\x12)\n" +
	"%RESOLUTION_STRATEGY_FIRST_WRITER_WINS\x10\x02\x12\x1d\n" +
	"\x19RESOLUTION_STRATEGY_MERGE\x10\x03\x12\x1e\n" +
	"\x1aRESOLUTION_STRATEGY_CUSTOM\x10\x04\x12#\n" +
	"\x1fRESOLUTION_STRATEGY_MULTI_VALUE\x10\x05B\xc3\x01\n" +
	"\x14com.gcommon.v1.queueB\x16ConsistencyConfigProtoP\x01Z)github.com/jdfalk/gcommon/pkg/queue/proto\xa2\x02\x03GVQ\xaa\x02\x10Gcommon.V1.Queue\xca\x02\x10Gcommon\\V1\\Queue\xe2\x02\x1cGcommon\\V1\\Queue\\GPBMetadata\xea\x02\x12Gcommon::V1::Queue\x92\x03\x05\xd2>\x02\x10\x03b\beditionsp\xe8\a"

var file_pkg_queue_proto_consistency_config_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_pkg_queue_proto_consistency_config_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_pkg_queue_proto_consistency_config_proto_goTypes = []any{
	(ReplicationLevel)(0),          // 0: gcommon.v1.queue.ReplicationLevel
	(ReadLevel)(0),                 // 1: gcommon.v1.queue.ReadLevel
	(WriteLevel)(0),                // 2: gcommon.v1.queue.WriteLevel
	(ConflictStrategy)(0),          // 3: gcommon.v1.queue.ConflictStrategy
	(OrderingLevel)(0),             // 4: gcommon.v1.queue.OrderingLevel
	(ResolutionStrategy)(0),        // 5: gcommon.v1.queue.ResolutionStrategy
	(*ConsistencyConfig)(nil),      // 6: gcommon.v1.queue.ConsistencyConfig
	(*ReplicationConsistency)(nil), // 7: gcommon.v1.queue.ReplicationConsistency
	(*ReadConsistency)(nil),        // 8: gcommon.v1.queue.ReadConsistency
	(*WriteConsistency)(nil),       // 9: gcommon.v1.queue.WriteConsistency
	(*SyncReplication)(nil),        // 10: gcommon.v1.queue.SyncReplication
	(*ConflictDetection)(nil),      // 11: gcommon.v1.queue.ConflictDetection
	(*VectorClockConfig)(nil),      // 12: gcommon.v1.queue.VectorClockConfig
	(*TimestampConfig)(nil),        // 13: gcommon.v1.queue.TimestampConfig
	(*OrderingConfig)(nil),         // 14: gcommon.v1.queue.OrderingConfig
	(*ConflictResolution)(nil),     // 15: gcommon.v1.queue.ConflictResolution
	(*CustomResolution)(nil),       // 16: gcommon.v1.queue.CustomResolution
	(*LastWriterWins)(nil),         // 17: gcommon.v1.queue.LastWriterWins
	(*MultiValueConfig)(nil),       // 18: gcommon.v1.queue.MultiValueConfig
	(*ConsistencyValidation)(nil),  // 19: gcommon.v1.queue.ConsistencyValidation
	(*ReadRetryConfig)(nil),        // 20: gcommon.v1.queue.ReadRetryConfig
	(*WriteRetryConfig)(nil),       // 21: gcommon.v1.queue.WriteRetryConfig
	nil,                            // 22: gcommon.v1.queue.CustomResolution.ParametersEntry
	(DurabilityLevel)(0),           // 23: gcommon.v1.queue.DurabilityLevel
	(AckLevel)(0),                  // 24: gcommon.v1.queue.AckLevel
}
var file_pkg_queue_proto_consistency_config_proto_depIdxs = []int32{
	23, // 0: gcommon.v1.queue.ConsistencyConfig.durability_level:type_name -> gcommon.v1.queue.DurabilityLevel
	24, // 1: gcommon.v1.queue.ConsistencyConfig.ack_level:type_name -> gcommon.v1.queue.AckLevel
	7,  // 2: gcommon.v1.queue.ConsistencyConfig.replication:type_name -> gcommon.v1.queue.ReplicationConsistency
	8,  // 3: gcommon.v1.queue.ConsistencyConfig.read_consistency:type_name -> gcommon.v1.queue.ReadConsistency
	9,  // 4: gcommon.v1.queue.ConsistencyConfig.write_consistency:type_name -> gcommon.v1.queue.WriteConsistency
	14, // 5: gcommon.v1.queue.ConsistencyConfig.ordering:type_name -> gcommon.v1.queue.OrderingConfig
	15, // 6: gcommon.v1.queue.ConsistencyConfig.conflict_resolution:type_name -> gcommon.v1.queue.ConflictResolution
	19, // 7: gcommon.v1.queue.ConsistencyConfig.validation:type_name -> gcommon.v1.queue.ConsistencyValidation
	0,  // 8: gcommon.v1.queue.ReplicationConsistency.replication_level:type_name -> gcommon.v1.queue.ReplicationLevel
	1,  // 9: gcommon.v1.queue.ReadConsistency.level:type_name -> gcommon.v1.queue.ReadLevel
	20, // 10: gcommon.v1.queue.ReadConsistency.retry_config:type_name -> gcommon.v1.queue.ReadRetryConfig
	2,  // 11: gcommon.v1.queue.WriteConsistency.level:type_name -> gcommon.v1.queue.WriteLevel
	10, // 12: gcommon.v1.queue.WriteConsistency.sync_replication:type_name -> gcommon.v1.queue.SyncReplication
	11, // 13: gcommon.v1.queue.WriteConsistency.conflict_detection:type_name -> gcommon.v1.queue.ConflictDetection
	21, // 14: gcommon.v1.queue.WriteConsistency.retry_config:type_name -> gcommon.v1.queue.WriteRetryConfig
	3,  // 15: gcommon.v1.queue.ConflictDetection.strategy:type_name -> gcommon.v1.queue.ConflictStrategy
	12, // 16: gcommon.v1.queue.ConflictDetection.vector_clock:type_name -> gcommon.v1.queue.VectorClockConfig
	13, // 17: gcommon.v1.queue.ConflictDetection.timestamp_config:type_name -> gcommon.v1.queue.TimestampConfig
	4,  // 18: gcommon.v1.queue.OrderingConfig.global_ordering:type_name -> gcommon.v1.queue.OrderingLevel
	4,  // 19: gcommon.v1.queue.OrderingConfig.partition_ordering:type_name -> gcommon.v1.queue.OrderingLevel
	4,  // 20: gcommon.v1.queue.OrderingConfig.producer_ordering:type_name -> gcommon.v1.queue.OrderingLevel
	5,  // 21: gcommon.v1.queue.ConflictResolution.strategy:type_name -> gcommon.v1.queue.ResolutionStrategy
	16, // 22: gcommon.v1.queue.ConflictResolution.custom_resolution:type_name -> gcommon.v1.queue.CustomResolution
	17, // 23: gcommon.v1.queue.ConflictResolution.lww_config:type_name -> gcommon.v1.queue.LastWriterWins
	18, // 24: gcommon.v1.queue.ConflictResolution.multi_value:type_name -> gcommon.v1.queue.MultiValueConfig
	22, // 25: gcommon.v1.queue.CustomResolution.parameters:type_name -> gcommon.v1.queue.CustomResolution.ParametersEntry
	26, // [26:26] is the sub-list for method output_type
	26, // [26:26] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_pkg_queue_proto_consistency_config_proto_init() }
func file_pkg_queue_proto_consistency_config_proto_init() {
	if File_pkg_queue_proto_consistency_config_proto != nil {
		return
	}
	file_pkg_queue_proto_ack_level_proto_init()
	file_pkg_queue_proto_durability_level_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_pkg_queue_proto_consistency_config_proto_rawDesc), len(file_pkg_queue_proto_consistency_config_proto_rawDesc)),
			NumEnums:      6,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_pkg_queue_proto_consistency_config_proto_goTypes,
		DependencyIndexes: file_pkg_queue_proto_consistency_config_proto_depIdxs,
		EnumInfos:         file_pkg_queue_proto_consistency_config_proto_enumTypes,
		MessageInfos:      file_pkg_queue_proto_consistency_config_proto_msgTypes,
	}.Build()
	File_pkg_queue_proto_consistency_config_proto = out.File
	file_pkg_queue_proto_consistency_config_proto_goTypes = nil
	file_pkg_queue_proto_consistency_config_proto_depIdxs = nil
}
