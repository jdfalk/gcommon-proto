// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: pkg/queue/proto/consistency_config.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Replication consistency level
type ReplicationLevel int32

const (
	ReplicationLevel_REPLICATION_LEVEL_UNSPECIFIED ReplicationLevel = 0
	ReplicationLevel_REPLICATION_LEVEL_ONE         ReplicationLevel = 1 // At least one replica
	ReplicationLevel_REPLICATION_LEVEL_QUORUM      ReplicationLevel = 2 // Majority of replicas
	ReplicationLevel_REPLICATION_LEVEL_ALL         ReplicationLevel = 3 // All replicas
)

// Enum value maps for ReplicationLevel.
var (
	ReplicationLevel_name = map[int32]string{
		0: "REPLICATION_LEVEL_UNSPECIFIED",
		1: "REPLICATION_LEVEL_ONE",
		2: "REPLICATION_LEVEL_QUORUM",
		3: "REPLICATION_LEVEL_ALL",
	}
	ReplicationLevel_value = map[string]int32{
		"REPLICATION_LEVEL_UNSPECIFIED": 0,
		"REPLICATION_LEVEL_ONE":         1,
		"REPLICATION_LEVEL_QUORUM":      2,
		"REPLICATION_LEVEL_ALL":         3,
	}
)

func (x ReplicationLevel) Enum() *ReplicationLevel {
	p := new(ReplicationLevel)
	*p = x
	return p
}

func (x ReplicationLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReplicationLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[0].Descriptor()
}

func (ReplicationLevel) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[0]
}

func (x ReplicationLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReplicationLevel.Descriptor instead.
func (ReplicationLevel) EnumDescriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{0}
}

// Read consistency level
type ReadLevel int32

const (
	ReadLevel_READ_LEVEL_UNSPECIFIED       ReadLevel = 0
	ReadLevel_READ_LEVEL_EVENTUAL          ReadLevel = 1 // Eventually consistent reads
	ReadLevel_READ_LEVEL_STRONG            ReadLevel = 2 // Strongly consistent reads
	ReadLevel_READ_LEVEL_BOUNDED_STALENESS ReadLevel = 3 // Bounded staleness reads
	ReadLevel_READ_LEVEL_SESSION           ReadLevel = 4 // Session consistency
)

// Enum value maps for ReadLevel.
var (
	ReadLevel_name = map[int32]string{
		0: "READ_LEVEL_UNSPECIFIED",
		1: "READ_LEVEL_EVENTUAL",
		2: "READ_LEVEL_STRONG",
		3: "READ_LEVEL_BOUNDED_STALENESS",
		4: "READ_LEVEL_SESSION",
	}
	ReadLevel_value = map[string]int32{
		"READ_LEVEL_UNSPECIFIED":       0,
		"READ_LEVEL_EVENTUAL":          1,
		"READ_LEVEL_STRONG":            2,
		"READ_LEVEL_BOUNDED_STALENESS": 3,
		"READ_LEVEL_SESSION":           4,
	}
)

func (x ReadLevel) Enum() *ReadLevel {
	p := new(ReadLevel)
	*p = x
	return p
}

func (x ReadLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReadLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[1].Descriptor()
}

func (ReadLevel) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[1]
}

func (x ReadLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReadLevel.Descriptor instead.
func (ReadLevel) EnumDescriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{1}
}

// Write consistency level
type WriteLevel int32

const (
	WriteLevel_WRITE_LEVEL_UNSPECIFIED WriteLevel = 0
	WriteLevel_WRITE_LEVEL_ASYNC       WriteLevel = 1 // Asynchronous writes
	WriteLevel_WRITE_LEVEL_SYNC_ONE    WriteLevel = 2 // Synchronous to one replica
	WriteLevel_WRITE_LEVEL_SYNC_QUORUM WriteLevel = 3 // Synchronous to quorum
	WriteLevel_WRITE_LEVEL_SYNC_ALL    WriteLevel = 4 // Synchronous to all replicas
)

// Enum value maps for WriteLevel.
var (
	WriteLevel_name = map[int32]string{
		0: "WRITE_LEVEL_UNSPECIFIED",
		1: "WRITE_LEVEL_ASYNC",
		2: "WRITE_LEVEL_SYNC_ONE",
		3: "WRITE_LEVEL_SYNC_QUORUM",
		4: "WRITE_LEVEL_SYNC_ALL",
	}
	WriteLevel_value = map[string]int32{
		"WRITE_LEVEL_UNSPECIFIED": 0,
		"WRITE_LEVEL_ASYNC":       1,
		"WRITE_LEVEL_SYNC_ONE":    2,
		"WRITE_LEVEL_SYNC_QUORUM": 3,
		"WRITE_LEVEL_SYNC_ALL":    4,
	}
)

func (x WriteLevel) Enum() *WriteLevel {
	p := new(WriteLevel)
	*p = x
	return p
}

func (x WriteLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WriteLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[2].Descriptor()
}

func (WriteLevel) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[2]
}

func (x WriteLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WriteLevel.Descriptor instead.
func (WriteLevel) EnumDescriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{2}
}

// Conflict detection strategy
type ConflictStrategy int32

const (
	ConflictStrategy_CONFLICT_STRATEGY_UNSPECIFIED  ConflictStrategy = 0
	ConflictStrategy_CONFLICT_STRATEGY_TIMESTAMP    ConflictStrategy = 1 // Timestamp-based detection
	ConflictStrategy_CONFLICT_STRATEGY_VECTOR_CLOCK ConflictStrategy = 2 // Vector clock-based detection
	ConflictStrategy_CONFLICT_STRATEGY_CAUSAL       ConflictStrategy = 3 // Causal consistency detection
)

// Enum value maps for ConflictStrategy.
var (
	ConflictStrategy_name = map[int32]string{
		0: "CONFLICT_STRATEGY_UNSPECIFIED",
		1: "CONFLICT_STRATEGY_TIMESTAMP",
		2: "CONFLICT_STRATEGY_VECTOR_CLOCK",
		3: "CONFLICT_STRATEGY_CAUSAL",
	}
	ConflictStrategy_value = map[string]int32{
		"CONFLICT_STRATEGY_UNSPECIFIED":  0,
		"CONFLICT_STRATEGY_TIMESTAMP":    1,
		"CONFLICT_STRATEGY_VECTOR_CLOCK": 2,
		"CONFLICT_STRATEGY_CAUSAL":       3,
	}
)

func (x ConflictStrategy) Enum() *ConflictStrategy {
	p := new(ConflictStrategy)
	*p = x
	return p
}

func (x ConflictStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConflictStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[3].Descriptor()
}

func (ConflictStrategy) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[3]
}

func (x ConflictStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ConflictStrategy.Descriptor instead.
func (ConflictStrategy) EnumDescriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{3}
}

// Ordering guarantee level
type OrderingLevel int32

const (
	OrderingLevel_ORDERING_LEVEL_UNSPECIFIED OrderingLevel = 0
	OrderingLevel_ORDERING_LEVEL_NONE        OrderingLevel = 1 // No ordering guarantees
	OrderingLevel_ORDERING_LEVEL_PARTIAL     OrderingLevel = 2 // Partial ordering
	OrderingLevel_ORDERING_LEVEL_TOTAL       OrderingLevel = 3 // Total ordering
)

// Enum value maps for OrderingLevel.
var (
	OrderingLevel_name = map[int32]string{
		0: "ORDERING_LEVEL_UNSPECIFIED",
		1: "ORDERING_LEVEL_NONE",
		2: "ORDERING_LEVEL_PARTIAL",
		3: "ORDERING_LEVEL_TOTAL",
	}
	OrderingLevel_value = map[string]int32{
		"ORDERING_LEVEL_UNSPECIFIED": 0,
		"ORDERING_LEVEL_NONE":        1,
		"ORDERING_LEVEL_PARTIAL":     2,
		"ORDERING_LEVEL_TOTAL":       3,
	}
)

func (x OrderingLevel) Enum() *OrderingLevel {
	p := new(OrderingLevel)
	*p = x
	return p
}

func (x OrderingLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderingLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[4].Descriptor()
}

func (OrderingLevel) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[4]
}

func (x OrderingLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderingLevel.Descriptor instead.
func (OrderingLevel) EnumDescriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{4}
}

// Conflict resolution strategy
type ResolutionStrategy int32

const (
	ResolutionStrategy_RESOLUTION_STRATEGY_UNSPECIFIED       ResolutionStrategy = 0
	ResolutionStrategy_RESOLUTION_STRATEGY_LAST_WRITER_WINS  ResolutionStrategy = 1 // Last writer wins
	ResolutionStrategy_RESOLUTION_STRATEGY_FIRST_WRITER_WINS ResolutionStrategy = 2 // First writer wins
	ResolutionStrategy_RESOLUTION_STRATEGY_MERGE             ResolutionStrategy = 3 // Automatic merge
	ResolutionStrategy_RESOLUTION_STRATEGY_CUSTOM            ResolutionStrategy = 4 // Custom resolution function
	ResolutionStrategy_RESOLUTION_STRATEGY_MULTI_VALUE       ResolutionStrategy = 5 // Keep all conflicting values
)

// Enum value maps for ResolutionStrategy.
var (
	ResolutionStrategy_name = map[int32]string{
		0: "RESOLUTION_STRATEGY_UNSPECIFIED",
		1: "RESOLUTION_STRATEGY_LAST_WRITER_WINS",
		2: "RESOLUTION_STRATEGY_FIRST_WRITER_WINS",
		3: "RESOLUTION_STRATEGY_MERGE",
		4: "RESOLUTION_STRATEGY_CUSTOM",
		5: "RESOLUTION_STRATEGY_MULTI_VALUE",
	}
	ResolutionStrategy_value = map[string]int32{
		"RESOLUTION_STRATEGY_UNSPECIFIED":       0,
		"RESOLUTION_STRATEGY_LAST_WRITER_WINS":  1,
		"RESOLUTION_STRATEGY_FIRST_WRITER_WINS": 2,
		"RESOLUTION_STRATEGY_MERGE":             3,
		"RESOLUTION_STRATEGY_CUSTOM":            4,
		"RESOLUTION_STRATEGY_MULTI_VALUE":       5,
	}
)

func (x ResolutionStrategy) Enum() *ResolutionStrategy {
	p := new(ResolutionStrategy)
	*p = x
	return p
}

func (x ResolutionStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResolutionStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_queue_proto_consistency_config_proto_enumTypes[5].Descriptor()
}

func (ResolutionStrategy) Type() protoreflect.EnumType {
	return &file_pkg_queue_proto_consistency_config_proto_enumTypes[5]
}

func (x ResolutionStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResolutionStrategy.Descriptor instead.
func (ResolutionStrategy) EnumDescriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{5}
}

// ConsistencyConfig configures data consistency and messaging guarantees
type ConsistencyConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Durability level for message persistence
	DurabilityLevel *DurabilityLevel `protobuf:"varint,1,opt,name=durability_level,json=durabilityLevel,enum=gcommon.v1.queue.DurabilityLevel" json:"durability_level,omitempty"`
	// Acknowledgment level required for message delivery
	AckLevel *AckLevel `protobuf:"varint,2,opt,name=ack_level,json=ackLevel,enum=gcommon.v1.queue.AckLevel" json:"ack_level,omitempty"`
	// Replication configuration
	Replication *ReplicationConsistency `protobuf:"bytes,3,opt,name=replication" json:"replication,omitempty"`
	// Read consistency settings
	ReadConsistency *ReadConsistency `protobuf:"bytes,4,opt,name=read_consistency,json=readConsistency" json:"read_consistency,omitempty"`
	// Write consistency settings
	WriteConsistency *WriteConsistency `protobuf:"bytes,5,opt,name=write_consistency,json=writeConsistency" json:"write_consistency,omitempty"`
	// Ordering guarantees
	Ordering *OrderingConfig `protobuf:"bytes,6,opt,name=ordering" json:"ordering,omitempty"`
	// Conflict resolution settings
	ConflictResolution *ConflictResolution `protobuf:"bytes,7,opt,name=conflict_resolution,json=conflictResolution" json:"conflict_resolution,omitempty"`
	// Consistency validation settings
	Validation    *ConsistencyValidation `protobuf:"bytes,8,opt,name=validation" json:"validation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConsistencyConfig) Reset() {
	*x = ConsistencyConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConsistencyConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConsistencyConfig) ProtoMessage() {}

func (x *ConsistencyConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConsistencyConfig.ProtoReflect.Descriptor instead.
func (*ConsistencyConfig) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{0}
}

func (x *ConsistencyConfig) GetDurabilityLevel() DurabilityLevel {
	if x != nil && x.DurabilityLevel != nil {
		return *x.DurabilityLevel
	}
	return DurabilityLevel_DURABILITY_LEVEL_UNSPECIFIED
}

func (x *ConsistencyConfig) GetAckLevel() AckLevel {
	if x != nil && x.AckLevel != nil {
		return *x.AckLevel
	}
	return AckLevel_ACK_LEVEL_UNSPECIFIED
}

func (x *ConsistencyConfig) GetReplication() *ReplicationConsistency {
	if x != nil {
		return x.Replication
	}
	return nil
}

func (x *ConsistencyConfig) GetReadConsistency() *ReadConsistency {
	if x != nil {
		return x.ReadConsistency
	}
	return nil
}

func (x *ConsistencyConfig) GetWriteConsistency() *WriteConsistency {
	if x != nil {
		return x.WriteConsistency
	}
	return nil
}

func (x *ConsistencyConfig) GetOrdering() *OrderingConfig {
	if x != nil {
		return x.Ordering
	}
	return nil
}

func (x *ConsistencyConfig) GetConflictResolution() *ConflictResolution {
	if x != nil {
		return x.ConflictResolution
	}
	return nil
}

func (x *ConsistencyConfig) GetValidation() *ConsistencyValidation {
	if x != nil {
		return x.Validation
	}
	return nil
}

// Replication consistency configuration
type ReplicationConsistency struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Minimum number of replicas that must acknowledge writes
	MinWriteReplicas *int32 `protobuf:"varint,1,opt,name=min_write_replicas,json=minWriteReplicas" json:"min_write_replicas,omitempty"`
	// Minimum number of replicas that must be available for reads
	MinReadReplicas *int32 `protobuf:"varint,2,opt,name=min_read_replicas,json=minReadReplicas" json:"min_read_replicas,omitempty"`
	// Replication factor (total number of replicas)
	ReplicationFactor *int32 `protobuf:"varint,3,opt,name=replication_factor,json=replicationFactor" json:"replication_factor,omitempty"`
	// Consistency level for replication
	ReplicationLevel *ReplicationLevel `protobuf:"varint,4,opt,name=replication_level,json=replicationLevel,enum=gcommon.v1.queue.ReplicationLevel" json:"replication_level,omitempty"`
	// Enable anti-entropy repair
	AntiEntropyEnabled *bool `protobuf:"varint,5,opt,name=anti_entropy_enabled,json=antiEntropyEnabled" json:"anti_entropy_enabled,omitempty"`
	// Anti-entropy repair interval (seconds)
	RepairIntervalSeconds *int32 `protobuf:"varint,6,opt,name=repair_interval_seconds,json=repairIntervalSeconds" json:"repair_interval_seconds,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ReplicationConsistency) Reset() {
	*x = ReplicationConsistency{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationConsistency) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationConsistency) ProtoMessage() {}

func (x *ReplicationConsistency) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationConsistency.ProtoReflect.Descriptor instead.
func (*ReplicationConsistency) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{1}
}

func (x *ReplicationConsistency) GetMinWriteReplicas() int32 {
	if x != nil && x.MinWriteReplicas != nil {
		return *x.MinWriteReplicas
	}
	return 0
}

func (x *ReplicationConsistency) GetMinReadReplicas() int32 {
	if x != nil && x.MinReadReplicas != nil {
		return *x.MinReadReplicas
	}
	return 0
}

func (x *ReplicationConsistency) GetReplicationFactor() int32 {
	if x != nil && x.ReplicationFactor != nil {
		return *x.ReplicationFactor
	}
	return 0
}

func (x *ReplicationConsistency) GetReplicationLevel() ReplicationLevel {
	if x != nil && x.ReplicationLevel != nil {
		return *x.ReplicationLevel
	}
	return ReplicationLevel_REPLICATION_LEVEL_UNSPECIFIED
}

func (x *ReplicationConsistency) GetAntiEntropyEnabled() bool {
	if x != nil && x.AntiEntropyEnabled != nil {
		return *x.AntiEntropyEnabled
	}
	return false
}

func (x *ReplicationConsistency) GetRepairIntervalSeconds() int32 {
	if x != nil && x.RepairIntervalSeconds != nil {
		return *x.RepairIntervalSeconds
	}
	return 0
}

// Read consistency configuration
type ReadConsistency struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Read consistency level
	Level *ReadLevel `protobuf:"varint,1,opt,name=level,enum=gcommon.v1.queue.ReadLevel" json:"level,omitempty"`
	// Maximum staleness allowed for reads (milliseconds)
	MaxStalenessMs *int64 `protobuf:"varint,2,opt,name=max_staleness_ms,json=maxStalenessMs" json:"max_staleness_ms,omitempty"`
	// Enable read-your-writes consistency
	ReadYourWrites *bool `protobuf:"varint,3,opt,name=read_your_writes,json=readYourWrites" json:"read_your_writes,omitempty"`
	// Enable monotonic read consistency
	MonotonicReads *bool `protobuf:"varint,4,opt,name=monotonic_reads,json=monotonicReads" json:"monotonic_reads,omitempty"`
	// Timeout for read operations (milliseconds)
	TimeoutMs *int32 `protobuf:"varint,5,opt,name=timeout_ms,json=timeoutMs" json:"timeout_ms,omitempty"`
	// Retry configuration for read failures
	RetryConfig   *ReadRetryConfig `protobuf:"bytes,6,opt,name=retry_config,json=retryConfig" json:"retry_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadConsistency) Reset() {
	*x = ReadConsistency{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadConsistency) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadConsistency) ProtoMessage() {}

func (x *ReadConsistency) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadConsistency.ProtoReflect.Descriptor instead.
func (*ReadConsistency) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{2}
}

func (x *ReadConsistency) GetLevel() ReadLevel {
	if x != nil && x.Level != nil {
		return *x.Level
	}
	return ReadLevel_READ_LEVEL_UNSPECIFIED
}

func (x *ReadConsistency) GetMaxStalenessMs() int64 {
	if x != nil && x.MaxStalenessMs != nil {
		return *x.MaxStalenessMs
	}
	return 0
}

func (x *ReadConsistency) GetReadYourWrites() bool {
	if x != nil && x.ReadYourWrites != nil {
		return *x.ReadYourWrites
	}
	return false
}

func (x *ReadConsistency) GetMonotonicReads() bool {
	if x != nil && x.MonotonicReads != nil {
		return *x.MonotonicReads
	}
	return false
}

func (x *ReadConsistency) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

func (x *ReadConsistency) GetRetryConfig() *ReadRetryConfig {
	if x != nil {
		return x.RetryConfig
	}
	return nil
}

// Write consistency configuration
type WriteConsistency struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Write consistency level
	Level *WriteLevel `protobuf:"varint,1,opt,name=level,enum=gcommon.v1.queue.WriteLevel" json:"level,omitempty"`
	// Synchronous replication requirements
	SyncReplication *SyncReplication `protobuf:"bytes,2,opt,name=sync_replication,json=syncReplication" json:"sync_replication,omitempty"`
	// Write conflict detection
	ConflictDetection *ConflictDetection `protobuf:"bytes,3,opt,name=conflict_detection,json=conflictDetection" json:"conflict_detection,omitempty"`
	// Timeout for write operations (milliseconds)
	TimeoutMs *int32 `protobuf:"varint,4,opt,name=timeout_ms,json=timeoutMs" json:"timeout_ms,omitempty"`
	// Retry configuration for write failures
	RetryConfig   *WriteRetryConfig `protobuf:"bytes,5,opt,name=retry_config,json=retryConfig" json:"retry_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WriteConsistency) Reset() {
	*x = WriteConsistency{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteConsistency) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteConsistency) ProtoMessage() {}

func (x *WriteConsistency) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteConsistency.ProtoReflect.Descriptor instead.
func (*WriteConsistency) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{3}
}

func (x *WriteConsistency) GetLevel() WriteLevel {
	if x != nil && x.Level != nil {
		return *x.Level
	}
	return WriteLevel_WRITE_LEVEL_UNSPECIFIED
}

func (x *WriteConsistency) GetSyncReplication() *SyncReplication {
	if x != nil {
		return x.SyncReplication
	}
	return nil
}

func (x *WriteConsistency) GetConflictDetection() *ConflictDetection {
	if x != nil {
		return x.ConflictDetection
	}
	return nil
}

func (x *WriteConsistency) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

func (x *WriteConsistency) GetRetryConfig() *WriteRetryConfig {
	if x != nil {
		return x.RetryConfig
	}
	return nil
}

// Synchronous replication configuration
type SyncReplication struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable synchronous replication
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Minimum synchronous replicas
	MinSyncReplicas *int32 `protobuf:"varint,2,opt,name=min_sync_replicas,json=minSyncReplicas" json:"min_sync_replicas,omitempty"`
	// Timeout for synchronous replication (milliseconds)
	SyncTimeoutMs *int32 `protobuf:"varint,3,opt,name=sync_timeout_ms,json=syncTimeoutMs" json:"sync_timeout_ms,omitempty"`
	// Fallback to async on timeout
	FallbackToAsync *bool `protobuf:"varint,4,opt,name=fallback_to_async,json=fallbackToAsync" json:"fallback_to_async,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SyncReplication) Reset() {
	*x = SyncReplication{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncReplication) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncReplication) ProtoMessage() {}

func (x *SyncReplication) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncReplication.ProtoReflect.Descriptor instead.
func (*SyncReplication) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{4}
}

func (x *SyncReplication) GetEnabled() bool {
	if x != nil && x.Enabled != nil {
		return *x.Enabled
	}
	return false
}

func (x *SyncReplication) GetMinSyncReplicas() int32 {
	if x != nil && x.MinSyncReplicas != nil {
		return *x.MinSyncReplicas
	}
	return 0
}

func (x *SyncReplication) GetSyncTimeoutMs() int32 {
	if x != nil && x.SyncTimeoutMs != nil {
		return *x.SyncTimeoutMs
	}
	return 0
}

func (x *SyncReplication) GetFallbackToAsync() bool {
	if x != nil && x.FallbackToAsync != nil {
		return *x.FallbackToAsync
	}
	return false
}

// Conflict detection configuration
type ConflictDetection struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable conflict detection
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Conflict detection strategy
	Strategy *ConflictStrategy `protobuf:"varint,2,opt,name=strategy,enum=gcommon.v1.queue.ConflictStrategy" json:"strategy,omitempty"`
	// Vector clock configuration
	VectorClock *VectorClockConfig `protobuf:"bytes,3,opt,name=vector_clock,json=vectorClock" json:"vector_clock,omitempty"`
	// Timestamp-based detection settings
	TimestampConfig *TimestampConfig `protobuf:"bytes,4,opt,name=timestamp_config,json=timestampConfig" json:"timestamp_config,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ConflictDetection) Reset() {
	*x = ConflictDetection{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConflictDetection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConflictDetection) ProtoMessage() {}

func (x *ConflictDetection) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConflictDetection.ProtoReflect.Descriptor instead.
func (*ConflictDetection) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{5}
}

func (x *ConflictDetection) GetEnabled() bool {
	if x != nil && x.Enabled != nil {
		return *x.Enabled
	}
	return false
}

func (x *ConflictDetection) GetStrategy() ConflictStrategy {
	if x != nil && x.Strategy != nil {
		return *x.Strategy
	}
	return ConflictStrategy_CONFLICT_STRATEGY_UNSPECIFIED
}

func (x *ConflictDetection) GetVectorClock() *VectorClockConfig {
	if x != nil {
		return x.VectorClock
	}
	return nil
}

func (x *ConflictDetection) GetTimestampConfig() *TimestampConfig {
	if x != nil {
		return x.TimestampConfig
	}
	return nil
}

// Vector clock configuration
type VectorClockConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable vector clocks
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Clock precision (nanoseconds, microseconds, milliseconds)
	Precision *string `protobuf:"bytes,2,opt,name=precision" json:"precision,omitempty"`
	// Maximum clock drift tolerance (milliseconds)
	MaxDriftMs    *int64 `protobuf:"varint,3,opt,name=max_drift_ms,json=maxDriftMs" json:"max_drift_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VectorClockConfig) Reset() {
	*x = VectorClockConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VectorClockConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VectorClockConfig) ProtoMessage() {}

func (x *VectorClockConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VectorClockConfig.ProtoReflect.Descriptor instead.
func (*VectorClockConfig) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{6}
}

func (x *VectorClockConfig) GetEnabled() bool {
	if x != nil && x.Enabled != nil {
		return *x.Enabled
	}
	return false
}

func (x *VectorClockConfig) GetPrecision() string {
	if x != nil && x.Precision != nil {
		return *x.Precision
	}
	return ""
}

func (x *VectorClockConfig) GetMaxDriftMs() int64 {
	if x != nil && x.MaxDriftMs != nil {
		return *x.MaxDriftMs
	}
	return 0
}

// Timestamp configuration
type TimestampConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Timestamp source (system, ntp, atomic)
	Source *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Clock synchronization interval (seconds)
	SyncIntervalSeconds *int32 `protobuf:"varint,2,opt,name=sync_interval_seconds,json=syncIntervalSeconds" json:"sync_interval_seconds,omitempty"`
	// Maximum timestamp skew tolerance (milliseconds)
	MaxSkewMs     *int64 `protobuf:"varint,3,opt,name=max_skew_ms,json=maxSkewMs" json:"max_skew_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimestampConfig) Reset() {
	*x = TimestampConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimestampConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimestampConfig) ProtoMessage() {}

func (x *TimestampConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimestampConfig.ProtoReflect.Descriptor instead.
func (*TimestampConfig) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{7}
}

func (x *TimestampConfig) GetSource() string {
	if x != nil && x.Source != nil {
		return *x.Source
	}
	return ""
}

func (x *TimestampConfig) GetSyncIntervalSeconds() int32 {
	if x != nil && x.SyncIntervalSeconds != nil {
		return *x.SyncIntervalSeconds
	}
	return 0
}

func (x *TimestampConfig) GetMaxSkewMs() int64 {
	if x != nil && x.MaxSkewMs != nil {
		return *x.MaxSkewMs
	}
	return 0
}

// Message ordering configuration
type OrderingConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Global ordering guarantee level
	GlobalOrdering *OrderingLevel `protobuf:"varint,1,opt,name=global_ordering,json=globalOrdering,enum=gcommon.v1.queue.OrderingLevel" json:"global_ordering,omitempty"`
	// Per-partition ordering guarantee
	PartitionOrdering *OrderingLevel `protobuf:"varint,2,opt,name=partition_ordering,json=partitionOrdering,enum=gcommon.v1.queue.OrderingLevel" json:"partition_ordering,omitempty"`
	// Per-producer ordering guarantee
	ProducerOrdering *OrderingLevel `protobuf:"varint,3,opt,name=producer_ordering,json=producerOrdering,enum=gcommon.v1.queue.OrderingLevel" json:"producer_ordering,omitempty"`
	// Enable causal ordering
	CausalOrdering *bool `protobuf:"varint,4,opt,name=causal_ordering,json=causalOrdering" json:"causal_ordering,omitempty"`
	// Ordering timeout (milliseconds)
	OrderingTimeoutMs *int32 `protobuf:"varint,5,opt,name=ordering_timeout_ms,json=orderingTimeoutMs" json:"ordering_timeout_ms,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *OrderingConfig) Reset() {
	*x = OrderingConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderingConfig) ProtoMessage() {}

func (x *OrderingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderingConfig.ProtoReflect.Descriptor instead.
func (*OrderingConfig) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{8}
}

func (x *OrderingConfig) GetGlobalOrdering() OrderingLevel {
	if x != nil && x.GlobalOrdering != nil {
		return *x.GlobalOrdering
	}
	return OrderingLevel_ORDERING_LEVEL_UNSPECIFIED
}

func (x *OrderingConfig) GetPartitionOrdering() OrderingLevel {
	if x != nil && x.PartitionOrdering != nil {
		return *x.PartitionOrdering
	}
	return OrderingLevel_ORDERING_LEVEL_UNSPECIFIED
}

func (x *OrderingConfig) GetProducerOrdering() OrderingLevel {
	if x != nil && x.ProducerOrdering != nil {
		return *x.ProducerOrdering
	}
	return OrderingLevel_ORDERING_LEVEL_UNSPECIFIED
}

func (x *OrderingConfig) GetCausalOrdering() bool {
	if x != nil && x.CausalOrdering != nil {
		return *x.CausalOrdering
	}
	return false
}

func (x *OrderingConfig) GetOrderingTimeoutMs() int32 {
	if x != nil && x.OrderingTimeoutMs != nil {
		return *x.OrderingTimeoutMs
	}
	return 0
}

// Conflict resolution configuration
type ConflictResolution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Conflict resolution strategy
	Strategy *ResolutionStrategy `protobuf:"varint,1,opt,name=strategy,enum=gcommon.v1.queue.ResolutionStrategy" json:"strategy,omitempty"`
	// Custom resolution function settings
	CustomResolution *CustomResolution `protobuf:"bytes,2,opt,name=custom_resolution,json=customResolution" json:"custom_resolution,omitempty"`
	// Last-writer-wins settings
	LwwConfig *LastWriterWins `protobuf:"bytes,3,opt,name=lww_config,json=lwwConfig" json:"lww_config,omitempty"`
	// Multi-value conflict handling
	MultiValue    *MultiValueConfig `protobuf:"bytes,4,opt,name=multi_value,json=multiValue" json:"multi_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConflictResolution) Reset() {
	*x = ConflictResolution{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConflictResolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConflictResolution) ProtoMessage() {}

func (x *ConflictResolution) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConflictResolution.ProtoReflect.Descriptor instead.
func (*ConflictResolution) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{9}
}

func (x *ConflictResolution) GetStrategy() ResolutionStrategy {
	if x != nil && x.Strategy != nil {
		return *x.Strategy
	}
	return ResolutionStrategy_RESOLUTION_STRATEGY_UNSPECIFIED
}

func (x *ConflictResolution) GetCustomResolution() *CustomResolution {
	if x != nil {
		return x.CustomResolution
	}
	return nil
}

func (x *ConflictResolution) GetLwwConfig() *LastWriterWins {
	if x != nil {
		return x.LwwConfig
	}
	return nil
}

func (x *ConflictResolution) GetMultiValue() *MultiValueConfig {
	if x != nil {
		return x.MultiValue
	}
	return nil
}

// Custom conflict resolution configuration
type CustomResolution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Resolution function name or identifier
	FunctionName *string `protobuf:"bytes,1,opt,name=function_name,json=functionName" json:"function_name,omitempty"`
	// Function parameters
	Parameters map[string]string `protobuf:"bytes,2,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Timeout for resolution function (milliseconds)
	TimeoutMs     *int32 `protobuf:"varint,3,opt,name=timeout_ms,json=timeoutMs" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CustomResolution) Reset() {
	*x = CustomResolution{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CustomResolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CustomResolution) ProtoMessage() {}

func (x *CustomResolution) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CustomResolution.ProtoReflect.Descriptor instead.
func (*CustomResolution) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{10}
}

func (x *CustomResolution) GetFunctionName() string {
	if x != nil && x.FunctionName != nil {
		return *x.FunctionName
	}
	return ""
}

func (x *CustomResolution) GetParameters() map[string]string {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *CustomResolution) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

// Last-writer-wins configuration
type LastWriterWins struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Use server timestamp instead of client timestamp
	UseServerTimestamp *bool `protobuf:"varint,1,opt,name=use_server_timestamp,json=useServerTimestamp" json:"use_server_timestamp,omitempty"`
	// Timestamp precision for comparison
	TimestampPrecision *string `protobuf:"bytes,2,opt,name=timestamp_precision,json=timestampPrecision" json:"timestamp_precision,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *LastWriterWins) Reset() {
	*x = LastWriterWins{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LastWriterWins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LastWriterWins) ProtoMessage() {}

func (x *LastWriterWins) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LastWriterWins.ProtoReflect.Descriptor instead.
func (*LastWriterWins) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{11}
}

func (x *LastWriterWins) GetUseServerTimestamp() bool {
	if x != nil && x.UseServerTimestamp != nil {
		return *x.UseServerTimestamp
	}
	return false
}

func (x *LastWriterWins) GetTimestampPrecision() string {
	if x != nil && x.TimestampPrecision != nil {
		return *x.TimestampPrecision
	}
	return ""
}

// Multi-value conflict configuration
type MultiValueConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum number of concurrent values to keep
	MaxValues *int32 `protobuf:"varint,1,opt,name=max_values,json=maxValues" json:"max_values,omitempty"`
	// Value expiration time (seconds)
	ValueTtlSeconds *int32 `protobuf:"varint,2,opt,name=value_ttl_seconds,json=valueTtlSeconds" json:"value_ttl_seconds,omitempty"`
	// Conflict value cleanup strategy
	CleanupStrategy *string `protobuf:"bytes,3,opt,name=cleanup_strategy,json=cleanupStrategy" json:"cleanup_strategy,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *MultiValueConfig) Reset() {
	*x = MultiValueConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiValueConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiValueConfig) ProtoMessage() {}

func (x *MultiValueConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiValueConfig.ProtoReflect.Descriptor instead.
func (*MultiValueConfig) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{12}
}

func (x *MultiValueConfig) GetMaxValues() int32 {
	if x != nil && x.MaxValues != nil {
		return *x.MaxValues
	}
	return 0
}

func (x *MultiValueConfig) GetValueTtlSeconds() int32 {
	if x != nil && x.ValueTtlSeconds != nil {
		return *x.ValueTtlSeconds
	}
	return 0
}

func (x *MultiValueConfig) GetCleanupStrategy() string {
	if x != nil && x.CleanupStrategy != nil {
		return *x.CleanupStrategy
	}
	return ""
}

// Consistency validation configuration
type ConsistencyValidation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable consistency validation
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Validation interval (seconds)
	ValidationIntervalSeconds *int32 `protobuf:"varint,2,opt,name=validation_interval_seconds,json=validationIntervalSeconds" json:"validation_interval_seconds,omitempty"`
	// Validation scope (local, cluster, global)
	ValidationScope *string `protobuf:"bytes,3,opt,name=validation_scope,json=validationScope" json:"validation_scope,omitempty"`
	// Actions to take on validation failure
	FailureActions []string `protobuf:"bytes,4,rep,name=failure_actions,json=failureActions" json:"failure_actions,omitempty"`
	// Validation timeout (milliseconds)
	TimeoutMs     *int32 `protobuf:"varint,5,opt,name=timeout_ms,json=timeoutMs" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConsistencyValidation) Reset() {
	*x = ConsistencyValidation{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConsistencyValidation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConsistencyValidation) ProtoMessage() {}

func (x *ConsistencyValidation) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConsistencyValidation.ProtoReflect.Descriptor instead.
func (*ConsistencyValidation) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{13}
}

func (x *ConsistencyValidation) GetEnabled() bool {
	if x != nil && x.Enabled != nil {
		return *x.Enabled
	}
	return false
}

func (x *ConsistencyValidation) GetValidationIntervalSeconds() int32 {
	if x != nil && x.ValidationIntervalSeconds != nil {
		return *x.ValidationIntervalSeconds
	}
	return 0
}

func (x *ConsistencyValidation) GetValidationScope() string {
	if x != nil && x.ValidationScope != nil {
		return *x.ValidationScope
	}
	return ""
}

func (x *ConsistencyValidation) GetFailureActions() []string {
	if x != nil {
		return x.FailureActions
	}
	return nil
}

func (x *ConsistencyValidation) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

// Read retry configuration
type ReadRetryConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum retry attempts
	MaxRetries *int32 `protobuf:"varint,1,opt,name=max_retries,json=maxRetries" json:"max_retries,omitempty"`
	// Initial retry delay (milliseconds)
	InitialDelayMs *int32 `protobuf:"varint,2,opt,name=initial_delay_ms,json=initialDelayMs" json:"initial_delay_ms,omitempty"`
	// Maximum retry delay (milliseconds)
	MaxDelayMs *int32 `protobuf:"varint,3,opt,name=max_delay_ms,json=maxDelayMs" json:"max_delay_ms,omitempty"`
	// Backoff multiplier
	BackoffMultiplier *float64 `protobuf:"fixed64,4,opt,name=backoff_multiplier,json=backoffMultiplier" json:"backoff_multiplier,omitempty"`
	// Retry on different replica
	RetryDifferentReplica *bool `protobuf:"varint,5,opt,name=retry_different_replica,json=retryDifferentReplica" json:"retry_different_replica,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ReadRetryConfig) Reset() {
	*x = ReadRetryConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadRetryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadRetryConfig) ProtoMessage() {}

func (x *ReadRetryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadRetryConfig.ProtoReflect.Descriptor instead.
func (*ReadRetryConfig) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{14}
}

func (x *ReadRetryConfig) GetMaxRetries() int32 {
	if x != nil && x.MaxRetries != nil {
		return *x.MaxRetries
	}
	return 0
}

func (x *ReadRetryConfig) GetInitialDelayMs() int32 {
	if x != nil && x.InitialDelayMs != nil {
		return *x.InitialDelayMs
	}
	return 0
}

func (x *ReadRetryConfig) GetMaxDelayMs() int32 {
	if x != nil && x.MaxDelayMs != nil {
		return *x.MaxDelayMs
	}
	return 0
}

func (x *ReadRetryConfig) GetBackoffMultiplier() float64 {
	if x != nil && x.BackoffMultiplier != nil {
		return *x.BackoffMultiplier
	}
	return 0
}

func (x *ReadRetryConfig) GetRetryDifferentReplica() bool {
	if x != nil && x.RetryDifferentReplica != nil {
		return *x.RetryDifferentReplica
	}
	return false
}

// Write retry configuration
type WriteRetryConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum retry attempts
	MaxRetries *int32 `protobuf:"varint,1,opt,name=max_retries,json=maxRetries" json:"max_retries,omitempty"`
	// Initial retry delay (milliseconds)
	InitialDelayMs *int32 `protobuf:"varint,2,opt,name=initial_delay_ms,json=initialDelayMs" json:"initial_delay_ms,omitempty"`
	// Maximum retry delay (milliseconds)
	MaxDelayMs *int32 `protobuf:"varint,3,opt,name=max_delay_ms,json=maxDelayMs" json:"max_delay_ms,omitempty"`
	// Backoff multiplier
	BackoffMultiplier *float64 `protobuf:"fixed64,4,opt,name=backoff_multiplier,json=backoffMultiplier" json:"backoff_multiplier,omitempty"`
	// Retry idempotent operations only
	IdempotentOnly *bool `protobuf:"varint,5,opt,name=idempotent_only,json=idempotentOnly" json:"idempotent_only,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *WriteRetryConfig) Reset() {
	*x = WriteRetryConfig{}
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteRetryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteRetryConfig) ProtoMessage() {}

func (x *WriteRetryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_queue_proto_consistency_config_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteRetryConfig.ProtoReflect.Descriptor instead.
func (*WriteRetryConfig) Descriptor() ([]byte, []int) {
	return file_pkg_queue_proto_consistency_config_proto_rawDescGZIP(), []int{15}
}

func (x *WriteRetryConfig) GetMaxRetries() int32 {
	if x != nil && x.MaxRetries != nil {
		return *x.MaxRetries
	}
	return 0
}

func (x *WriteRetryConfig) GetInitialDelayMs() int32 {
	if x != nil && x.InitialDelayMs != nil {
		return *x.InitialDelayMs
	}
	return 0
}

func (x *WriteRetryConfig) GetMaxDelayMs() int32 {
	if x != nil && x.MaxDelayMs != nil {
		return *x.MaxDelayMs
	}
	return 0
}

func (x *WriteRetryConfig) GetBackoffMultiplier() float64 {
	if x != nil && x.BackoffMultiplier != nil {
		return *x.BackoffMultiplier
	}
	return 0
}

func (x *WriteRetryConfig) GetIdempotentOnly() bool {
	if x != nil && x.IdempotentOnly != nil {
		return *x.IdempotentOnly
	}
	return false
}

var File_pkg_queue_proto_consistency_config_proto protoreflect.FileDescriptor

const file_pkg_queue_proto_consistency_config_proto_rawDesc = "" +
	"\n" +
	"(pkg/queue/proto/consistency_config.proto\x12\x10gcommon.v1.queue\x1a&pkg/queue/proto/durability_level.proto\x1a\x1fpkg/queue/proto/ack_level.proto\"\xe3\x04\n" +
	"\x11ConsistencyConfig\x12L\n" +
	"\x10durability_level\x18\x01 \x01(\x0e2!.gcommon.v1.queue.DurabilityLevelR\x0fdurabilityLevel\x127\n" +
	"\tack_level\x18\x02 \x01(\x0e2\x1a.gcommon.v1.queue.AckLevelR\backLevel\x12J\n" +
	"\vreplication\x18\x03 \x01(\v2(.gcommon.v1.queue.ReplicationConsistencyR\vreplication\x12L\n" +
	"\x10read_consistency\x18\x04 \x01(\v2!.gcommon.v1.queue.ReadConsistencyR\x0freadConsistency\x12O\n" +
	"\x11write_consistency\x18\x05 \x01(\v2\".gcommon.v1.queue.WriteConsistencyR\x10writeConsistency\x12<\n" +
	"\bordering\x18\x06 \x01(\v2 .gcommon.v1.queue.OrderingConfigR\bordering\x12U\n" +
	"\x13conflict_resolution\x18\a \x01(\v2$.gcommon.v1.queue.ConflictResolutionR\x12conflictResolution\x12G\n" +
	"\n" +
	"validation\x18\b \x01(\v2'.gcommon.v1.queue.ConsistencyValidationR\n" +
	"validation\"\xdc\x02\n" +
	"\x16ReplicationConsistency\x12,\n" +
	"\x12min_write_replicas\x18\x01 \x01(\x05R\x10minWriteReplicas\x12*\n" +
	"\x11min_read_replicas\x18\x02 \x01(\x05R\x0fminReadReplicas\x12-\n" +
	"\x12replication_factor\x18\x03 \x01(\x05R\x11replicationFactor\x12O\n" +
	"\x11replication_level\x18\x04 \x01(\x0e2\".gcommon.v1.queue.ReplicationLevelR\x10replicationLevel\x120\n" +
	"\x14anti_entropy_enabled\x18\x05 \x01(\bR\x12antiEntropyEnabled\x126\n" +
	"\x17repair_interval_seconds\x18\x06 \x01(\x05R\x15repairIntervalSeconds\"\xa6\x02\n" +
	"\x0fReadConsistency\x121\n" +
	"\x05level\x18\x01 \x01(\x0e2\x1b.gcommon.v1.queue.ReadLevelR\x05level\x12(\n" +
	"\x10max_staleness_ms\x18\x02 \x01(\x03R\x0emaxStalenessMs\x12(\n" +
	"\x10read_your_writes\x18\x03 \x01(\bR\x0ereadYourWrites\x12'\n" +
	"\x0fmonotonic_reads\x18\x04 \x01(\bR\x0emonotonicReads\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x05 \x01(\x05R\ttimeoutMs\x12D\n" +
	"\fretry_config\x18\x06 \x01(\v2!.gcommon.v1.queue.ReadRetryConfigR\vretryConfig\"\xce\x02\n" +
	"\x10WriteConsistency\x122\n" +
	"\x05level\x18\x01 \x01(\x0e2\x1c.gcommon.v1.queue.WriteLevelR\x05level\x12L\n" +
	"\x10sync_replication\x18\x02 \x01(\v2!.gcommon.v1.queue.SyncReplicationR\x0fsyncReplication\x12R\n" +
	"\x12conflict_detection\x18\x03 \x01(\v2#.gcommon.v1.queue.ConflictDetectionR\x11conflictDetection\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x04 \x01(\x05R\ttimeoutMs\x12E\n" +
	"\fretry_config\x18\x05 \x01(\v2\".gcommon.v1.queue.WriteRetryConfigR\vretryConfig\"\xab\x01\n" +
	"\x0fSyncReplication\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12*\n" +
	"\x11min_sync_replicas\x18\x02 \x01(\x05R\x0fminSyncReplicas\x12&\n" +
	"\x0fsync_timeout_ms\x18\x03 \x01(\x05R\rsyncTimeoutMs\x12*\n" +
	"\x11fallback_to_async\x18\x04 \x01(\bR\x0ffallbackToAsync\"\x83\x02\n" +
	"\x11ConflictDetection\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12>\n" +
	"\bstrategy\x18\x02 \x01(\x0e2\".gcommon.v1.queue.ConflictStrategyR\bstrategy\x12F\n" +
	"\fvector_clock\x18\x03 \x01(\v2#.gcommon.v1.queue.VectorClockConfigR\vvectorClock\x12L\n" +
	"\x10timestamp_config\x18\x04 \x01(\v2!.gcommon.v1.queue.TimestampConfigR\x0ftimestampConfig\"m\n" +
	"\x11VectorClockConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1c\n" +
	"\tprecision\x18\x02 \x01(\tR\tprecision\x12 \n" +
	"\fmax_drift_ms\x18\x03 \x01(\x03R\n" +
	"maxDriftMs\"}\n" +
	"\x0fTimestampConfig\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x122\n" +
	"\x15sync_interval_seconds\x18\x02 \x01(\x05R\x13syncIntervalSeconds\x12\x1e\n" +
	"\vmax_skew_ms\x18\x03 \x01(\x03R\tmaxSkewMs\"\xd1\x02\n" +
	"\x0eOrderingConfig\x12H\n" +
	"\x0fglobal_ordering\x18\x01 \x01(\x0e2\x1f.gcommon.v1.queue.OrderingLevelR\x0eglobalOrdering\x12N\n" +
	"\x12partition_ordering\x18\x02 \x01(\x0e2\x1f.gcommon.v1.queue.OrderingLevelR\x11partitionOrdering\x12L\n" +
	"\x11producer_ordering\x18\x03 \x01(\x0e2\x1f.gcommon.v1.queue.OrderingLevelR\x10producerOrdering\x12'\n" +
	"\x0fcausal_ordering\x18\x04 \x01(\bR\x0ecausalOrdering\x12.\n" +
	"\x13ordering_timeout_ms\x18\x05 \x01(\x05R\x11orderingTimeoutMs\"\xad\x02\n" +
	"\x12ConflictResolution\x12@\n" +
	"\bstrategy\x18\x01 \x01(\x0e2$.gcommon.v1.queue.ResolutionStrategyR\bstrategy\x12O\n" +
	"\x11custom_resolution\x18\x02 \x01(\v2\".gcommon.v1.queue.CustomResolutionR\x10customResolution\x12?\n" +
	"\n" +
	"lww_config\x18\x03 \x01(\v2 .gcommon.v1.queue.LastWriterWinsR\tlwwConfig\x12C\n" +
	"\vmulti_value\x18\x04 \x01(\v2\".gcommon.v1.queue.MultiValueConfigR\n" +
	"multiValue\"\xe9\x01\n" +
	"\x10CustomResolution\x12#\n" +
	"\rfunction_name\x18\x01 \x01(\tR\ffunctionName\x12R\n" +
	"\n" +
	"parameters\x18\x02 \x03(\v22.gcommon.v1.queue.CustomResolution.ParametersEntryR\n" +
	"parameters\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x03 \x01(\x05R\ttimeoutMs\x1a=\n" +
	"\x0fParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"s\n" +
	"\x0eLastWriterWins\x120\n" +
	"\x14use_server_timestamp\x18\x01 \x01(\bR\x12useServerTimestamp\x12/\n" +
	"\x13timestamp_precision\x18\x02 \x01(\tR\x12timestampPrecision\"\x88\x01\n" +
	"\x10MultiValueConfig\x12\x1d\n" +
	"\n" +
	"max_values\x18\x01 \x01(\x05R\tmaxValues\x12*\n" +
	"\x11value_ttl_seconds\x18\x02 \x01(\x05R\x0fvalueTtlSeconds\x12)\n" +
	"\x10cleanup_strategy\x18\x03 \x01(\tR\x0fcleanupStrategy\"\xe4\x01\n" +
	"\x15ConsistencyValidation\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12>\n" +
	"\x1bvalidation_interval_seconds\x18\x02 \x01(\x05R\x19validationIntervalSeconds\x12)\n" +
	"\x10validation_scope\x18\x03 \x01(\tR\x0fvalidationScope\x12'\n" +
	"\x0ffailure_actions\x18\x04 \x03(\tR\x0efailureActions\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x05 \x01(\x05R\ttimeoutMs\"\xe5\x01\n" +
	"\x0fReadRetryConfig\x12\x1f\n" +
	"\vmax_retries\x18\x01 \x01(\x05R\n" +
	"maxRetries\x12(\n" +
	"\x10initial_delay_ms\x18\x02 \x01(\x05R\x0einitialDelayMs\x12 \n" +
	"\fmax_delay_ms\x18\x03 \x01(\x05R\n" +
	"maxDelayMs\x12-\n" +
	"\x12backoff_multiplier\x18\x04 \x01(\x01R\x11backoffMultiplier\x126\n" +
	"\x17retry_different_replica\x18\x05 \x01(\bR\x15retryDifferentReplica\"\xd7\x01\n" +
	"\x10WriteRetryConfig\x12\x1f\n" +
	"\vmax_retries\x18\x01 \x01(\x05R\n" +
	"maxRetries\x12(\n" +
	"\x10initial_delay_ms\x18\x02 \x01(\x05R\x0einitialDelayMs\x12 \n" +
	"\fmax_delay_ms\x18\x03 \x01(\x05R\n" +
	"maxDelayMs\x12-\n" +
	"\x12backoff_multiplier\x18\x04 \x01(\x01R\x11backoffMultiplier\x12'\n" +
	"\x0fidempotent_only\x18\x05 \x01(\bR\x0eidempotentOnly*\x89\x01\n" +
	"\x10ReplicationLevel\x12!\n" +
	"\x1dREPLICATION_LEVEL_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15REPLICATION_LEVEL_ONE\x10\x01\x12\x1c\n" +
	"\x18REPLICATION_LEVEL_QUORUM\x10\x02\x12\x19\n" +
	"\x15REPLICATION_LEVEL_ALL\x10\x03*\x91\x01\n" +
	"\tReadLevel\x12\x1a\n" +
	"\x16READ_LEVEL_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13READ_LEVEL_EVENTUAL\x10\x01\x12\x15\n" +
	"\x11READ_LEVEL_STRONG\x10\x02\x12 \n" +
	"\x1cREAD_LEVEL_BOUNDED_STALENESS\x10\x03\x12\x16\n" +
	"\x12READ_LEVEL_SESSION\x10\x04*\x91\x01\n" +
	"\n" +
	"WriteLevel\x12\x1b\n" +
	"\x17WRITE_LEVEL_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11WRITE_LEVEL_ASYNC\x10\x01\x12\x18\n" +
	"\x14WRITE_LEVEL_SYNC_ONE\x10\x02\x12\x1b\n" +
	"\x17WRITE_LEVEL_SYNC_QUORUM\x10\x03\x12\x18\n" +
	"\x14WRITE_LEVEL_SYNC_ALL\x10\x04*\x98\x01\n" +
	"\x10ConflictStrategy\x12!\n" +
	"\x1dCONFLICT_STRATEGY_UNSPECIFIED\x10\x00\x12\x1f\n" +
	"\x1bCONFLICT_STRATEGY_TIMESTAMP\x10\x01\x12\"\n" +
	"\x1eCONFLICT_STRATEGY_VECTOR_CLOCK\x10\x02\x12\x1c\n" +
	"\x18CONFLICT_STRATEGY_CAUSAL\x10\x03*~\n" +
	"\rOrderingLevel\x12\x1e\n" +
	"\x1aORDERING_LEVEL_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13ORDERING_LEVEL_NONE\x10\x01\x12\x1a\n" +
	"\x16ORDERING_LEVEL_PARTIAL\x10\x02\x12\x18\n" +
	"\x14ORDERING_LEVEL_TOTAL\x10\x03*\xf2\x01\n" +
	"\x12ResolutionStrategy\x12#\n" +
	"\x1fRESOLUTION_STRATEGY_UNSPECIFIED\x10\x00\x12(\n" +
	"$RESOLUTION_STRATEGY_LAST_WRITER_WINS\x10\x01\x12)\n" +
	"%RESOLUTION_STRATEGY_FIRST_WRITER_WINS\x10\x02\x12\x1d\n" +
	"\x19RESOLUTION_STRATEGY_MERGE\x10\x03\x12\x1e\n" +
	"\x1aRESOLUTION_STRATEGY_CUSTOM\x10\x04\x12#\n" +
	"\x1fRESOLUTION_STRATEGY_MULTI_VALUE\x10\x05B\xbb\x01\n" +
	"\x14com.gcommon.v1.queueB\x16ConsistencyConfigProtoP\x01Z)github.com/jdfalk/gcommon/pkg/queue/proto\xa2\x02\x03GVQ\xaa\x02\x10Gcommon.V1.Queue\xca\x02\x10Gcommon\\V1\\Queue\xe2\x02\x1cGcommon\\V1\\Queue\\GPBMetadata\xea\x02\x12Gcommon::V1::Queueb\beditionsp\xe8\a"

var (
	file_pkg_queue_proto_consistency_config_proto_rawDescOnce sync.Once
	file_pkg_queue_proto_consistency_config_proto_rawDescData []byte
)

func file_pkg_queue_proto_consistency_config_proto_rawDescGZIP() []byte {
	file_pkg_queue_proto_consistency_config_proto_rawDescOnce.Do(func() {
		file_pkg_queue_proto_consistency_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pkg_queue_proto_consistency_config_proto_rawDesc), len(file_pkg_queue_proto_consistency_config_proto_rawDesc)))
	})
	return file_pkg_queue_proto_consistency_config_proto_rawDescData
}

var file_pkg_queue_proto_consistency_config_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_pkg_queue_proto_consistency_config_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_pkg_queue_proto_consistency_config_proto_goTypes = []any{
	(ReplicationLevel)(0),          // 0: gcommon.v1.queue.ReplicationLevel
	(ReadLevel)(0),                 // 1: gcommon.v1.queue.ReadLevel
	(WriteLevel)(0),                // 2: gcommon.v1.queue.WriteLevel
	(ConflictStrategy)(0),          // 3: gcommon.v1.queue.ConflictStrategy
	(OrderingLevel)(0),             // 4: gcommon.v1.queue.OrderingLevel
	(ResolutionStrategy)(0),        // 5: gcommon.v1.queue.ResolutionStrategy
	(*ConsistencyConfig)(nil),      // 6: gcommon.v1.queue.ConsistencyConfig
	(*ReplicationConsistency)(nil), // 7: gcommon.v1.queue.ReplicationConsistency
	(*ReadConsistency)(nil),        // 8: gcommon.v1.queue.ReadConsistency
	(*WriteConsistency)(nil),       // 9: gcommon.v1.queue.WriteConsistency
	(*SyncReplication)(nil),        // 10: gcommon.v1.queue.SyncReplication
	(*ConflictDetection)(nil),      // 11: gcommon.v1.queue.ConflictDetection
	(*VectorClockConfig)(nil),      // 12: gcommon.v1.queue.VectorClockConfig
	(*TimestampConfig)(nil),        // 13: gcommon.v1.queue.TimestampConfig
	(*OrderingConfig)(nil),         // 14: gcommon.v1.queue.OrderingConfig
	(*ConflictResolution)(nil),     // 15: gcommon.v1.queue.ConflictResolution
	(*CustomResolution)(nil),       // 16: gcommon.v1.queue.CustomResolution
	(*LastWriterWins)(nil),         // 17: gcommon.v1.queue.LastWriterWins
	(*MultiValueConfig)(nil),       // 18: gcommon.v1.queue.MultiValueConfig
	(*ConsistencyValidation)(nil),  // 19: gcommon.v1.queue.ConsistencyValidation
	(*ReadRetryConfig)(nil),        // 20: gcommon.v1.queue.ReadRetryConfig
	(*WriteRetryConfig)(nil),       // 21: gcommon.v1.queue.WriteRetryConfig
	nil,                            // 22: gcommon.v1.queue.CustomResolution.ParametersEntry
	(DurabilityLevel)(0),           // 23: gcommon.v1.queue.DurabilityLevel
	(AckLevel)(0),                  // 24: gcommon.v1.queue.AckLevel
}
var file_pkg_queue_proto_consistency_config_proto_depIdxs = []int32{
	23, // 0: gcommon.v1.queue.ConsistencyConfig.durability_level:type_name -> gcommon.v1.queue.DurabilityLevel
	24, // 1: gcommon.v1.queue.ConsistencyConfig.ack_level:type_name -> gcommon.v1.queue.AckLevel
	7,  // 2: gcommon.v1.queue.ConsistencyConfig.replication:type_name -> gcommon.v1.queue.ReplicationConsistency
	8,  // 3: gcommon.v1.queue.ConsistencyConfig.read_consistency:type_name -> gcommon.v1.queue.ReadConsistency
	9,  // 4: gcommon.v1.queue.ConsistencyConfig.write_consistency:type_name -> gcommon.v1.queue.WriteConsistency
	14, // 5: gcommon.v1.queue.ConsistencyConfig.ordering:type_name -> gcommon.v1.queue.OrderingConfig
	15, // 6: gcommon.v1.queue.ConsistencyConfig.conflict_resolution:type_name -> gcommon.v1.queue.ConflictResolution
	19, // 7: gcommon.v1.queue.ConsistencyConfig.validation:type_name -> gcommon.v1.queue.ConsistencyValidation
	0,  // 8: gcommon.v1.queue.ReplicationConsistency.replication_level:type_name -> gcommon.v1.queue.ReplicationLevel
	1,  // 9: gcommon.v1.queue.ReadConsistency.level:type_name -> gcommon.v1.queue.ReadLevel
	20, // 10: gcommon.v1.queue.ReadConsistency.retry_config:type_name -> gcommon.v1.queue.ReadRetryConfig
	2,  // 11: gcommon.v1.queue.WriteConsistency.level:type_name -> gcommon.v1.queue.WriteLevel
	10, // 12: gcommon.v1.queue.WriteConsistency.sync_replication:type_name -> gcommon.v1.queue.SyncReplication
	11, // 13: gcommon.v1.queue.WriteConsistency.conflict_detection:type_name -> gcommon.v1.queue.ConflictDetection
	21, // 14: gcommon.v1.queue.WriteConsistency.retry_config:type_name -> gcommon.v1.queue.WriteRetryConfig
	3,  // 15: gcommon.v1.queue.ConflictDetection.strategy:type_name -> gcommon.v1.queue.ConflictStrategy
	12, // 16: gcommon.v1.queue.ConflictDetection.vector_clock:type_name -> gcommon.v1.queue.VectorClockConfig
	13, // 17: gcommon.v1.queue.ConflictDetection.timestamp_config:type_name -> gcommon.v1.queue.TimestampConfig
	4,  // 18: gcommon.v1.queue.OrderingConfig.global_ordering:type_name -> gcommon.v1.queue.OrderingLevel
	4,  // 19: gcommon.v1.queue.OrderingConfig.partition_ordering:type_name -> gcommon.v1.queue.OrderingLevel
	4,  // 20: gcommon.v1.queue.OrderingConfig.producer_ordering:type_name -> gcommon.v1.queue.OrderingLevel
	5,  // 21: gcommon.v1.queue.ConflictResolution.strategy:type_name -> gcommon.v1.queue.ResolutionStrategy
	16, // 22: gcommon.v1.queue.ConflictResolution.custom_resolution:type_name -> gcommon.v1.queue.CustomResolution
	17, // 23: gcommon.v1.queue.ConflictResolution.lww_config:type_name -> gcommon.v1.queue.LastWriterWins
	18, // 24: gcommon.v1.queue.ConflictResolution.multi_value:type_name -> gcommon.v1.queue.MultiValueConfig
	22, // 25: gcommon.v1.queue.CustomResolution.parameters:type_name -> gcommon.v1.queue.CustomResolution.ParametersEntry
	26, // [26:26] is the sub-list for method output_type
	26, // [26:26] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_pkg_queue_proto_consistency_config_proto_init() }
func file_pkg_queue_proto_consistency_config_proto_init() {
	if File_pkg_queue_proto_consistency_config_proto != nil {
		return
	}
	file_pkg_queue_proto_durability_level_proto_init()
	file_pkg_queue_proto_ack_level_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_pkg_queue_proto_consistency_config_proto_rawDesc), len(file_pkg_queue_proto_consistency_config_proto_rawDesc)),
			NumEnums:      6,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_pkg_queue_proto_consistency_config_proto_goTypes,
		DependencyIndexes: file_pkg_queue_proto_consistency_config_proto_depIdxs,
		EnumInfos:         file_pkg_queue_proto_consistency_config_proto_enumTypes,
		MessageInfos:      file_pkg_queue_proto_consistency_config_proto_msgTypes,
	}.Build()
	File_pkg_queue_proto_consistency_config_proto = out.File
	file_pkg_queue_proto_consistency_config_proto_goTypes = nil
	file_pkg_queue_proto_consistency_config_proto_depIdxs = nil
}
