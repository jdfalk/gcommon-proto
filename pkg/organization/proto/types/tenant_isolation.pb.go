// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: pkg/organization/proto/types/tenant_isolation.proto

//go:build !protoopaque

package types

import (
	types "github.com/jdfalk/gcommon/pkg/common/proto/types"
	enums "github.com/jdfalk/gcommon/pkg/organization/proto/enums"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	_ "google.golang.org/protobuf/types/gofeaturespb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// TenantIsolation type defining the isolation configuration for a tenant.
// Specifies how tenant data and resources are separated from other tenants.
type TenantIsolation struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Tenant identifier
	TenantId *string `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId" json:"tenant_id,omitempty"`
	// Isolation level for this tenant
	Level *enums.IsolationLevel `protobuf:"varint,2,opt,name=level,enum=gcommon.v1.organization.IsolationLevel" json:"level,omitempty"`
	// Database isolation configuration
	Database *DatabaseIsolation `protobuf:"bytes,3,opt,name=database" json:"database,omitempty"`
	// Network isolation configuration
	Network *NetworkIsolation `protobuf:"bytes,4,opt,name=network" json:"network,omitempty"`
	// Storage isolation configuration
	Storage *StorageIsolation `protobuf:"bytes,5,opt,name=storage" json:"storage,omitempty"`
	// Compute isolation configuration
	Compute *ComputeIsolation `protobuf:"bytes,6,opt,name=compute" json:"compute,omitempty"`
	// Encryption configuration for tenant data
	Encryption *EncryptionConfig `protobuf:"bytes,7,opt,name=encryption" json:"encryption,omitempty"`
	// Access control configuration
	AccessControl *AccessControl `protobuf:"bytes,8,opt,name=access_control,json=accessControl" json:"access_control,omitempty"`
	// Audit and compliance configuration
	Audit *AuditConfig `protobuf:"bytes,9,opt,name=audit" json:"audit,omitempty"`
	// Isolation metadata and custom settings
	Metadata []*types.KeyValue `protobuf:"bytes,10,rep,name=metadata" json:"metadata,omitempty"`
	// Isolation configuration creation timestamp
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	// Last update timestamp
	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=updated_at,json=updatedAt" json:"updated_at,omitempty"`
	// User ID who configured this isolation
	ConfiguredBy  *string `protobuf:"bytes,13,opt,name=configured_by,json=configuredBy" json:"configured_by,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TenantIsolation) Reset() {
	*x = TenantIsolation{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TenantIsolation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TenantIsolation) ProtoMessage() {}

func (x *TenantIsolation) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TenantIsolation) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *TenantIsolation) GetLevel() enums.IsolationLevel {
	if x != nil && x.Level != nil {
		return *x.Level
	}
	return enums.IsolationLevel(0)
}

func (x *TenantIsolation) GetDatabase() *DatabaseIsolation {
	if x != nil {
		return x.Database
	}
	return nil
}

func (x *TenantIsolation) GetNetwork() *NetworkIsolation {
	if x != nil {
		return x.Network
	}
	return nil
}

func (x *TenantIsolation) GetStorage() *StorageIsolation {
	if x != nil {
		return x.Storage
	}
	return nil
}

func (x *TenantIsolation) GetCompute() *ComputeIsolation {
	if x != nil {
		return x.Compute
	}
	return nil
}

func (x *TenantIsolation) GetEncryption() *EncryptionConfig {
	if x != nil {
		return x.Encryption
	}
	return nil
}

func (x *TenantIsolation) GetAccessControl() *AccessControl {
	if x != nil {
		return x.AccessControl
	}
	return nil
}

func (x *TenantIsolation) GetAudit() *AuditConfig {
	if x != nil {
		return x.Audit
	}
	return nil
}

func (x *TenantIsolation) GetMetadata() []*types.KeyValue {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *TenantIsolation) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *TenantIsolation) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *TenantIsolation) GetConfiguredBy() string {
	if x != nil && x.ConfiguredBy != nil {
		return *x.ConfiguredBy
	}
	return ""
}

func (x *TenantIsolation) SetTenantId(v string) {
	x.TenantId = &v
}

func (x *TenantIsolation) SetLevel(v enums.IsolationLevel) {
	x.Level = &v
}

func (x *TenantIsolation) SetDatabase(v *DatabaseIsolation) {
	x.Database = v
}

func (x *TenantIsolation) SetNetwork(v *NetworkIsolation) {
	x.Network = v
}

func (x *TenantIsolation) SetStorage(v *StorageIsolation) {
	x.Storage = v
}

func (x *TenantIsolation) SetCompute(v *ComputeIsolation) {
	x.Compute = v
}

func (x *TenantIsolation) SetEncryption(v *EncryptionConfig) {
	x.Encryption = v
}

func (x *TenantIsolation) SetAccessControl(v *AccessControl) {
	x.AccessControl = v
}

func (x *TenantIsolation) SetAudit(v *AuditConfig) {
	x.Audit = v
}

func (x *TenantIsolation) SetMetadata(v []*types.KeyValue) {
	x.Metadata = v
}

func (x *TenantIsolation) SetCreatedAt(v *timestamppb.Timestamp) {
	x.CreatedAt = v
}

func (x *TenantIsolation) SetUpdatedAt(v *timestamppb.Timestamp) {
	x.UpdatedAt = v
}

func (x *TenantIsolation) SetConfiguredBy(v string) {
	x.ConfiguredBy = &v
}

func (x *TenantIsolation) HasTenantId() bool {
	if x == nil {
		return false
	}
	return x.TenantId != nil
}

func (x *TenantIsolation) HasLevel() bool {
	if x == nil {
		return false
	}
	return x.Level != nil
}

func (x *TenantIsolation) HasDatabase() bool {
	if x == nil {
		return false
	}
	return x.Database != nil
}

func (x *TenantIsolation) HasNetwork() bool {
	if x == nil {
		return false
	}
	return x.Network != nil
}

func (x *TenantIsolation) HasStorage() bool {
	if x == nil {
		return false
	}
	return x.Storage != nil
}

func (x *TenantIsolation) HasCompute() bool {
	if x == nil {
		return false
	}
	return x.Compute != nil
}

func (x *TenantIsolation) HasEncryption() bool {
	if x == nil {
		return false
	}
	return x.Encryption != nil
}

func (x *TenantIsolation) HasAccessControl() bool {
	if x == nil {
		return false
	}
	return x.AccessControl != nil
}

func (x *TenantIsolation) HasAudit() bool {
	if x == nil {
		return false
	}
	return x.Audit != nil
}

func (x *TenantIsolation) HasCreatedAt() bool {
	if x == nil {
		return false
	}
	return x.CreatedAt != nil
}

func (x *TenantIsolation) HasUpdatedAt() bool {
	if x == nil {
		return false
	}
	return x.UpdatedAt != nil
}

func (x *TenantIsolation) HasConfiguredBy() bool {
	if x == nil {
		return false
	}
	return x.ConfiguredBy != nil
}

func (x *TenantIsolation) ClearTenantId() {
	x.TenantId = nil
}

func (x *TenantIsolation) ClearLevel() {
	x.Level = nil
}

func (x *TenantIsolation) ClearDatabase() {
	x.Database = nil
}

func (x *TenantIsolation) ClearNetwork() {
	x.Network = nil
}

func (x *TenantIsolation) ClearStorage() {
	x.Storage = nil
}

func (x *TenantIsolation) ClearCompute() {
	x.Compute = nil
}

func (x *TenantIsolation) ClearEncryption() {
	x.Encryption = nil
}

func (x *TenantIsolation) ClearAccessControl() {
	x.AccessControl = nil
}

func (x *TenantIsolation) ClearAudit() {
	x.Audit = nil
}

func (x *TenantIsolation) ClearCreatedAt() {
	x.CreatedAt = nil
}

func (x *TenantIsolation) ClearUpdatedAt() {
	x.UpdatedAt = nil
}

func (x *TenantIsolation) ClearConfiguredBy() {
	x.ConfiguredBy = nil
}

type TenantIsolation_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Tenant identifier
	TenantId *string
	// Isolation level for this tenant
	Level *enums.IsolationLevel
	// Database isolation configuration
	Database *DatabaseIsolation
	// Network isolation configuration
	Network *NetworkIsolation
	// Storage isolation configuration
	Storage *StorageIsolation
	// Compute isolation configuration
	Compute *ComputeIsolation
	// Encryption configuration for tenant data
	Encryption *EncryptionConfig
	// Access control configuration
	AccessControl *AccessControl
	// Audit and compliance configuration
	Audit *AuditConfig
	// Isolation metadata and custom settings
	Metadata []*types.KeyValue
	// Isolation configuration creation timestamp
	CreatedAt *timestamppb.Timestamp
	// Last update timestamp
	UpdatedAt *timestamppb.Timestamp
	// User ID who configured this isolation
	ConfiguredBy *string
}

func (b0 TenantIsolation_builder) Build() *TenantIsolation {
	m0 := &TenantIsolation{}
	b, x := &b0, m0
	_, _ = b, x
	x.TenantId = b.TenantId
	x.Level = b.Level
	x.Database = b.Database
	x.Network = b.Network
	x.Storage = b.Storage
	x.Compute = b.Compute
	x.Encryption = b.Encryption
	x.AccessControl = b.AccessControl
	x.Audit = b.Audit
	x.Metadata = b.Metadata
	x.CreatedAt = b.CreatedAt
	x.UpdatedAt = b.UpdatedAt
	x.ConfiguredBy = b.ConfiguredBy
	return m0
}

// *
// DatabaseIsolation type defining database-level isolation for a tenant.
type DatabaseIsolation struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Database instance identifier (for INFRASTRUCTURE isolation)
	DatabaseInstance *string `protobuf:"bytes,1,opt,name=database_instance,json=databaseInstance" json:"database_instance,omitempty"`
	// Schema or database name for this tenant
	SchemaName *string `protobuf:"bytes,2,opt,name=schema_name,json=schemaName" json:"schema_name,omitempty"`
	// Database connection parameters
	ConnectionParams []*types.KeyValue `protobuf:"bytes,3,rep,name=connection_params,json=connectionParams" json:"connection_params,omitempty"`
	// Whether tenant has dedicated database
	DedicatedDatabase *bool `protobuf:"varint,4,opt,name=dedicated_database,json=dedicatedDatabase" json:"dedicated_database,omitempty"`
	// Database backup configuration
	Backup *BackupConfig `protobuf:"bytes,5,opt,name=backup" json:"backup,omitempty"`
	// Database access restrictions
	AllowedOperations []string `protobuf:"bytes,6,rep,name=allowed_operations,json=allowedOperations" json:"allowed_operations,omitempty"`
	// Maximum connections allowed for this tenant
	MaxConnections *int32 `protobuf:"varint,7,opt,name=max_connections,json=maxConnections" json:"max_connections,omitempty"`
	// Query timeout in seconds
	QueryTimeoutSeconds *int32 `protobuf:"varint,8,opt,name=query_timeout_seconds,json=queryTimeoutSeconds" json:"query_timeout_seconds,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *DatabaseIsolation) Reset() {
	*x = DatabaseIsolation{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DatabaseIsolation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DatabaseIsolation) ProtoMessage() {}

func (x *DatabaseIsolation) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DatabaseIsolation) GetDatabaseInstance() string {
	if x != nil && x.DatabaseInstance != nil {
		return *x.DatabaseInstance
	}
	return ""
}

func (x *DatabaseIsolation) GetSchemaName() string {
	if x != nil && x.SchemaName != nil {
		return *x.SchemaName
	}
	return ""
}

func (x *DatabaseIsolation) GetConnectionParams() []*types.KeyValue {
	if x != nil {
		return x.ConnectionParams
	}
	return nil
}

func (x *DatabaseIsolation) GetDedicatedDatabase() bool {
	if x != nil && x.DedicatedDatabase != nil {
		return *x.DedicatedDatabase
	}
	return false
}

func (x *DatabaseIsolation) GetBackup() *BackupConfig {
	if x != nil {
		return x.Backup
	}
	return nil
}

func (x *DatabaseIsolation) GetAllowedOperations() []string {
	if x != nil {
		return x.AllowedOperations
	}
	return nil
}

func (x *DatabaseIsolation) GetMaxConnections() int32 {
	if x != nil && x.MaxConnections != nil {
		return *x.MaxConnections
	}
	return 0
}

func (x *DatabaseIsolation) GetQueryTimeoutSeconds() int32 {
	if x != nil && x.QueryTimeoutSeconds != nil {
		return *x.QueryTimeoutSeconds
	}
	return 0
}

func (x *DatabaseIsolation) SetDatabaseInstance(v string) {
	x.DatabaseInstance = &v
}

func (x *DatabaseIsolation) SetSchemaName(v string) {
	x.SchemaName = &v
}

func (x *DatabaseIsolation) SetConnectionParams(v []*types.KeyValue) {
	x.ConnectionParams = v
}

func (x *DatabaseIsolation) SetDedicatedDatabase(v bool) {
	x.DedicatedDatabase = &v
}

func (x *DatabaseIsolation) SetBackup(v *BackupConfig) {
	x.Backup = v
}

func (x *DatabaseIsolation) SetAllowedOperations(v []string) {
	x.AllowedOperations = v
}

func (x *DatabaseIsolation) SetMaxConnections(v int32) {
	x.MaxConnections = &v
}

func (x *DatabaseIsolation) SetQueryTimeoutSeconds(v int32) {
	x.QueryTimeoutSeconds = &v
}

func (x *DatabaseIsolation) HasDatabaseInstance() bool {
	if x == nil {
		return false
	}
	return x.DatabaseInstance != nil
}

func (x *DatabaseIsolation) HasSchemaName() bool {
	if x == nil {
		return false
	}
	return x.SchemaName != nil
}

func (x *DatabaseIsolation) HasDedicatedDatabase() bool {
	if x == nil {
		return false
	}
	return x.DedicatedDatabase != nil
}

func (x *DatabaseIsolation) HasBackup() bool {
	if x == nil {
		return false
	}
	return x.Backup != nil
}

func (x *DatabaseIsolation) HasMaxConnections() bool {
	if x == nil {
		return false
	}
	return x.MaxConnections != nil
}

func (x *DatabaseIsolation) HasQueryTimeoutSeconds() bool {
	if x == nil {
		return false
	}
	return x.QueryTimeoutSeconds != nil
}

func (x *DatabaseIsolation) ClearDatabaseInstance() {
	x.DatabaseInstance = nil
}

func (x *DatabaseIsolation) ClearSchemaName() {
	x.SchemaName = nil
}

func (x *DatabaseIsolation) ClearDedicatedDatabase() {
	x.DedicatedDatabase = nil
}

func (x *DatabaseIsolation) ClearBackup() {
	x.Backup = nil
}

func (x *DatabaseIsolation) ClearMaxConnections() {
	x.MaxConnections = nil
}

func (x *DatabaseIsolation) ClearQueryTimeoutSeconds() {
	x.QueryTimeoutSeconds = nil
}

type DatabaseIsolation_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Database instance identifier (for INFRASTRUCTURE isolation)
	DatabaseInstance *string
	// Schema or database name for this tenant
	SchemaName *string
	// Database connection parameters
	ConnectionParams []*types.KeyValue
	// Whether tenant has dedicated database
	DedicatedDatabase *bool
	// Database backup configuration
	Backup *BackupConfig
	// Database access restrictions
	AllowedOperations []string
	// Maximum connections allowed for this tenant
	MaxConnections *int32
	// Query timeout in seconds
	QueryTimeoutSeconds *int32
}

func (b0 DatabaseIsolation_builder) Build() *DatabaseIsolation {
	m0 := &DatabaseIsolation{}
	b, x := &b0, m0
	_, _ = b, x
	x.DatabaseInstance = b.DatabaseInstance
	x.SchemaName = b.SchemaName
	x.ConnectionParams = b.ConnectionParams
	x.DedicatedDatabase = b.DedicatedDatabase
	x.Backup = b.Backup
	x.AllowedOperations = b.AllowedOperations
	x.MaxConnections = b.MaxConnections
	x.QueryTimeoutSeconds = b.QueryTimeoutSeconds
	return m0
}

// *
// NetworkIsolation type defining network-level isolation for a tenant.
type NetworkIsolation struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Virtual private cloud (VPC) identifier
	VpcId *string `protobuf:"bytes,1,opt,name=vpc_id,json=vpcId" json:"vpc_id,omitempty"`
	// Subnet identifier for this tenant
	SubnetId *string `protobuf:"bytes,2,opt,name=subnet_id,json=subnetId" json:"subnet_id,omitempty"`
	// Security group identifiers
	SecurityGroupIds []string `protobuf:"bytes,3,rep,name=security_group_ids,json=securityGroupIds" json:"security_group_ids,omitempty"`
	// Network access control list (ACL) rules
	AclRules []*NetworkACLRule `protobuf:"bytes,4,rep,name=acl_rules,json=aclRules" json:"acl_rules,omitempty"`
	// Whether tenant has dedicated network
	DedicatedNetwork *bool `protobuf:"varint,5,opt,name=dedicated_network,json=dedicatedNetwork" json:"dedicated_network,omitempty"`
	// Load balancer configuration for this tenant
	LoadBalancer *LoadBalancerConfig `protobuf:"bytes,6,opt,name=load_balancer,json=loadBalancer" json:"load_balancer,omitempty"`
	// CDN configuration for this tenant
	Cdn *CDNConfig `protobuf:"bytes,7,opt,name=cdn" json:"cdn,omitempty"`
	// Custom domain configuration
	Domain        *DomainConfig `protobuf:"bytes,8,opt,name=domain" json:"domain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkIsolation) Reset() {
	*x = NetworkIsolation{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkIsolation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkIsolation) ProtoMessage() {}

func (x *NetworkIsolation) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *NetworkIsolation) GetVpcId() string {
	if x != nil && x.VpcId != nil {
		return *x.VpcId
	}
	return ""
}

func (x *NetworkIsolation) GetSubnetId() string {
	if x != nil && x.SubnetId != nil {
		return *x.SubnetId
	}
	return ""
}

func (x *NetworkIsolation) GetSecurityGroupIds() []string {
	if x != nil {
		return x.SecurityGroupIds
	}
	return nil
}

func (x *NetworkIsolation) GetAclRules() []*NetworkACLRule {
	if x != nil {
		return x.AclRules
	}
	return nil
}

func (x *NetworkIsolation) GetDedicatedNetwork() bool {
	if x != nil && x.DedicatedNetwork != nil {
		return *x.DedicatedNetwork
	}
	return false
}

func (x *NetworkIsolation) GetLoadBalancer() *LoadBalancerConfig {
	if x != nil {
		return x.LoadBalancer
	}
	return nil
}

func (x *NetworkIsolation) GetCdn() *CDNConfig {
	if x != nil {
		return x.Cdn
	}
	return nil
}

func (x *NetworkIsolation) GetDomain() *DomainConfig {
	if x != nil {
		return x.Domain
	}
	return nil
}

func (x *NetworkIsolation) SetVpcId(v string) {
	x.VpcId = &v
}

func (x *NetworkIsolation) SetSubnetId(v string) {
	x.SubnetId = &v
}

func (x *NetworkIsolation) SetSecurityGroupIds(v []string) {
	x.SecurityGroupIds = v
}

func (x *NetworkIsolation) SetAclRules(v []*NetworkACLRule) {
	x.AclRules = v
}

func (x *NetworkIsolation) SetDedicatedNetwork(v bool) {
	x.DedicatedNetwork = &v
}

func (x *NetworkIsolation) SetLoadBalancer(v *LoadBalancerConfig) {
	x.LoadBalancer = v
}

func (x *NetworkIsolation) SetCdn(v *CDNConfig) {
	x.Cdn = v
}

func (x *NetworkIsolation) SetDomain(v *DomainConfig) {
	x.Domain = v
}

func (x *NetworkIsolation) HasVpcId() bool {
	if x == nil {
		return false
	}
	return x.VpcId != nil
}

func (x *NetworkIsolation) HasSubnetId() bool {
	if x == nil {
		return false
	}
	return x.SubnetId != nil
}

func (x *NetworkIsolation) HasDedicatedNetwork() bool {
	if x == nil {
		return false
	}
	return x.DedicatedNetwork != nil
}

func (x *NetworkIsolation) HasLoadBalancer() bool {
	if x == nil {
		return false
	}
	return x.LoadBalancer != nil
}

func (x *NetworkIsolation) HasCdn() bool {
	if x == nil {
		return false
	}
	return x.Cdn != nil
}

func (x *NetworkIsolation) HasDomain() bool {
	if x == nil {
		return false
	}
	return x.Domain != nil
}

func (x *NetworkIsolation) ClearVpcId() {
	x.VpcId = nil
}

func (x *NetworkIsolation) ClearSubnetId() {
	x.SubnetId = nil
}

func (x *NetworkIsolation) ClearDedicatedNetwork() {
	x.DedicatedNetwork = nil
}

func (x *NetworkIsolation) ClearLoadBalancer() {
	x.LoadBalancer = nil
}

func (x *NetworkIsolation) ClearCdn() {
	x.Cdn = nil
}

func (x *NetworkIsolation) ClearDomain() {
	x.Domain = nil
}

type NetworkIsolation_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Virtual private cloud (VPC) identifier
	VpcId *string
	// Subnet identifier for this tenant
	SubnetId *string
	// Security group identifiers
	SecurityGroupIds []string
	// Network access control list (ACL) rules
	AclRules []*NetworkACLRule
	// Whether tenant has dedicated network
	DedicatedNetwork *bool
	// Load balancer configuration for this tenant
	LoadBalancer *LoadBalancerConfig
	// CDN configuration for this tenant
	Cdn *CDNConfig
	// Custom domain configuration
	Domain *DomainConfig
}

func (b0 NetworkIsolation_builder) Build() *NetworkIsolation {
	m0 := &NetworkIsolation{}
	b, x := &b0, m0
	_, _ = b, x
	x.VpcId = b.VpcId
	x.SubnetId = b.SubnetId
	x.SecurityGroupIds = b.SecurityGroupIds
	x.AclRules = b.AclRules
	x.DedicatedNetwork = b.DedicatedNetwork
	x.LoadBalancer = b.LoadBalancer
	x.Cdn = b.Cdn
	x.Domain = b.Domain
	return m0
}

// *
// StorageIsolation type defining storage-level isolation for a tenant.
type StorageIsolation struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Storage bucket or container identifier
	StorageBucket *string `protobuf:"bytes,1,opt,name=storage_bucket,json=storageBucket" json:"storage_bucket,omitempty"`
	// Storage path prefix for this tenant
	PathPrefix *string `protobuf:"bytes,2,opt,name=path_prefix,json=pathPrefix" json:"path_prefix,omitempty"`
	// Whether tenant has dedicated storage
	DedicatedStorage *bool `protobuf:"varint,3,opt,name=dedicated_storage,json=dedicatedStorage" json:"dedicated_storage,omitempty"`
	// Storage encryption configuration
	Encryption *StorageEncryption `protobuf:"bytes,4,opt,name=encryption" json:"encryption,omitempty"`
	// Storage access policies
	Policies []*StoragePolicy `protobuf:"bytes,5,rep,name=policies" json:"policies,omitempty"`
	// Backup and replication configuration
	Backup *StorageBackupConfig `protobuf:"bytes,6,opt,name=backup" json:"backup,omitempty"`
	// Storage quota limits
	Quota         *StorageQuota `protobuf:"bytes,7,opt,name=quota" json:"quota,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageIsolation) Reset() {
	*x = StorageIsolation{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageIsolation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageIsolation) ProtoMessage() {}

func (x *StorageIsolation) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StorageIsolation) GetStorageBucket() string {
	if x != nil && x.StorageBucket != nil {
		return *x.StorageBucket
	}
	return ""
}

func (x *StorageIsolation) GetPathPrefix() string {
	if x != nil && x.PathPrefix != nil {
		return *x.PathPrefix
	}
	return ""
}

func (x *StorageIsolation) GetDedicatedStorage() bool {
	if x != nil && x.DedicatedStorage != nil {
		return *x.DedicatedStorage
	}
	return false
}

func (x *StorageIsolation) GetEncryption() *StorageEncryption {
	if x != nil {
		return x.Encryption
	}
	return nil
}

func (x *StorageIsolation) GetPolicies() []*StoragePolicy {
	if x != nil {
		return x.Policies
	}
	return nil
}

func (x *StorageIsolation) GetBackup() *StorageBackupConfig {
	if x != nil {
		return x.Backup
	}
	return nil
}

func (x *StorageIsolation) GetQuota() *StorageQuota {
	if x != nil {
		return x.Quota
	}
	return nil
}

func (x *StorageIsolation) SetStorageBucket(v string) {
	x.StorageBucket = &v
}

func (x *StorageIsolation) SetPathPrefix(v string) {
	x.PathPrefix = &v
}

func (x *StorageIsolation) SetDedicatedStorage(v bool) {
	x.DedicatedStorage = &v
}

func (x *StorageIsolation) SetEncryption(v *StorageEncryption) {
	x.Encryption = v
}

func (x *StorageIsolation) SetPolicies(v []*StoragePolicy) {
	x.Policies = v
}

func (x *StorageIsolation) SetBackup(v *StorageBackupConfig) {
	x.Backup = v
}

func (x *StorageIsolation) SetQuota(v *StorageQuota) {
	x.Quota = v
}

func (x *StorageIsolation) HasStorageBucket() bool {
	if x == nil {
		return false
	}
	return x.StorageBucket != nil
}

func (x *StorageIsolation) HasPathPrefix() bool {
	if x == nil {
		return false
	}
	return x.PathPrefix != nil
}

func (x *StorageIsolation) HasDedicatedStorage() bool {
	if x == nil {
		return false
	}
	return x.DedicatedStorage != nil
}

func (x *StorageIsolation) HasEncryption() bool {
	if x == nil {
		return false
	}
	return x.Encryption != nil
}

func (x *StorageIsolation) HasBackup() bool {
	if x == nil {
		return false
	}
	return x.Backup != nil
}

func (x *StorageIsolation) HasQuota() bool {
	if x == nil {
		return false
	}
	return x.Quota != nil
}

func (x *StorageIsolation) ClearStorageBucket() {
	x.StorageBucket = nil
}

func (x *StorageIsolation) ClearPathPrefix() {
	x.PathPrefix = nil
}

func (x *StorageIsolation) ClearDedicatedStorage() {
	x.DedicatedStorage = nil
}

func (x *StorageIsolation) ClearEncryption() {
	x.Encryption = nil
}

func (x *StorageIsolation) ClearBackup() {
	x.Backup = nil
}

func (x *StorageIsolation) ClearQuota() {
	x.Quota = nil
}

type StorageIsolation_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Storage bucket or container identifier
	StorageBucket *string
	// Storage path prefix for this tenant
	PathPrefix *string
	// Whether tenant has dedicated storage
	DedicatedStorage *bool
	// Storage encryption configuration
	Encryption *StorageEncryption
	// Storage access policies
	Policies []*StoragePolicy
	// Backup and replication configuration
	Backup *StorageBackupConfig
	// Storage quota limits
	Quota *StorageQuota
}

func (b0 StorageIsolation_builder) Build() *StorageIsolation {
	m0 := &StorageIsolation{}
	b, x := &b0, m0
	_, _ = b, x
	x.StorageBucket = b.StorageBucket
	x.PathPrefix = b.PathPrefix
	x.DedicatedStorage = b.DedicatedStorage
	x.Encryption = b.Encryption
	x.Policies = b.Policies
	x.Backup = b.Backup
	x.Quota = b.Quota
	return m0
}

// *
// ComputeIsolation type defining compute-level isolation for a tenant.
type ComputeIsolation struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Dedicated compute instance identifier
	ComputeInstance *string `protobuf:"bytes,1,opt,name=compute_instance,json=computeInstance" json:"compute_instance,omitempty"`
	// Container or namespace identifier
	Namespace *string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// CPU allocation for this tenant
	Cpu *CPUAllocation `protobuf:"bytes,3,opt,name=cpu" json:"cpu,omitempty"`
	// Memory allocation for this tenant
	Memory *MemoryAllocation `protobuf:"bytes,4,opt,name=memory" json:"memory,omitempty"`
	// Whether tenant has dedicated compute resources
	DedicatedCompute *bool `protobuf:"varint,5,opt,name=dedicated_compute,json=dedicatedCompute" json:"dedicated_compute,omitempty"`
	// Resource limits and quotas
	Limits *ResourceLimits `protobuf:"bytes,6,opt,name=limits" json:"limits,omitempty"`
	// Auto-scaling configuration
	AutoScaling   *AutoScalingConfig `protobuf:"bytes,7,opt,name=auto_scaling,json=autoScaling" json:"auto_scaling,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComputeIsolation) Reset() {
	*x = ComputeIsolation{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComputeIsolation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComputeIsolation) ProtoMessage() {}

func (x *ComputeIsolation) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ComputeIsolation) GetComputeInstance() string {
	if x != nil && x.ComputeInstance != nil {
		return *x.ComputeInstance
	}
	return ""
}

func (x *ComputeIsolation) GetNamespace() string {
	if x != nil && x.Namespace != nil {
		return *x.Namespace
	}
	return ""
}

func (x *ComputeIsolation) GetCpu() *CPUAllocation {
	if x != nil {
		return x.Cpu
	}
	return nil
}

func (x *ComputeIsolation) GetMemory() *MemoryAllocation {
	if x != nil {
		return x.Memory
	}
	return nil
}

func (x *ComputeIsolation) GetDedicatedCompute() bool {
	if x != nil && x.DedicatedCompute != nil {
		return *x.DedicatedCompute
	}
	return false
}

func (x *ComputeIsolation) GetLimits() *ResourceLimits {
	if x != nil {
		return x.Limits
	}
	return nil
}

func (x *ComputeIsolation) GetAutoScaling() *AutoScalingConfig {
	if x != nil {
		return x.AutoScaling
	}
	return nil
}

func (x *ComputeIsolation) SetComputeInstance(v string) {
	x.ComputeInstance = &v
}

func (x *ComputeIsolation) SetNamespace(v string) {
	x.Namespace = &v
}

func (x *ComputeIsolation) SetCpu(v *CPUAllocation) {
	x.Cpu = v
}

func (x *ComputeIsolation) SetMemory(v *MemoryAllocation) {
	x.Memory = v
}

func (x *ComputeIsolation) SetDedicatedCompute(v bool) {
	x.DedicatedCompute = &v
}

func (x *ComputeIsolation) SetLimits(v *ResourceLimits) {
	x.Limits = v
}

func (x *ComputeIsolation) SetAutoScaling(v *AutoScalingConfig) {
	x.AutoScaling = v
}

func (x *ComputeIsolation) HasComputeInstance() bool {
	if x == nil {
		return false
	}
	return x.ComputeInstance != nil
}

func (x *ComputeIsolation) HasNamespace() bool {
	if x == nil {
		return false
	}
	return x.Namespace != nil
}

func (x *ComputeIsolation) HasCpu() bool {
	if x == nil {
		return false
	}
	return x.Cpu != nil
}

func (x *ComputeIsolation) HasMemory() bool {
	if x == nil {
		return false
	}
	return x.Memory != nil
}

func (x *ComputeIsolation) HasDedicatedCompute() bool {
	if x == nil {
		return false
	}
	return x.DedicatedCompute != nil
}

func (x *ComputeIsolation) HasLimits() bool {
	if x == nil {
		return false
	}
	return x.Limits != nil
}

func (x *ComputeIsolation) HasAutoScaling() bool {
	if x == nil {
		return false
	}
	return x.AutoScaling != nil
}

func (x *ComputeIsolation) ClearComputeInstance() {
	x.ComputeInstance = nil
}

func (x *ComputeIsolation) ClearNamespace() {
	x.Namespace = nil
}

func (x *ComputeIsolation) ClearCpu() {
	x.Cpu = nil
}

func (x *ComputeIsolation) ClearMemory() {
	x.Memory = nil
}

func (x *ComputeIsolation) ClearDedicatedCompute() {
	x.DedicatedCompute = nil
}

func (x *ComputeIsolation) ClearLimits() {
	x.Limits = nil
}

func (x *ComputeIsolation) ClearAutoScaling() {
	x.AutoScaling = nil
}

type ComputeIsolation_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Dedicated compute instance identifier
	ComputeInstance *string
	// Container or namespace identifier
	Namespace *string
	// CPU allocation for this tenant
	Cpu *CPUAllocation
	// Memory allocation for this tenant
	Memory *MemoryAllocation
	// Whether tenant has dedicated compute resources
	DedicatedCompute *bool
	// Resource limits and quotas
	Limits *ResourceLimits
	// Auto-scaling configuration
	AutoScaling *AutoScalingConfig
}

func (b0 ComputeIsolation_builder) Build() *ComputeIsolation {
	m0 := &ComputeIsolation{}
	b, x := &b0, m0
	_, _ = b, x
	x.ComputeInstance = b.ComputeInstance
	x.Namespace = b.Namespace
	x.Cpu = b.Cpu
	x.Memory = b.Memory
	x.DedicatedCompute = b.DedicatedCompute
	x.Limits = b.Limits
	x.AutoScaling = b.AutoScaling
	return m0
}

// *
// Supporting message types for isolation configuration.
type EncryptionConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Whether encryption at rest is enabled
	EncryptionAtRest *bool `protobuf:"varint,1,opt,name=encryption_at_rest,json=encryptionAtRest" json:"encryption_at_rest,omitempty"`
	// Whether encryption in transit is enabled
	EncryptionInTransit *bool `protobuf:"varint,2,opt,name=encryption_in_transit,json=encryptionInTransit" json:"encryption_in_transit,omitempty"`
	// Encryption key management service
	KeyManagementService *string `protobuf:"bytes,3,opt,name=key_management_service,json=keyManagementService" json:"key_management_service,omitempty"`
	// Customer-managed encryption key ID
	CustomerKeyId *string `protobuf:"bytes,4,opt,name=customer_key_id,json=customerKeyId" json:"customer_key_id,omitempty"`
	// Encryption algorithm used
	EncryptionAlgorithm *string `protobuf:"bytes,5,opt,name=encryption_algorithm,json=encryptionAlgorithm" json:"encryption_algorithm,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *EncryptionConfig) Reset() {
	*x = EncryptionConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptionConfig) ProtoMessage() {}

func (x *EncryptionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *EncryptionConfig) GetEncryptionAtRest() bool {
	if x != nil && x.EncryptionAtRest != nil {
		return *x.EncryptionAtRest
	}
	return false
}

func (x *EncryptionConfig) GetEncryptionInTransit() bool {
	if x != nil && x.EncryptionInTransit != nil {
		return *x.EncryptionInTransit
	}
	return false
}

func (x *EncryptionConfig) GetKeyManagementService() string {
	if x != nil && x.KeyManagementService != nil {
		return *x.KeyManagementService
	}
	return ""
}

func (x *EncryptionConfig) GetCustomerKeyId() string {
	if x != nil && x.CustomerKeyId != nil {
		return *x.CustomerKeyId
	}
	return ""
}

func (x *EncryptionConfig) GetEncryptionAlgorithm() string {
	if x != nil && x.EncryptionAlgorithm != nil {
		return *x.EncryptionAlgorithm
	}
	return ""
}

func (x *EncryptionConfig) SetEncryptionAtRest(v bool) {
	x.EncryptionAtRest = &v
}

func (x *EncryptionConfig) SetEncryptionInTransit(v bool) {
	x.EncryptionInTransit = &v
}

func (x *EncryptionConfig) SetKeyManagementService(v string) {
	x.KeyManagementService = &v
}

func (x *EncryptionConfig) SetCustomerKeyId(v string) {
	x.CustomerKeyId = &v
}

func (x *EncryptionConfig) SetEncryptionAlgorithm(v string) {
	x.EncryptionAlgorithm = &v
}

func (x *EncryptionConfig) HasEncryptionAtRest() bool {
	if x == nil {
		return false
	}
	return x.EncryptionAtRest != nil
}

func (x *EncryptionConfig) HasEncryptionInTransit() bool {
	if x == nil {
		return false
	}
	return x.EncryptionInTransit != nil
}

func (x *EncryptionConfig) HasKeyManagementService() bool {
	if x == nil {
		return false
	}
	return x.KeyManagementService != nil
}

func (x *EncryptionConfig) HasCustomerKeyId() bool {
	if x == nil {
		return false
	}
	return x.CustomerKeyId != nil
}

func (x *EncryptionConfig) HasEncryptionAlgorithm() bool {
	if x == nil {
		return false
	}
	return x.EncryptionAlgorithm != nil
}

func (x *EncryptionConfig) ClearEncryptionAtRest() {
	x.EncryptionAtRest = nil
}

func (x *EncryptionConfig) ClearEncryptionInTransit() {
	x.EncryptionInTransit = nil
}

func (x *EncryptionConfig) ClearKeyManagementService() {
	x.KeyManagementService = nil
}

func (x *EncryptionConfig) ClearCustomerKeyId() {
	x.CustomerKeyId = nil
}

func (x *EncryptionConfig) ClearEncryptionAlgorithm() {
	x.EncryptionAlgorithm = nil
}

type EncryptionConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Whether encryption at rest is enabled
	EncryptionAtRest *bool
	// Whether encryption in transit is enabled
	EncryptionInTransit *bool
	// Encryption key management service
	KeyManagementService *string
	// Customer-managed encryption key ID
	CustomerKeyId *string
	// Encryption algorithm used
	EncryptionAlgorithm *string
}

func (b0 EncryptionConfig_builder) Build() *EncryptionConfig {
	m0 := &EncryptionConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.EncryptionAtRest = b.EncryptionAtRest
	x.EncryptionInTransit = b.EncryptionInTransit
	x.KeyManagementService = b.KeyManagementService
	x.CustomerKeyId = b.CustomerKeyId
	x.EncryptionAlgorithm = b.EncryptionAlgorithm
	return m0
}

type AccessControl struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// IP address whitelist for tenant access
	IpWhitelist []string `protobuf:"bytes,1,rep,name=ip_whitelist,json=ipWhitelist" json:"ip_whitelist,omitempty"`
	// Allowed authentication methods
	AuthMethods []string `protobuf:"bytes,2,rep,name=auth_methods,json=authMethods" json:"auth_methods,omitempty"`
	// Session timeout in minutes
	SessionTimeout *int32 `protobuf:"varint,3,opt,name=session_timeout,json=sessionTimeout" json:"session_timeout,omitempty"`
	// Maximum concurrent sessions
	MaxConcurrentSessions *int32 `protobuf:"varint,4,opt,name=max_concurrent_sessions,json=maxConcurrentSessions" json:"max_concurrent_sessions,omitempty"`
	// Geographic access restrictions
	AllowedCountries []string `protobuf:"bytes,5,rep,name=allowed_countries,json=allowedCountries" json:"allowed_countries,omitempty"`
	// Time-based access restrictions
	TimeRestrictions []*TimeRestriction `protobuf:"bytes,6,rep,name=time_restrictions,json=timeRestrictions" json:"time_restrictions,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *AccessControl) Reset() {
	*x = AccessControl{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccessControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessControl) ProtoMessage() {}

func (x *AccessControl) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AccessControl) GetIpWhitelist() []string {
	if x != nil {
		return x.IpWhitelist
	}
	return nil
}

func (x *AccessControl) GetAuthMethods() []string {
	if x != nil {
		return x.AuthMethods
	}
	return nil
}

func (x *AccessControl) GetSessionTimeout() int32 {
	if x != nil && x.SessionTimeout != nil {
		return *x.SessionTimeout
	}
	return 0
}

func (x *AccessControl) GetMaxConcurrentSessions() int32 {
	if x != nil && x.MaxConcurrentSessions != nil {
		return *x.MaxConcurrentSessions
	}
	return 0
}

func (x *AccessControl) GetAllowedCountries() []string {
	if x != nil {
		return x.AllowedCountries
	}
	return nil
}

func (x *AccessControl) GetTimeRestrictions() []*TimeRestriction {
	if x != nil {
		return x.TimeRestrictions
	}
	return nil
}

func (x *AccessControl) SetIpWhitelist(v []string) {
	x.IpWhitelist = v
}

func (x *AccessControl) SetAuthMethods(v []string) {
	x.AuthMethods = v
}

func (x *AccessControl) SetSessionTimeout(v int32) {
	x.SessionTimeout = &v
}

func (x *AccessControl) SetMaxConcurrentSessions(v int32) {
	x.MaxConcurrentSessions = &v
}

func (x *AccessControl) SetAllowedCountries(v []string) {
	x.AllowedCountries = v
}

func (x *AccessControl) SetTimeRestrictions(v []*TimeRestriction) {
	x.TimeRestrictions = v
}

func (x *AccessControl) HasSessionTimeout() bool {
	if x == nil {
		return false
	}
	return x.SessionTimeout != nil
}

func (x *AccessControl) HasMaxConcurrentSessions() bool {
	if x == nil {
		return false
	}
	return x.MaxConcurrentSessions != nil
}

func (x *AccessControl) ClearSessionTimeout() {
	x.SessionTimeout = nil
}

func (x *AccessControl) ClearMaxConcurrentSessions() {
	x.MaxConcurrentSessions = nil
}

type AccessControl_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// IP address whitelist for tenant access
	IpWhitelist []string
	// Allowed authentication methods
	AuthMethods []string
	// Session timeout in minutes
	SessionTimeout *int32
	// Maximum concurrent sessions
	MaxConcurrentSessions *int32
	// Geographic access restrictions
	AllowedCountries []string
	// Time-based access restrictions
	TimeRestrictions []*TimeRestriction
}

func (b0 AccessControl_builder) Build() *AccessControl {
	m0 := &AccessControl{}
	b, x := &b0, m0
	_, _ = b, x
	x.IpWhitelist = b.IpWhitelist
	x.AuthMethods = b.AuthMethods
	x.SessionTimeout = b.SessionTimeout
	x.MaxConcurrentSessions = b.MaxConcurrentSessions
	x.AllowedCountries = b.AllowedCountries
	x.TimeRestrictions = b.TimeRestrictions
	return m0
}

type AuditConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Whether audit logging is enabled
	AuditEnabled *bool `protobuf:"varint,1,opt,name=audit_enabled,json=auditEnabled" json:"audit_enabled,omitempty"`
	// Audit log retention period in days
	RetentionDays *int32 `protobuf:"varint,2,opt,name=retention_days,json=retentionDays" json:"retention_days,omitempty"`
	// Audit log storage location
	StorageLocation *string `protobuf:"bytes,3,opt,name=storage_location,json=storageLocation" json:"storage_location,omitempty"`
	// Events to audit
	AuditedEvents []string `protobuf:"bytes,4,rep,name=audited_events,json=auditedEvents" json:"audited_events,omitempty"`
	// Whether real-time monitoring is enabled
	RealTimeMonitoring *bool `protobuf:"varint,5,opt,name=real_time_monitoring,json=realTimeMonitoring" json:"real_time_monitoring,omitempty"`
	// Alert configuration for audit events
	Alerts        []*AuditAlert `protobuf:"bytes,6,rep,name=alerts" json:"alerts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuditConfig) Reset() {
	*x = AuditConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuditConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuditConfig) ProtoMessage() {}

func (x *AuditConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AuditConfig) GetAuditEnabled() bool {
	if x != nil && x.AuditEnabled != nil {
		return *x.AuditEnabled
	}
	return false
}

func (x *AuditConfig) GetRetentionDays() int32 {
	if x != nil && x.RetentionDays != nil {
		return *x.RetentionDays
	}
	return 0
}

func (x *AuditConfig) GetStorageLocation() string {
	if x != nil && x.StorageLocation != nil {
		return *x.StorageLocation
	}
	return ""
}

func (x *AuditConfig) GetAuditedEvents() []string {
	if x != nil {
		return x.AuditedEvents
	}
	return nil
}

func (x *AuditConfig) GetRealTimeMonitoring() bool {
	if x != nil && x.RealTimeMonitoring != nil {
		return *x.RealTimeMonitoring
	}
	return false
}

func (x *AuditConfig) GetAlerts() []*AuditAlert {
	if x != nil {
		return x.Alerts
	}
	return nil
}

func (x *AuditConfig) SetAuditEnabled(v bool) {
	x.AuditEnabled = &v
}

func (x *AuditConfig) SetRetentionDays(v int32) {
	x.RetentionDays = &v
}

func (x *AuditConfig) SetStorageLocation(v string) {
	x.StorageLocation = &v
}

func (x *AuditConfig) SetAuditedEvents(v []string) {
	x.AuditedEvents = v
}

func (x *AuditConfig) SetRealTimeMonitoring(v bool) {
	x.RealTimeMonitoring = &v
}

func (x *AuditConfig) SetAlerts(v []*AuditAlert) {
	x.Alerts = v
}

func (x *AuditConfig) HasAuditEnabled() bool {
	if x == nil {
		return false
	}
	return x.AuditEnabled != nil
}

func (x *AuditConfig) HasRetentionDays() bool {
	if x == nil {
		return false
	}
	return x.RetentionDays != nil
}

func (x *AuditConfig) HasStorageLocation() bool {
	if x == nil {
		return false
	}
	return x.StorageLocation != nil
}

func (x *AuditConfig) HasRealTimeMonitoring() bool {
	if x == nil {
		return false
	}
	return x.RealTimeMonitoring != nil
}

func (x *AuditConfig) ClearAuditEnabled() {
	x.AuditEnabled = nil
}

func (x *AuditConfig) ClearRetentionDays() {
	x.RetentionDays = nil
}

func (x *AuditConfig) ClearStorageLocation() {
	x.StorageLocation = nil
}

func (x *AuditConfig) ClearRealTimeMonitoring() {
	x.RealTimeMonitoring = nil
}

type AuditConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Whether audit logging is enabled
	AuditEnabled *bool
	// Audit log retention period in days
	RetentionDays *int32
	// Audit log storage location
	StorageLocation *string
	// Events to audit
	AuditedEvents []string
	// Whether real-time monitoring is enabled
	RealTimeMonitoring *bool
	// Alert configuration for audit events
	Alerts []*AuditAlert
}

func (b0 AuditConfig_builder) Build() *AuditConfig {
	m0 := &AuditConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.AuditEnabled = b.AuditEnabled
	x.RetentionDays = b.RetentionDays
	x.StorageLocation = b.StorageLocation
	x.AuditedEvents = b.AuditedEvents
	x.RealTimeMonitoring = b.RealTimeMonitoring
	x.Alerts = b.Alerts
	return m0
}

type BackupConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Whether automated backups are enabled
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Backup frequency (hourly, daily, weekly)
	Frequency *string `protobuf:"bytes,2,opt,name=frequency" json:"frequency,omitempty"`
	// Backup retention period in days
	RetentionDays *int32 `protobuf:"varint,3,opt,name=retention_days,json=retentionDays" json:"retention_days,omitempty"`
	// Backup storage location
	StorageLocation *string `protobuf:"bytes,4,opt,name=storage_location,json=storageLocation" json:"storage_location,omitempty"`
	// Whether point-in-time recovery is enabled
	PointInTimeRecovery *bool `protobuf:"varint,5,opt,name=point_in_time_recovery,json=pointInTimeRecovery" json:"point_in_time_recovery,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *BackupConfig) Reset() {
	*x = BackupConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackupConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupConfig) ProtoMessage() {}

func (x *BackupConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *BackupConfig) GetEnabled() bool {
	if x != nil && x.Enabled != nil {
		return *x.Enabled
	}
	return false
}

func (x *BackupConfig) GetFrequency() string {
	if x != nil && x.Frequency != nil {
		return *x.Frequency
	}
	return ""
}

func (x *BackupConfig) GetRetentionDays() int32 {
	if x != nil && x.RetentionDays != nil {
		return *x.RetentionDays
	}
	return 0
}

func (x *BackupConfig) GetStorageLocation() string {
	if x != nil && x.StorageLocation != nil {
		return *x.StorageLocation
	}
	return ""
}

func (x *BackupConfig) GetPointInTimeRecovery() bool {
	if x != nil && x.PointInTimeRecovery != nil {
		return *x.PointInTimeRecovery
	}
	return false
}

func (x *BackupConfig) SetEnabled(v bool) {
	x.Enabled = &v
}

func (x *BackupConfig) SetFrequency(v string) {
	x.Frequency = &v
}

func (x *BackupConfig) SetRetentionDays(v int32) {
	x.RetentionDays = &v
}

func (x *BackupConfig) SetStorageLocation(v string) {
	x.StorageLocation = &v
}

func (x *BackupConfig) SetPointInTimeRecovery(v bool) {
	x.PointInTimeRecovery = &v
}

func (x *BackupConfig) HasEnabled() bool {
	if x == nil {
		return false
	}
	return x.Enabled != nil
}

func (x *BackupConfig) HasFrequency() bool {
	if x == nil {
		return false
	}
	return x.Frequency != nil
}

func (x *BackupConfig) HasRetentionDays() bool {
	if x == nil {
		return false
	}
	return x.RetentionDays != nil
}

func (x *BackupConfig) HasStorageLocation() bool {
	if x == nil {
		return false
	}
	return x.StorageLocation != nil
}

func (x *BackupConfig) HasPointInTimeRecovery() bool {
	if x == nil {
		return false
	}
	return x.PointInTimeRecovery != nil
}

func (x *BackupConfig) ClearEnabled() {
	x.Enabled = nil
}

func (x *BackupConfig) ClearFrequency() {
	x.Frequency = nil
}

func (x *BackupConfig) ClearRetentionDays() {
	x.RetentionDays = nil
}

func (x *BackupConfig) ClearStorageLocation() {
	x.StorageLocation = nil
}

func (x *BackupConfig) ClearPointInTimeRecovery() {
	x.PointInTimeRecovery = nil
}

type BackupConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Whether automated backups are enabled
	Enabled *bool
	// Backup frequency (hourly, daily, weekly)
	Frequency *string
	// Backup retention period in days
	RetentionDays *int32
	// Backup storage location
	StorageLocation *string
	// Whether point-in-time recovery is enabled
	PointInTimeRecovery *bool
}

func (b0 BackupConfig_builder) Build() *BackupConfig {
	m0 := &BackupConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.Enabled = b.Enabled
	x.Frequency = b.Frequency
	x.RetentionDays = b.RetentionDays
	x.StorageLocation = b.StorageLocation
	x.PointInTimeRecovery = b.PointInTimeRecovery
	return m0
}

type NetworkACLRule struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Rule action (allow, deny)
	Action *string `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	// Source IP or CIDR block
	Source *string `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	// Destination IP or CIDR block
	Destination *string `protobuf:"bytes,3,opt,name=destination" json:"destination,omitempty"`
	// Protocol (TCP, UDP, ICMP)
	Protocol *string `protobuf:"bytes,4,opt,name=protocol" json:"protocol,omitempty"`
	// Port range
	PortRange *string `protobuf:"bytes,5,opt,name=port_range,json=portRange" json:"port_range,omitempty"`
	// Rule priority
	Priority      *int32 `protobuf:"varint,6,opt,name=priority" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkACLRule) Reset() {
	*x = NetworkACLRule{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkACLRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkACLRule) ProtoMessage() {}

func (x *NetworkACLRule) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *NetworkACLRule) GetAction() string {
	if x != nil && x.Action != nil {
		return *x.Action
	}
	return ""
}

func (x *NetworkACLRule) GetSource() string {
	if x != nil && x.Source != nil {
		return *x.Source
	}
	return ""
}

func (x *NetworkACLRule) GetDestination() string {
	if x != nil && x.Destination != nil {
		return *x.Destination
	}
	return ""
}

func (x *NetworkACLRule) GetProtocol() string {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return ""
}

func (x *NetworkACLRule) GetPortRange() string {
	if x != nil && x.PortRange != nil {
		return *x.PortRange
	}
	return ""
}

func (x *NetworkACLRule) GetPriority() int32 {
	if x != nil && x.Priority != nil {
		return *x.Priority
	}
	return 0
}

func (x *NetworkACLRule) SetAction(v string) {
	x.Action = &v
}

func (x *NetworkACLRule) SetSource(v string) {
	x.Source = &v
}

func (x *NetworkACLRule) SetDestination(v string) {
	x.Destination = &v
}

func (x *NetworkACLRule) SetProtocol(v string) {
	x.Protocol = &v
}

func (x *NetworkACLRule) SetPortRange(v string) {
	x.PortRange = &v
}

func (x *NetworkACLRule) SetPriority(v int32) {
	x.Priority = &v
}

func (x *NetworkACLRule) HasAction() bool {
	if x == nil {
		return false
	}
	return x.Action != nil
}

func (x *NetworkACLRule) HasSource() bool {
	if x == nil {
		return false
	}
	return x.Source != nil
}

func (x *NetworkACLRule) HasDestination() bool {
	if x == nil {
		return false
	}
	return x.Destination != nil
}

func (x *NetworkACLRule) HasProtocol() bool {
	if x == nil {
		return false
	}
	return x.Protocol != nil
}

func (x *NetworkACLRule) HasPortRange() bool {
	if x == nil {
		return false
	}
	return x.PortRange != nil
}

func (x *NetworkACLRule) HasPriority() bool {
	if x == nil {
		return false
	}
	return x.Priority != nil
}

func (x *NetworkACLRule) ClearAction() {
	x.Action = nil
}

func (x *NetworkACLRule) ClearSource() {
	x.Source = nil
}

func (x *NetworkACLRule) ClearDestination() {
	x.Destination = nil
}

func (x *NetworkACLRule) ClearProtocol() {
	x.Protocol = nil
}

func (x *NetworkACLRule) ClearPortRange() {
	x.PortRange = nil
}

func (x *NetworkACLRule) ClearPriority() {
	x.Priority = nil
}

type NetworkACLRule_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Rule action (allow, deny)
	Action *string
	// Source IP or CIDR block
	Source *string
	// Destination IP or CIDR block
	Destination *string
	// Protocol (TCP, UDP, ICMP)
	Protocol *string
	// Port range
	PortRange *string
	// Rule priority
	Priority *int32
}

func (b0 NetworkACLRule_builder) Build() *NetworkACLRule {
	m0 := &NetworkACLRule{}
	b, x := &b0, m0
	_, _ = b, x
	x.Action = b.Action
	x.Source = b.Source
	x.Destination = b.Destination
	x.Protocol = b.Protocol
	x.PortRange = b.PortRange
	x.Priority = b.Priority
	return m0
}

type LoadBalancerConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Load balancer type (application, network)
	Type *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Load balancing algorithm
	Algorithm *string `protobuf:"bytes,2,opt,name=algorithm" json:"algorithm,omitempty"`
	// Health check configuration
	HealthCheck *HealthCheckConfig `protobuf:"bytes,3,opt,name=health_check,json=healthCheck" json:"health_check,omitempty"`
	// SSL/TLS configuration
	Ssl           *SSLConfig `protobuf:"bytes,4,opt,name=ssl" json:"ssl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LoadBalancerConfig) Reset() {
	*x = LoadBalancerConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoadBalancerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadBalancerConfig) ProtoMessage() {}

func (x *LoadBalancerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *LoadBalancerConfig) GetType() string {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return ""
}

func (x *LoadBalancerConfig) GetAlgorithm() string {
	if x != nil && x.Algorithm != nil {
		return *x.Algorithm
	}
	return ""
}

func (x *LoadBalancerConfig) GetHealthCheck() *HealthCheckConfig {
	if x != nil {
		return x.HealthCheck
	}
	return nil
}

func (x *LoadBalancerConfig) GetSsl() *SSLConfig {
	if x != nil {
		return x.Ssl
	}
	return nil
}

func (x *LoadBalancerConfig) SetType(v string) {
	x.Type = &v
}

func (x *LoadBalancerConfig) SetAlgorithm(v string) {
	x.Algorithm = &v
}

func (x *LoadBalancerConfig) SetHealthCheck(v *HealthCheckConfig) {
	x.HealthCheck = v
}

func (x *LoadBalancerConfig) SetSsl(v *SSLConfig) {
	x.Ssl = v
}

func (x *LoadBalancerConfig) HasType() bool {
	if x == nil {
		return false
	}
	return x.Type != nil
}

func (x *LoadBalancerConfig) HasAlgorithm() bool {
	if x == nil {
		return false
	}
	return x.Algorithm != nil
}

func (x *LoadBalancerConfig) HasHealthCheck() bool {
	if x == nil {
		return false
	}
	return x.HealthCheck != nil
}

func (x *LoadBalancerConfig) HasSsl() bool {
	if x == nil {
		return false
	}
	return x.Ssl != nil
}

func (x *LoadBalancerConfig) ClearType() {
	x.Type = nil
}

func (x *LoadBalancerConfig) ClearAlgorithm() {
	x.Algorithm = nil
}

func (x *LoadBalancerConfig) ClearHealthCheck() {
	x.HealthCheck = nil
}

func (x *LoadBalancerConfig) ClearSsl() {
	x.Ssl = nil
}

type LoadBalancerConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Load balancer type (application, network)
	Type *string
	// Load balancing algorithm
	Algorithm *string
	// Health check configuration
	HealthCheck *HealthCheckConfig
	// SSL/TLS configuration
	Ssl *SSLConfig
}

func (b0 LoadBalancerConfig_builder) Build() *LoadBalancerConfig {
	m0 := &LoadBalancerConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.Type = b.Type
	x.Algorithm = b.Algorithm
	x.HealthCheck = b.HealthCheck
	x.Ssl = b.Ssl
	return m0
}

type CDNConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// CDN provider
	Provider *string `protobuf:"bytes,1,opt,name=provider" json:"provider,omitempty"`
	// CDN distribution ID
	DistributionId *string `protobuf:"bytes,2,opt,name=distribution_id,json=distributionId" json:"distribution_id,omitempty"`
	// Cache behavior settings
	CacheBehaviors []*CacheBehavior `protobuf:"bytes,3,rep,name=cache_behaviors,json=cacheBehaviors" json:"cache_behaviors,omitempty"`
	// Origin configuration
	Origin        *OriginConfig `protobuf:"bytes,4,opt,name=origin" json:"origin,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CDNConfig) Reset() {
	*x = CDNConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CDNConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CDNConfig) ProtoMessage() {}

func (x *CDNConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CDNConfig) GetProvider() string {
	if x != nil && x.Provider != nil {
		return *x.Provider
	}
	return ""
}

func (x *CDNConfig) GetDistributionId() string {
	if x != nil && x.DistributionId != nil {
		return *x.DistributionId
	}
	return ""
}

func (x *CDNConfig) GetCacheBehaviors() []*CacheBehavior {
	if x != nil {
		return x.CacheBehaviors
	}
	return nil
}

func (x *CDNConfig) GetOrigin() *OriginConfig {
	if x != nil {
		return x.Origin
	}
	return nil
}

func (x *CDNConfig) SetProvider(v string) {
	x.Provider = &v
}

func (x *CDNConfig) SetDistributionId(v string) {
	x.DistributionId = &v
}

func (x *CDNConfig) SetCacheBehaviors(v []*CacheBehavior) {
	x.CacheBehaviors = v
}

func (x *CDNConfig) SetOrigin(v *OriginConfig) {
	x.Origin = v
}

func (x *CDNConfig) HasProvider() bool {
	if x == nil {
		return false
	}
	return x.Provider != nil
}

func (x *CDNConfig) HasDistributionId() bool {
	if x == nil {
		return false
	}
	return x.DistributionId != nil
}

func (x *CDNConfig) HasOrigin() bool {
	if x == nil {
		return false
	}
	return x.Origin != nil
}

func (x *CDNConfig) ClearProvider() {
	x.Provider = nil
}

func (x *CDNConfig) ClearDistributionId() {
	x.DistributionId = nil
}

func (x *CDNConfig) ClearOrigin() {
	x.Origin = nil
}

type CDNConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// CDN provider
	Provider *string
	// CDN distribution ID
	DistributionId *string
	// Cache behavior settings
	CacheBehaviors []*CacheBehavior
	// Origin configuration
	Origin *OriginConfig
}

func (b0 CDNConfig_builder) Build() *CDNConfig {
	m0 := &CDNConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.Provider = b.Provider
	x.DistributionId = b.DistributionId
	x.CacheBehaviors = b.CacheBehaviors
	x.Origin = b.Origin
	return m0
}

type DomainConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Custom domain name
	DomainName *string `protobuf:"bytes,1,opt,name=domain_name,json=domainName" json:"domain_name,omitempty"`
	// SSL certificate ARN or ID
	SslCertificate *string `protobuf:"bytes,2,opt,name=ssl_certificate,json=sslCertificate" json:"ssl_certificate,omitempty"`
	// DNS configuration
	Dns *DNSConfig `protobuf:"bytes,3,opt,name=dns" json:"dns,omitempty"`
	// Domain validation status
	ValidationStatus *string `protobuf:"bytes,4,opt,name=validation_status,json=validationStatus" json:"validation_status,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DomainConfig) Reset() {
	*x = DomainConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DomainConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DomainConfig) ProtoMessage() {}

func (x *DomainConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DomainConfig) GetDomainName() string {
	if x != nil && x.DomainName != nil {
		return *x.DomainName
	}
	return ""
}

func (x *DomainConfig) GetSslCertificate() string {
	if x != nil && x.SslCertificate != nil {
		return *x.SslCertificate
	}
	return ""
}

func (x *DomainConfig) GetDns() *DNSConfig {
	if x != nil {
		return x.Dns
	}
	return nil
}

func (x *DomainConfig) GetValidationStatus() string {
	if x != nil && x.ValidationStatus != nil {
		return *x.ValidationStatus
	}
	return ""
}

func (x *DomainConfig) SetDomainName(v string) {
	x.DomainName = &v
}

func (x *DomainConfig) SetSslCertificate(v string) {
	x.SslCertificate = &v
}

func (x *DomainConfig) SetDns(v *DNSConfig) {
	x.Dns = v
}

func (x *DomainConfig) SetValidationStatus(v string) {
	x.ValidationStatus = &v
}

func (x *DomainConfig) HasDomainName() bool {
	if x == nil {
		return false
	}
	return x.DomainName != nil
}

func (x *DomainConfig) HasSslCertificate() bool {
	if x == nil {
		return false
	}
	return x.SslCertificate != nil
}

func (x *DomainConfig) HasDns() bool {
	if x == nil {
		return false
	}
	return x.Dns != nil
}

func (x *DomainConfig) HasValidationStatus() bool {
	if x == nil {
		return false
	}
	return x.ValidationStatus != nil
}

func (x *DomainConfig) ClearDomainName() {
	x.DomainName = nil
}

func (x *DomainConfig) ClearSslCertificate() {
	x.SslCertificate = nil
}

func (x *DomainConfig) ClearDns() {
	x.Dns = nil
}

func (x *DomainConfig) ClearValidationStatus() {
	x.ValidationStatus = nil
}

type DomainConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Custom domain name
	DomainName *string
	// SSL certificate ARN or ID
	SslCertificate *string
	// DNS configuration
	Dns *DNSConfig
	// Domain validation status
	ValidationStatus *string
}

func (b0 DomainConfig_builder) Build() *DomainConfig {
	m0 := &DomainConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.DomainName = b.DomainName
	x.SslCertificate = b.SslCertificate
	x.Dns = b.Dns
	x.ValidationStatus = b.ValidationStatus
	return m0
}

type StorageEncryption struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Encryption type (AES256, KMS)
	Type *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Key ID for KMS encryption
	KeyId *string `protobuf:"bytes,2,opt,name=key_id,json=keyId" json:"key_id,omitempty"`
	// Whether server-side encryption is enabled
	ServerSide *bool `protobuf:"varint,3,opt,name=server_side,json=serverSide" json:"server_side,omitempty"`
	// Whether client-side encryption is enabled
	ClientSide    *bool `protobuf:"varint,4,opt,name=client_side,json=clientSide" json:"client_side,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageEncryption) Reset() {
	*x = StorageEncryption{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageEncryption) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageEncryption) ProtoMessage() {}

func (x *StorageEncryption) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StorageEncryption) GetType() string {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return ""
}

func (x *StorageEncryption) GetKeyId() string {
	if x != nil && x.KeyId != nil {
		return *x.KeyId
	}
	return ""
}

func (x *StorageEncryption) GetServerSide() bool {
	if x != nil && x.ServerSide != nil {
		return *x.ServerSide
	}
	return false
}

func (x *StorageEncryption) GetClientSide() bool {
	if x != nil && x.ClientSide != nil {
		return *x.ClientSide
	}
	return false
}

func (x *StorageEncryption) SetType(v string) {
	x.Type = &v
}

func (x *StorageEncryption) SetKeyId(v string) {
	x.KeyId = &v
}

func (x *StorageEncryption) SetServerSide(v bool) {
	x.ServerSide = &v
}

func (x *StorageEncryption) SetClientSide(v bool) {
	x.ClientSide = &v
}

func (x *StorageEncryption) HasType() bool {
	if x == nil {
		return false
	}
	return x.Type != nil
}

func (x *StorageEncryption) HasKeyId() bool {
	if x == nil {
		return false
	}
	return x.KeyId != nil
}

func (x *StorageEncryption) HasServerSide() bool {
	if x == nil {
		return false
	}
	return x.ServerSide != nil
}

func (x *StorageEncryption) HasClientSide() bool {
	if x == nil {
		return false
	}
	return x.ClientSide != nil
}

func (x *StorageEncryption) ClearType() {
	x.Type = nil
}

func (x *StorageEncryption) ClearKeyId() {
	x.KeyId = nil
}

func (x *StorageEncryption) ClearServerSide() {
	x.ServerSide = nil
}

func (x *StorageEncryption) ClearClientSide() {
	x.ClientSide = nil
}

type StorageEncryption_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Encryption type (AES256, KMS)
	Type *string
	// Key ID for KMS encryption
	KeyId *string
	// Whether server-side encryption is enabled
	ServerSide *bool
	// Whether client-side encryption is enabled
	ClientSide *bool
}

func (b0 StorageEncryption_builder) Build() *StorageEncryption {
	m0 := &StorageEncryption{}
	b, x := &b0, m0
	_, _ = b, x
	x.Type = b.Type
	x.KeyId = b.KeyId
	x.ServerSide = b.ServerSide
	x.ClientSide = b.ClientSide
	return m0
}

type StoragePolicy struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Policy name
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Policy statement (JSON)
	Statement *string `protobuf:"bytes,2,opt,name=statement" json:"statement,omitempty"`
	// Policy effect (Allow, Deny)
	Effect *string `protobuf:"bytes,3,opt,name=effect" json:"effect,omitempty"`
	// Resources covered by this policy
	Resources []string `protobuf:"bytes,4,rep,name=resources" json:"resources,omitempty"`
	// Actions covered by this policy
	Actions       []string `protobuf:"bytes,5,rep,name=actions" json:"actions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoragePolicy) Reset() {
	*x = StoragePolicy{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoragePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoragePolicy) ProtoMessage() {}

func (x *StoragePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StoragePolicy) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *StoragePolicy) GetStatement() string {
	if x != nil && x.Statement != nil {
		return *x.Statement
	}
	return ""
}

func (x *StoragePolicy) GetEffect() string {
	if x != nil && x.Effect != nil {
		return *x.Effect
	}
	return ""
}

func (x *StoragePolicy) GetResources() []string {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *StoragePolicy) GetActions() []string {
	if x != nil {
		return x.Actions
	}
	return nil
}

func (x *StoragePolicy) SetName(v string) {
	x.Name = &v
}

func (x *StoragePolicy) SetStatement(v string) {
	x.Statement = &v
}

func (x *StoragePolicy) SetEffect(v string) {
	x.Effect = &v
}

func (x *StoragePolicy) SetResources(v []string) {
	x.Resources = v
}

func (x *StoragePolicy) SetActions(v []string) {
	x.Actions = v
}

func (x *StoragePolicy) HasName() bool {
	if x == nil {
		return false
	}
	return x.Name != nil
}

func (x *StoragePolicy) HasStatement() bool {
	if x == nil {
		return false
	}
	return x.Statement != nil
}

func (x *StoragePolicy) HasEffect() bool {
	if x == nil {
		return false
	}
	return x.Effect != nil
}

func (x *StoragePolicy) ClearName() {
	x.Name = nil
}

func (x *StoragePolicy) ClearStatement() {
	x.Statement = nil
}

func (x *StoragePolicy) ClearEffect() {
	x.Effect = nil
}

type StoragePolicy_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Policy name
	Name *string
	// Policy statement (JSON)
	Statement *string
	// Policy effect (Allow, Deny)
	Effect *string
	// Resources covered by this policy
	Resources []string
	// Actions covered by this policy
	Actions []string
}

func (b0 StoragePolicy_builder) Build() *StoragePolicy {
	m0 := &StoragePolicy{}
	b, x := &b0, m0
	_, _ = b, x
	x.Name = b.Name
	x.Statement = b.Statement
	x.Effect = b.Effect
	x.Resources = b.Resources
	x.Actions = b.Actions
	return m0
}

type StorageBackupConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Whether backup is enabled
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Backup schedule (cron expression)
	Schedule *string `protobuf:"bytes,2,opt,name=schedule" json:"schedule,omitempty"`
	// Backup retention period
	RetentionDays *int32 `protobuf:"varint,3,opt,name=retention_days,json=retentionDays" json:"retention_days,omitempty"`
	// Cross-region backup enabled
	CrossRegion *bool `protobuf:"varint,4,opt,name=cross_region,json=crossRegion" json:"cross_region,omitempty"`
	// Backup encryption enabled
	EncryptionEnabled *bool `protobuf:"varint,5,opt,name=encryption_enabled,json=encryptionEnabled" json:"encryption_enabled,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StorageBackupConfig) Reset() {
	*x = StorageBackupConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageBackupConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageBackupConfig) ProtoMessage() {}

func (x *StorageBackupConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StorageBackupConfig) GetEnabled() bool {
	if x != nil && x.Enabled != nil {
		return *x.Enabled
	}
	return false
}

func (x *StorageBackupConfig) GetSchedule() string {
	if x != nil && x.Schedule != nil {
		return *x.Schedule
	}
	return ""
}

func (x *StorageBackupConfig) GetRetentionDays() int32 {
	if x != nil && x.RetentionDays != nil {
		return *x.RetentionDays
	}
	return 0
}

func (x *StorageBackupConfig) GetCrossRegion() bool {
	if x != nil && x.CrossRegion != nil {
		return *x.CrossRegion
	}
	return false
}

func (x *StorageBackupConfig) GetEncryptionEnabled() bool {
	if x != nil && x.EncryptionEnabled != nil {
		return *x.EncryptionEnabled
	}
	return false
}

func (x *StorageBackupConfig) SetEnabled(v bool) {
	x.Enabled = &v
}

func (x *StorageBackupConfig) SetSchedule(v string) {
	x.Schedule = &v
}

func (x *StorageBackupConfig) SetRetentionDays(v int32) {
	x.RetentionDays = &v
}

func (x *StorageBackupConfig) SetCrossRegion(v bool) {
	x.CrossRegion = &v
}

func (x *StorageBackupConfig) SetEncryptionEnabled(v bool) {
	x.EncryptionEnabled = &v
}

func (x *StorageBackupConfig) HasEnabled() bool {
	if x == nil {
		return false
	}
	return x.Enabled != nil
}

func (x *StorageBackupConfig) HasSchedule() bool {
	if x == nil {
		return false
	}
	return x.Schedule != nil
}

func (x *StorageBackupConfig) HasRetentionDays() bool {
	if x == nil {
		return false
	}
	return x.RetentionDays != nil
}

func (x *StorageBackupConfig) HasCrossRegion() bool {
	if x == nil {
		return false
	}
	return x.CrossRegion != nil
}

func (x *StorageBackupConfig) HasEncryptionEnabled() bool {
	if x == nil {
		return false
	}
	return x.EncryptionEnabled != nil
}

func (x *StorageBackupConfig) ClearEnabled() {
	x.Enabled = nil
}

func (x *StorageBackupConfig) ClearSchedule() {
	x.Schedule = nil
}

func (x *StorageBackupConfig) ClearRetentionDays() {
	x.RetentionDays = nil
}

func (x *StorageBackupConfig) ClearCrossRegion() {
	x.CrossRegion = nil
}

func (x *StorageBackupConfig) ClearEncryptionEnabled() {
	x.EncryptionEnabled = nil
}

type StorageBackupConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Whether backup is enabled
	Enabled *bool
	// Backup schedule (cron expression)
	Schedule *string
	// Backup retention period
	RetentionDays *int32
	// Cross-region backup enabled
	CrossRegion *bool
	// Backup encryption enabled
	EncryptionEnabled *bool
}

func (b0 StorageBackupConfig_builder) Build() *StorageBackupConfig {
	m0 := &StorageBackupConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.Enabled = b.Enabled
	x.Schedule = b.Schedule
	x.RetentionDays = b.RetentionDays
	x.CrossRegion = b.CrossRegion
	x.EncryptionEnabled = b.EncryptionEnabled
	return m0
}

type StorageQuota struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Maximum storage size in bytes
	MaxSizeBytes *int64 `protobuf:"varint,1,opt,name=max_size_bytes,json=maxSizeBytes" json:"max_size_bytes,omitempty"`
	// Maximum number of objects
	MaxObjects *int64 `protobuf:"varint,2,opt,name=max_objects,json=maxObjects" json:"max_objects,omitempty"`
	// Maximum request rate per second
	MaxRequestsPerSecond *int32 `protobuf:"varint,3,opt,name=max_requests_per_second,json=maxRequestsPerSecond" json:"max_requests_per_second,omitempty"`
	// Transfer quota in bytes per month
	TransferQuotaBytes *int64 `protobuf:"varint,4,opt,name=transfer_quota_bytes,json=transferQuotaBytes" json:"transfer_quota_bytes,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StorageQuota) Reset() {
	*x = StorageQuota{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageQuota) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageQuota) ProtoMessage() {}

func (x *StorageQuota) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StorageQuota) GetMaxSizeBytes() int64 {
	if x != nil && x.MaxSizeBytes != nil {
		return *x.MaxSizeBytes
	}
	return 0
}

func (x *StorageQuota) GetMaxObjects() int64 {
	if x != nil && x.MaxObjects != nil {
		return *x.MaxObjects
	}
	return 0
}

func (x *StorageQuota) GetMaxRequestsPerSecond() int32 {
	if x != nil && x.MaxRequestsPerSecond != nil {
		return *x.MaxRequestsPerSecond
	}
	return 0
}

func (x *StorageQuota) GetTransferQuotaBytes() int64 {
	if x != nil && x.TransferQuotaBytes != nil {
		return *x.TransferQuotaBytes
	}
	return 0
}

func (x *StorageQuota) SetMaxSizeBytes(v int64) {
	x.MaxSizeBytes = &v
}

func (x *StorageQuota) SetMaxObjects(v int64) {
	x.MaxObjects = &v
}

func (x *StorageQuota) SetMaxRequestsPerSecond(v int32) {
	x.MaxRequestsPerSecond = &v
}

func (x *StorageQuota) SetTransferQuotaBytes(v int64) {
	x.TransferQuotaBytes = &v
}

func (x *StorageQuota) HasMaxSizeBytes() bool {
	if x == nil {
		return false
	}
	return x.MaxSizeBytes != nil
}

func (x *StorageQuota) HasMaxObjects() bool {
	if x == nil {
		return false
	}
	return x.MaxObjects != nil
}

func (x *StorageQuota) HasMaxRequestsPerSecond() bool {
	if x == nil {
		return false
	}
	return x.MaxRequestsPerSecond != nil
}

func (x *StorageQuota) HasTransferQuotaBytes() bool {
	if x == nil {
		return false
	}
	return x.TransferQuotaBytes != nil
}

func (x *StorageQuota) ClearMaxSizeBytes() {
	x.MaxSizeBytes = nil
}

func (x *StorageQuota) ClearMaxObjects() {
	x.MaxObjects = nil
}

func (x *StorageQuota) ClearMaxRequestsPerSecond() {
	x.MaxRequestsPerSecond = nil
}

func (x *StorageQuota) ClearTransferQuotaBytes() {
	x.TransferQuotaBytes = nil
}

type StorageQuota_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Maximum storage size in bytes
	MaxSizeBytes *int64
	// Maximum number of objects
	MaxObjects *int64
	// Maximum request rate per second
	MaxRequestsPerSecond *int32
	// Transfer quota in bytes per month
	TransferQuotaBytes *int64
}

func (b0 StorageQuota_builder) Build() *StorageQuota {
	m0 := &StorageQuota{}
	b, x := &b0, m0
	_, _ = b, x
	x.MaxSizeBytes = b.MaxSizeBytes
	x.MaxObjects = b.MaxObjects
	x.MaxRequestsPerSecond = b.MaxRequestsPerSecond
	x.TransferQuotaBytes = b.TransferQuotaBytes
	return m0
}

type CPUAllocation struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Number of CPU cores
	Cores *int32 `protobuf:"varint,1,opt,name=cores" json:"cores,omitempty"`
	// CPU frequency in MHz
	FrequencyMhz *int32 `protobuf:"varint,2,opt,name=frequency_mhz,json=frequencyMhz" json:"frequency_mhz,omitempty"`
	// CPU usage limit percentage
	UsageLimitPercent *int32 `protobuf:"varint,3,opt,name=usage_limit_percent,json=usageLimitPercent" json:"usage_limit_percent,omitempty"`
	// CPU priority
	Priority      *int32 `protobuf:"varint,4,opt,name=priority" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CPUAllocation) Reset() {
	*x = CPUAllocation{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CPUAllocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CPUAllocation) ProtoMessage() {}

func (x *CPUAllocation) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CPUAllocation) GetCores() int32 {
	if x != nil && x.Cores != nil {
		return *x.Cores
	}
	return 0
}

func (x *CPUAllocation) GetFrequencyMhz() int32 {
	if x != nil && x.FrequencyMhz != nil {
		return *x.FrequencyMhz
	}
	return 0
}

func (x *CPUAllocation) GetUsageLimitPercent() int32 {
	if x != nil && x.UsageLimitPercent != nil {
		return *x.UsageLimitPercent
	}
	return 0
}

func (x *CPUAllocation) GetPriority() int32 {
	if x != nil && x.Priority != nil {
		return *x.Priority
	}
	return 0
}

func (x *CPUAllocation) SetCores(v int32) {
	x.Cores = &v
}

func (x *CPUAllocation) SetFrequencyMhz(v int32) {
	x.FrequencyMhz = &v
}

func (x *CPUAllocation) SetUsageLimitPercent(v int32) {
	x.UsageLimitPercent = &v
}

func (x *CPUAllocation) SetPriority(v int32) {
	x.Priority = &v
}

func (x *CPUAllocation) HasCores() bool {
	if x == nil {
		return false
	}
	return x.Cores != nil
}

func (x *CPUAllocation) HasFrequencyMhz() bool {
	if x == nil {
		return false
	}
	return x.FrequencyMhz != nil
}

func (x *CPUAllocation) HasUsageLimitPercent() bool {
	if x == nil {
		return false
	}
	return x.UsageLimitPercent != nil
}

func (x *CPUAllocation) HasPriority() bool {
	if x == nil {
		return false
	}
	return x.Priority != nil
}

func (x *CPUAllocation) ClearCores() {
	x.Cores = nil
}

func (x *CPUAllocation) ClearFrequencyMhz() {
	x.FrequencyMhz = nil
}

func (x *CPUAllocation) ClearUsageLimitPercent() {
	x.UsageLimitPercent = nil
}

func (x *CPUAllocation) ClearPriority() {
	x.Priority = nil
}

type CPUAllocation_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Number of CPU cores
	Cores *int32
	// CPU frequency in MHz
	FrequencyMhz *int32
	// CPU usage limit percentage
	UsageLimitPercent *int32
	// CPU priority
	Priority *int32
}

func (b0 CPUAllocation_builder) Build() *CPUAllocation {
	m0 := &CPUAllocation{}
	b, x := &b0, m0
	_, _ = b, x
	x.Cores = b.Cores
	x.FrequencyMhz = b.FrequencyMhz
	x.UsageLimitPercent = b.UsageLimitPercent
	x.Priority = b.Priority
	return m0
}

type MemoryAllocation struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Memory size in MB
	SizeMb *int64 `protobuf:"varint,1,opt,name=size_mb,json=sizeMb" json:"size_mb,omitempty"`
	// Memory usage limit percentage
	UsageLimitPercent *int32 `protobuf:"varint,2,opt,name=usage_limit_percent,json=usageLimitPercent" json:"usage_limit_percent,omitempty"`
	// Swap allocation in MB
	SwapMb        *int64 `protobuf:"varint,3,opt,name=swap_mb,json=swapMb" json:"swap_mb,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MemoryAllocation) Reset() {
	*x = MemoryAllocation{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MemoryAllocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MemoryAllocation) ProtoMessage() {}

func (x *MemoryAllocation) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *MemoryAllocation) GetSizeMb() int64 {
	if x != nil && x.SizeMb != nil {
		return *x.SizeMb
	}
	return 0
}

func (x *MemoryAllocation) GetUsageLimitPercent() int32 {
	if x != nil && x.UsageLimitPercent != nil {
		return *x.UsageLimitPercent
	}
	return 0
}

func (x *MemoryAllocation) GetSwapMb() int64 {
	if x != nil && x.SwapMb != nil {
		return *x.SwapMb
	}
	return 0
}

func (x *MemoryAllocation) SetSizeMb(v int64) {
	x.SizeMb = &v
}

func (x *MemoryAllocation) SetUsageLimitPercent(v int32) {
	x.UsageLimitPercent = &v
}

func (x *MemoryAllocation) SetSwapMb(v int64) {
	x.SwapMb = &v
}

func (x *MemoryAllocation) HasSizeMb() bool {
	if x == nil {
		return false
	}
	return x.SizeMb != nil
}

func (x *MemoryAllocation) HasUsageLimitPercent() bool {
	if x == nil {
		return false
	}
	return x.UsageLimitPercent != nil
}

func (x *MemoryAllocation) HasSwapMb() bool {
	if x == nil {
		return false
	}
	return x.SwapMb != nil
}

func (x *MemoryAllocation) ClearSizeMb() {
	x.SizeMb = nil
}

func (x *MemoryAllocation) ClearUsageLimitPercent() {
	x.UsageLimitPercent = nil
}

func (x *MemoryAllocation) ClearSwapMb() {
	x.SwapMb = nil
}

type MemoryAllocation_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Memory size in MB
	SizeMb *int64
	// Memory usage limit percentage
	UsageLimitPercent *int32
	// Swap allocation in MB
	SwapMb *int64
}

func (b0 MemoryAllocation_builder) Build() *MemoryAllocation {
	m0 := &MemoryAllocation{}
	b, x := &b0, m0
	_, _ = b, x
	x.SizeMb = b.SizeMb
	x.UsageLimitPercent = b.UsageLimitPercent
	x.SwapMb = b.SwapMb
	return m0
}

type ResourceLimits struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Maximum CPU usage percentage
	MaxCpuPercent *int32 `protobuf:"varint,1,opt,name=max_cpu_percent,json=maxCpuPercent" json:"max_cpu_percent,omitempty"`
	// Maximum memory usage in MB
	MaxMemoryMb *int64 `protobuf:"varint,2,opt,name=max_memory_mb,json=maxMemoryMb" json:"max_memory_mb,omitempty"`
	// Maximum disk I/O operations per second
	MaxDiskIops *int32 `protobuf:"varint,3,opt,name=max_disk_iops,json=maxDiskIops" json:"max_disk_iops,omitempty"`
	// Maximum network bandwidth in Mbps
	MaxNetworkMbps *int32 `protobuf:"varint,4,opt,name=max_network_mbps,json=maxNetworkMbps" json:"max_network_mbps,omitempty"`
	// Maximum number of processes
	MaxProcesses *int32 `protobuf:"varint,5,opt,name=max_processes,json=maxProcesses" json:"max_processes,omitempty"`
	// Maximum number of file descriptors
	MaxFileDescriptors *int32 `protobuf:"varint,6,opt,name=max_file_descriptors,json=maxFileDescriptors" json:"max_file_descriptors,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ResourceLimits) Reset() {
	*x = ResourceLimits{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResourceLimits) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResourceLimits) ProtoMessage() {}

func (x *ResourceLimits) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ResourceLimits) GetMaxCpuPercent() int32 {
	if x != nil && x.MaxCpuPercent != nil {
		return *x.MaxCpuPercent
	}
	return 0
}

func (x *ResourceLimits) GetMaxMemoryMb() int64 {
	if x != nil && x.MaxMemoryMb != nil {
		return *x.MaxMemoryMb
	}
	return 0
}

func (x *ResourceLimits) GetMaxDiskIops() int32 {
	if x != nil && x.MaxDiskIops != nil {
		return *x.MaxDiskIops
	}
	return 0
}

func (x *ResourceLimits) GetMaxNetworkMbps() int32 {
	if x != nil && x.MaxNetworkMbps != nil {
		return *x.MaxNetworkMbps
	}
	return 0
}

func (x *ResourceLimits) GetMaxProcesses() int32 {
	if x != nil && x.MaxProcesses != nil {
		return *x.MaxProcesses
	}
	return 0
}

func (x *ResourceLimits) GetMaxFileDescriptors() int32 {
	if x != nil && x.MaxFileDescriptors != nil {
		return *x.MaxFileDescriptors
	}
	return 0
}

func (x *ResourceLimits) SetMaxCpuPercent(v int32) {
	x.MaxCpuPercent = &v
}

func (x *ResourceLimits) SetMaxMemoryMb(v int64) {
	x.MaxMemoryMb = &v
}

func (x *ResourceLimits) SetMaxDiskIops(v int32) {
	x.MaxDiskIops = &v
}

func (x *ResourceLimits) SetMaxNetworkMbps(v int32) {
	x.MaxNetworkMbps = &v
}

func (x *ResourceLimits) SetMaxProcesses(v int32) {
	x.MaxProcesses = &v
}

func (x *ResourceLimits) SetMaxFileDescriptors(v int32) {
	x.MaxFileDescriptors = &v
}

func (x *ResourceLimits) HasMaxCpuPercent() bool {
	if x == nil {
		return false
	}
	return x.MaxCpuPercent != nil
}

func (x *ResourceLimits) HasMaxMemoryMb() bool {
	if x == nil {
		return false
	}
	return x.MaxMemoryMb != nil
}

func (x *ResourceLimits) HasMaxDiskIops() bool {
	if x == nil {
		return false
	}
	return x.MaxDiskIops != nil
}

func (x *ResourceLimits) HasMaxNetworkMbps() bool {
	if x == nil {
		return false
	}
	return x.MaxNetworkMbps != nil
}

func (x *ResourceLimits) HasMaxProcesses() bool {
	if x == nil {
		return false
	}
	return x.MaxProcesses != nil
}

func (x *ResourceLimits) HasMaxFileDescriptors() bool {
	if x == nil {
		return false
	}
	return x.MaxFileDescriptors != nil
}

func (x *ResourceLimits) ClearMaxCpuPercent() {
	x.MaxCpuPercent = nil
}

func (x *ResourceLimits) ClearMaxMemoryMb() {
	x.MaxMemoryMb = nil
}

func (x *ResourceLimits) ClearMaxDiskIops() {
	x.MaxDiskIops = nil
}

func (x *ResourceLimits) ClearMaxNetworkMbps() {
	x.MaxNetworkMbps = nil
}

func (x *ResourceLimits) ClearMaxProcesses() {
	x.MaxProcesses = nil
}

func (x *ResourceLimits) ClearMaxFileDescriptors() {
	x.MaxFileDescriptors = nil
}

type ResourceLimits_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Maximum CPU usage percentage
	MaxCpuPercent *int32
	// Maximum memory usage in MB
	MaxMemoryMb *int64
	// Maximum disk I/O operations per second
	MaxDiskIops *int32
	// Maximum network bandwidth in Mbps
	MaxNetworkMbps *int32
	// Maximum number of processes
	MaxProcesses *int32
	// Maximum number of file descriptors
	MaxFileDescriptors *int32
}

func (b0 ResourceLimits_builder) Build() *ResourceLimits {
	m0 := &ResourceLimits{}
	b, x := &b0, m0
	_, _ = b, x
	x.MaxCpuPercent = b.MaxCpuPercent
	x.MaxMemoryMb = b.MaxMemoryMb
	x.MaxDiskIops = b.MaxDiskIops
	x.MaxNetworkMbps = b.MaxNetworkMbps
	x.MaxProcesses = b.MaxProcesses
	x.MaxFileDescriptors = b.MaxFileDescriptors
	return m0
}

type AutoScalingConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Whether auto-scaling is enabled
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Minimum number of instances
	MinInstances *int32 `protobuf:"varint,2,opt,name=min_instances,json=minInstances" json:"min_instances,omitempty"`
	// Maximum number of instances
	MaxInstances *int32 `protobuf:"varint,3,opt,name=max_instances,json=maxInstances" json:"max_instances,omitempty"`
	// Target CPU utilization percentage
	TargetCpuPercent *int32 `protobuf:"varint,4,opt,name=target_cpu_percent,json=targetCpuPercent" json:"target_cpu_percent,omitempty"`
	// Target memory utilization percentage
	TargetMemoryPercent *int32 `protobuf:"varint,5,opt,name=target_memory_percent,json=targetMemoryPercent" json:"target_memory_percent,omitempty"`
	// Scale-up cooldown period in seconds
	ScaleUpCooldown *int32 `protobuf:"varint,6,opt,name=scale_up_cooldown,json=scaleUpCooldown" json:"scale_up_cooldown,omitempty"`
	// Scale-down cooldown period in seconds
	ScaleDownCooldown *int32 `protobuf:"varint,7,opt,name=scale_down_cooldown,json=scaleDownCooldown" json:"scale_down_cooldown,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AutoScalingConfig) Reset() {
	*x = AutoScalingConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoScalingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoScalingConfig) ProtoMessage() {}

func (x *AutoScalingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AutoScalingConfig) GetEnabled() bool {
	if x != nil && x.Enabled != nil {
		return *x.Enabled
	}
	return false
}

func (x *AutoScalingConfig) GetMinInstances() int32 {
	if x != nil && x.MinInstances != nil {
		return *x.MinInstances
	}
	return 0
}

func (x *AutoScalingConfig) GetMaxInstances() int32 {
	if x != nil && x.MaxInstances != nil {
		return *x.MaxInstances
	}
	return 0
}

func (x *AutoScalingConfig) GetTargetCpuPercent() int32 {
	if x != nil && x.TargetCpuPercent != nil {
		return *x.TargetCpuPercent
	}
	return 0
}

func (x *AutoScalingConfig) GetTargetMemoryPercent() int32 {
	if x != nil && x.TargetMemoryPercent != nil {
		return *x.TargetMemoryPercent
	}
	return 0
}

func (x *AutoScalingConfig) GetScaleUpCooldown() int32 {
	if x != nil && x.ScaleUpCooldown != nil {
		return *x.ScaleUpCooldown
	}
	return 0
}

func (x *AutoScalingConfig) GetScaleDownCooldown() int32 {
	if x != nil && x.ScaleDownCooldown != nil {
		return *x.ScaleDownCooldown
	}
	return 0
}

func (x *AutoScalingConfig) SetEnabled(v bool) {
	x.Enabled = &v
}

func (x *AutoScalingConfig) SetMinInstances(v int32) {
	x.MinInstances = &v
}

func (x *AutoScalingConfig) SetMaxInstances(v int32) {
	x.MaxInstances = &v
}

func (x *AutoScalingConfig) SetTargetCpuPercent(v int32) {
	x.TargetCpuPercent = &v
}

func (x *AutoScalingConfig) SetTargetMemoryPercent(v int32) {
	x.TargetMemoryPercent = &v
}

func (x *AutoScalingConfig) SetScaleUpCooldown(v int32) {
	x.ScaleUpCooldown = &v
}

func (x *AutoScalingConfig) SetScaleDownCooldown(v int32) {
	x.ScaleDownCooldown = &v
}

func (x *AutoScalingConfig) HasEnabled() bool {
	if x == nil {
		return false
	}
	return x.Enabled != nil
}

func (x *AutoScalingConfig) HasMinInstances() bool {
	if x == nil {
		return false
	}
	return x.MinInstances != nil
}

func (x *AutoScalingConfig) HasMaxInstances() bool {
	if x == nil {
		return false
	}
	return x.MaxInstances != nil
}

func (x *AutoScalingConfig) HasTargetCpuPercent() bool {
	if x == nil {
		return false
	}
	return x.TargetCpuPercent != nil
}

func (x *AutoScalingConfig) HasTargetMemoryPercent() bool {
	if x == nil {
		return false
	}
	return x.TargetMemoryPercent != nil
}

func (x *AutoScalingConfig) HasScaleUpCooldown() bool {
	if x == nil {
		return false
	}
	return x.ScaleUpCooldown != nil
}

func (x *AutoScalingConfig) HasScaleDownCooldown() bool {
	if x == nil {
		return false
	}
	return x.ScaleDownCooldown != nil
}

func (x *AutoScalingConfig) ClearEnabled() {
	x.Enabled = nil
}

func (x *AutoScalingConfig) ClearMinInstances() {
	x.MinInstances = nil
}

func (x *AutoScalingConfig) ClearMaxInstances() {
	x.MaxInstances = nil
}

func (x *AutoScalingConfig) ClearTargetCpuPercent() {
	x.TargetCpuPercent = nil
}

func (x *AutoScalingConfig) ClearTargetMemoryPercent() {
	x.TargetMemoryPercent = nil
}

func (x *AutoScalingConfig) ClearScaleUpCooldown() {
	x.ScaleUpCooldown = nil
}

func (x *AutoScalingConfig) ClearScaleDownCooldown() {
	x.ScaleDownCooldown = nil
}

type AutoScalingConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Whether auto-scaling is enabled
	Enabled *bool
	// Minimum number of instances
	MinInstances *int32
	// Maximum number of instances
	MaxInstances *int32
	// Target CPU utilization percentage
	TargetCpuPercent *int32
	// Target memory utilization percentage
	TargetMemoryPercent *int32
	// Scale-up cooldown period in seconds
	ScaleUpCooldown *int32
	// Scale-down cooldown period in seconds
	ScaleDownCooldown *int32
}

func (b0 AutoScalingConfig_builder) Build() *AutoScalingConfig {
	m0 := &AutoScalingConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.Enabled = b.Enabled
	x.MinInstances = b.MinInstances
	x.MaxInstances = b.MaxInstances
	x.TargetCpuPercent = b.TargetCpuPercent
	x.TargetMemoryPercent = b.TargetMemoryPercent
	x.ScaleUpCooldown = b.ScaleUpCooldown
	x.ScaleDownCooldown = b.ScaleDownCooldown
	return m0
}

type TimeRestriction struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Day of week (0-6, 0=Sunday)
	DayOfWeek *int32 `protobuf:"varint,1,opt,name=day_of_week,json=dayOfWeek" json:"day_of_week,omitempty"`
	// Start time (24-hour format, e.g., "09:00")
	StartTime *string `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// End time (24-hour format, e.g., "17:00")
	EndTime *string `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// Timezone for this restriction
	Timezone      *string `protobuf:"bytes,4,opt,name=timezone" json:"timezone,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimeRestriction) Reset() {
	*x = TimeRestriction{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeRestriction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeRestriction) ProtoMessage() {}

func (x *TimeRestriction) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TimeRestriction) GetDayOfWeek() int32 {
	if x != nil && x.DayOfWeek != nil {
		return *x.DayOfWeek
	}
	return 0
}

func (x *TimeRestriction) GetStartTime() string {
	if x != nil && x.StartTime != nil {
		return *x.StartTime
	}
	return ""
}

func (x *TimeRestriction) GetEndTime() string {
	if x != nil && x.EndTime != nil {
		return *x.EndTime
	}
	return ""
}

func (x *TimeRestriction) GetTimezone() string {
	if x != nil && x.Timezone != nil {
		return *x.Timezone
	}
	return ""
}

func (x *TimeRestriction) SetDayOfWeek(v int32) {
	x.DayOfWeek = &v
}

func (x *TimeRestriction) SetStartTime(v string) {
	x.StartTime = &v
}

func (x *TimeRestriction) SetEndTime(v string) {
	x.EndTime = &v
}

func (x *TimeRestriction) SetTimezone(v string) {
	x.Timezone = &v
}

func (x *TimeRestriction) HasDayOfWeek() bool {
	if x == nil {
		return false
	}
	return x.DayOfWeek != nil
}

func (x *TimeRestriction) HasStartTime() bool {
	if x == nil {
		return false
	}
	return x.StartTime != nil
}

func (x *TimeRestriction) HasEndTime() bool {
	if x == nil {
		return false
	}
	return x.EndTime != nil
}

func (x *TimeRestriction) HasTimezone() bool {
	if x == nil {
		return false
	}
	return x.Timezone != nil
}

func (x *TimeRestriction) ClearDayOfWeek() {
	x.DayOfWeek = nil
}

func (x *TimeRestriction) ClearStartTime() {
	x.StartTime = nil
}

func (x *TimeRestriction) ClearEndTime() {
	x.EndTime = nil
}

func (x *TimeRestriction) ClearTimezone() {
	x.Timezone = nil
}

type TimeRestriction_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Day of week (0-6, 0=Sunday)
	DayOfWeek *int32
	// Start time (24-hour format, e.g., "09:00")
	StartTime *string
	// End time (24-hour format, e.g., "17:00")
	EndTime *string
	// Timezone for this restriction
	Timezone *string
}

func (b0 TimeRestriction_builder) Build() *TimeRestriction {
	m0 := &TimeRestriction{}
	b, x := &b0, m0
	_, _ = b, x
	x.DayOfWeek = b.DayOfWeek
	x.StartTime = b.StartTime
	x.EndTime = b.EndTime
	x.Timezone = b.Timezone
	return m0
}

type AuditAlert struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Alert name
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Event patterns to match
	EventPatterns []string `protobuf:"bytes,2,rep,name=event_patterns,json=eventPatterns" json:"event_patterns,omitempty"`
	// Alert severity level
	Severity *string `protobuf:"bytes,3,opt,name=severity" json:"severity,omitempty"`
	// Notification channels for this alert
	NotificationChannels []string `protobuf:"bytes,4,rep,name=notification_channels,json=notificationChannels" json:"notification_channels,omitempty"`
	// Alert threshold (if applicable)
	Threshold *int32 `protobuf:"varint,5,opt,name=threshold" json:"threshold,omitempty"`
	// Time window for threshold evaluation in minutes
	TimeWindowMinutes *int32 `protobuf:"varint,6,opt,name=time_window_minutes,json=timeWindowMinutes" json:"time_window_minutes,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AuditAlert) Reset() {
	*x = AuditAlert{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuditAlert) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuditAlert) ProtoMessage() {}

func (x *AuditAlert) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AuditAlert) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *AuditAlert) GetEventPatterns() []string {
	if x != nil {
		return x.EventPatterns
	}
	return nil
}

func (x *AuditAlert) GetSeverity() string {
	if x != nil && x.Severity != nil {
		return *x.Severity
	}
	return ""
}

func (x *AuditAlert) GetNotificationChannels() []string {
	if x != nil {
		return x.NotificationChannels
	}
	return nil
}

func (x *AuditAlert) GetThreshold() int32 {
	if x != nil && x.Threshold != nil {
		return *x.Threshold
	}
	return 0
}

func (x *AuditAlert) GetTimeWindowMinutes() int32 {
	if x != nil && x.TimeWindowMinutes != nil {
		return *x.TimeWindowMinutes
	}
	return 0
}

func (x *AuditAlert) SetName(v string) {
	x.Name = &v
}

func (x *AuditAlert) SetEventPatterns(v []string) {
	x.EventPatterns = v
}

func (x *AuditAlert) SetSeverity(v string) {
	x.Severity = &v
}

func (x *AuditAlert) SetNotificationChannels(v []string) {
	x.NotificationChannels = v
}

func (x *AuditAlert) SetThreshold(v int32) {
	x.Threshold = &v
}

func (x *AuditAlert) SetTimeWindowMinutes(v int32) {
	x.TimeWindowMinutes = &v
}

func (x *AuditAlert) HasName() bool {
	if x == nil {
		return false
	}
	return x.Name != nil
}

func (x *AuditAlert) HasSeverity() bool {
	if x == nil {
		return false
	}
	return x.Severity != nil
}

func (x *AuditAlert) HasThreshold() bool {
	if x == nil {
		return false
	}
	return x.Threshold != nil
}

func (x *AuditAlert) HasTimeWindowMinutes() bool {
	if x == nil {
		return false
	}
	return x.TimeWindowMinutes != nil
}

func (x *AuditAlert) ClearName() {
	x.Name = nil
}

func (x *AuditAlert) ClearSeverity() {
	x.Severity = nil
}

func (x *AuditAlert) ClearThreshold() {
	x.Threshold = nil
}

func (x *AuditAlert) ClearTimeWindowMinutes() {
	x.TimeWindowMinutes = nil
}

type AuditAlert_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Alert name
	Name *string
	// Event patterns to match
	EventPatterns []string
	// Alert severity level
	Severity *string
	// Notification channels for this alert
	NotificationChannels []string
	// Alert threshold (if applicable)
	Threshold *int32
	// Time window for threshold evaluation in minutes
	TimeWindowMinutes *int32
}

func (b0 AuditAlert_builder) Build() *AuditAlert {
	m0 := &AuditAlert{}
	b, x := &b0, m0
	_, _ = b, x
	x.Name = b.Name
	x.EventPatterns = b.EventPatterns
	x.Severity = b.Severity
	x.NotificationChannels = b.NotificationChannels
	x.Threshold = b.Threshold
	x.TimeWindowMinutes = b.TimeWindowMinutes
	return m0
}

type HealthCheckConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Health check path
	Path *string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// Health check port
	Port *int32 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	// Health check protocol (HTTP, HTTPS, TCP)
	Protocol *string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	// Health check interval in seconds
	IntervalSeconds *int32 `protobuf:"varint,4,opt,name=interval_seconds,json=intervalSeconds" json:"interval_seconds,omitempty"`
	// Health check timeout in seconds
	TimeoutSeconds *int32 `protobuf:"varint,5,opt,name=timeout_seconds,json=timeoutSeconds" json:"timeout_seconds,omitempty"`
	// Healthy threshold
	HealthyThreshold *int32 `protobuf:"varint,6,opt,name=healthy_threshold,json=healthyThreshold" json:"healthy_threshold,omitempty"`
	// Unhealthy threshold
	UnhealthyThreshold *int32 `protobuf:"varint,7,opt,name=unhealthy_threshold,json=unhealthyThreshold" json:"unhealthy_threshold,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *HealthCheckConfig) Reset() {
	*x = HealthCheckConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckConfig) ProtoMessage() {}

func (x *HealthCheckConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *HealthCheckConfig) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *HealthCheckConfig) GetPort() int32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return 0
}

func (x *HealthCheckConfig) GetProtocol() string {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return ""
}

func (x *HealthCheckConfig) GetIntervalSeconds() int32 {
	if x != nil && x.IntervalSeconds != nil {
		return *x.IntervalSeconds
	}
	return 0
}

func (x *HealthCheckConfig) GetTimeoutSeconds() int32 {
	if x != nil && x.TimeoutSeconds != nil {
		return *x.TimeoutSeconds
	}
	return 0
}

func (x *HealthCheckConfig) GetHealthyThreshold() int32 {
	if x != nil && x.HealthyThreshold != nil {
		return *x.HealthyThreshold
	}
	return 0
}

func (x *HealthCheckConfig) GetUnhealthyThreshold() int32 {
	if x != nil && x.UnhealthyThreshold != nil {
		return *x.UnhealthyThreshold
	}
	return 0
}

func (x *HealthCheckConfig) SetPath(v string) {
	x.Path = &v
}

func (x *HealthCheckConfig) SetPort(v int32) {
	x.Port = &v
}

func (x *HealthCheckConfig) SetProtocol(v string) {
	x.Protocol = &v
}

func (x *HealthCheckConfig) SetIntervalSeconds(v int32) {
	x.IntervalSeconds = &v
}

func (x *HealthCheckConfig) SetTimeoutSeconds(v int32) {
	x.TimeoutSeconds = &v
}

func (x *HealthCheckConfig) SetHealthyThreshold(v int32) {
	x.HealthyThreshold = &v
}

func (x *HealthCheckConfig) SetUnhealthyThreshold(v int32) {
	x.UnhealthyThreshold = &v
}

func (x *HealthCheckConfig) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *HealthCheckConfig) HasPort() bool {
	if x == nil {
		return false
	}
	return x.Port != nil
}

func (x *HealthCheckConfig) HasProtocol() bool {
	if x == nil {
		return false
	}
	return x.Protocol != nil
}

func (x *HealthCheckConfig) HasIntervalSeconds() bool {
	if x == nil {
		return false
	}
	return x.IntervalSeconds != nil
}

func (x *HealthCheckConfig) HasTimeoutSeconds() bool {
	if x == nil {
		return false
	}
	return x.TimeoutSeconds != nil
}

func (x *HealthCheckConfig) HasHealthyThreshold() bool {
	if x == nil {
		return false
	}
	return x.HealthyThreshold != nil
}

func (x *HealthCheckConfig) HasUnhealthyThreshold() bool {
	if x == nil {
		return false
	}
	return x.UnhealthyThreshold != nil
}

func (x *HealthCheckConfig) ClearPath() {
	x.Path = nil
}

func (x *HealthCheckConfig) ClearPort() {
	x.Port = nil
}

func (x *HealthCheckConfig) ClearProtocol() {
	x.Protocol = nil
}

func (x *HealthCheckConfig) ClearIntervalSeconds() {
	x.IntervalSeconds = nil
}

func (x *HealthCheckConfig) ClearTimeoutSeconds() {
	x.TimeoutSeconds = nil
}

func (x *HealthCheckConfig) ClearHealthyThreshold() {
	x.HealthyThreshold = nil
}

func (x *HealthCheckConfig) ClearUnhealthyThreshold() {
	x.UnhealthyThreshold = nil
}

type HealthCheckConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Health check path
	Path *string
	// Health check port
	Port *int32
	// Health check protocol (HTTP, HTTPS, TCP)
	Protocol *string
	// Health check interval in seconds
	IntervalSeconds *int32
	// Health check timeout in seconds
	TimeoutSeconds *int32
	// Healthy threshold
	HealthyThreshold *int32
	// Unhealthy threshold
	UnhealthyThreshold *int32
}

func (b0 HealthCheckConfig_builder) Build() *HealthCheckConfig {
	m0 := &HealthCheckConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.Path = b.Path
	x.Port = b.Port
	x.Protocol = b.Protocol
	x.IntervalSeconds = b.IntervalSeconds
	x.TimeoutSeconds = b.TimeoutSeconds
	x.HealthyThreshold = b.HealthyThreshold
	x.UnhealthyThreshold = b.UnhealthyThreshold
	return m0
}

type SSLConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// SSL certificate ARN or ID
	CertificateId *string `protobuf:"bytes,1,opt,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
	// SSL policy
	SslPolicy *string `protobuf:"bytes,2,opt,name=ssl_policy,json=sslPolicy" json:"ssl_policy,omitempty"`
	// Whether to redirect HTTP to HTTPS
	RedirectHttp *bool `protobuf:"varint,3,opt,name=redirect_http,json=redirectHttp" json:"redirect_http,omitempty"`
	// Minimum TLS version
	MinTlsVersion *string `protobuf:"bytes,4,opt,name=min_tls_version,json=minTlsVersion" json:"min_tls_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSLConfig) Reset() {
	*x = SSLConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSLConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSLConfig) ProtoMessage() {}

func (x *SSLConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SSLConfig) GetCertificateId() string {
	if x != nil && x.CertificateId != nil {
		return *x.CertificateId
	}
	return ""
}

func (x *SSLConfig) GetSslPolicy() string {
	if x != nil && x.SslPolicy != nil {
		return *x.SslPolicy
	}
	return ""
}

func (x *SSLConfig) GetRedirectHttp() bool {
	if x != nil && x.RedirectHttp != nil {
		return *x.RedirectHttp
	}
	return false
}

func (x *SSLConfig) GetMinTlsVersion() string {
	if x != nil && x.MinTlsVersion != nil {
		return *x.MinTlsVersion
	}
	return ""
}

func (x *SSLConfig) SetCertificateId(v string) {
	x.CertificateId = &v
}

func (x *SSLConfig) SetSslPolicy(v string) {
	x.SslPolicy = &v
}

func (x *SSLConfig) SetRedirectHttp(v bool) {
	x.RedirectHttp = &v
}

func (x *SSLConfig) SetMinTlsVersion(v string) {
	x.MinTlsVersion = &v
}

func (x *SSLConfig) HasCertificateId() bool {
	if x == nil {
		return false
	}
	return x.CertificateId != nil
}

func (x *SSLConfig) HasSslPolicy() bool {
	if x == nil {
		return false
	}
	return x.SslPolicy != nil
}

func (x *SSLConfig) HasRedirectHttp() bool {
	if x == nil {
		return false
	}
	return x.RedirectHttp != nil
}

func (x *SSLConfig) HasMinTlsVersion() bool {
	if x == nil {
		return false
	}
	return x.MinTlsVersion != nil
}

func (x *SSLConfig) ClearCertificateId() {
	x.CertificateId = nil
}

func (x *SSLConfig) ClearSslPolicy() {
	x.SslPolicy = nil
}

func (x *SSLConfig) ClearRedirectHttp() {
	x.RedirectHttp = nil
}

func (x *SSLConfig) ClearMinTlsVersion() {
	x.MinTlsVersion = nil
}

type SSLConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// SSL certificate ARN or ID
	CertificateId *string
	// SSL policy
	SslPolicy *string
	// Whether to redirect HTTP to HTTPS
	RedirectHttp *bool
	// Minimum TLS version
	MinTlsVersion *string
}

func (b0 SSLConfig_builder) Build() *SSLConfig {
	m0 := &SSLConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.CertificateId = b.CertificateId
	x.SslPolicy = b.SslPolicy
	x.RedirectHttp = b.RedirectHttp
	x.MinTlsVersion = b.MinTlsVersion
	return m0
}

type CacheBehavior struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Path pattern for this behavior
	PathPattern *string `protobuf:"bytes,1,opt,name=path_pattern,json=pathPattern" json:"path_pattern,omitempty"`
	// Cache TTL in seconds
	TtlSeconds *int64 `protobuf:"varint,2,opt,name=ttl_seconds,json=ttlSeconds" json:"ttl_seconds,omitempty"`
	// Whether to compress objects
	Compress *bool `protobuf:"varint,3,opt,name=compress" json:"compress,omitempty"`
	// Allowed HTTP methods
	AllowedMethods []string `protobuf:"bytes,4,rep,name=allowed_methods,json=allowedMethods" json:"allowed_methods,omitempty"`
	// Cache key policy
	CacheKey      *CacheKeyPolicy `protobuf:"bytes,5,opt,name=cache_key,json=cacheKey" json:"cache_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CacheBehavior) Reset() {
	*x = CacheBehavior{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CacheBehavior) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CacheBehavior) ProtoMessage() {}

func (x *CacheBehavior) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CacheBehavior) GetPathPattern() string {
	if x != nil && x.PathPattern != nil {
		return *x.PathPattern
	}
	return ""
}

func (x *CacheBehavior) GetTtlSeconds() int64 {
	if x != nil && x.TtlSeconds != nil {
		return *x.TtlSeconds
	}
	return 0
}

func (x *CacheBehavior) GetCompress() bool {
	if x != nil && x.Compress != nil {
		return *x.Compress
	}
	return false
}

func (x *CacheBehavior) GetAllowedMethods() []string {
	if x != nil {
		return x.AllowedMethods
	}
	return nil
}

func (x *CacheBehavior) GetCacheKey() *CacheKeyPolicy {
	if x != nil {
		return x.CacheKey
	}
	return nil
}

func (x *CacheBehavior) SetPathPattern(v string) {
	x.PathPattern = &v
}

func (x *CacheBehavior) SetTtlSeconds(v int64) {
	x.TtlSeconds = &v
}

func (x *CacheBehavior) SetCompress(v bool) {
	x.Compress = &v
}

func (x *CacheBehavior) SetAllowedMethods(v []string) {
	x.AllowedMethods = v
}

func (x *CacheBehavior) SetCacheKey(v *CacheKeyPolicy) {
	x.CacheKey = v
}

func (x *CacheBehavior) HasPathPattern() bool {
	if x == nil {
		return false
	}
	return x.PathPattern != nil
}

func (x *CacheBehavior) HasTtlSeconds() bool {
	if x == nil {
		return false
	}
	return x.TtlSeconds != nil
}

func (x *CacheBehavior) HasCompress() bool {
	if x == nil {
		return false
	}
	return x.Compress != nil
}

func (x *CacheBehavior) HasCacheKey() bool {
	if x == nil {
		return false
	}
	return x.CacheKey != nil
}

func (x *CacheBehavior) ClearPathPattern() {
	x.PathPattern = nil
}

func (x *CacheBehavior) ClearTtlSeconds() {
	x.TtlSeconds = nil
}

func (x *CacheBehavior) ClearCompress() {
	x.Compress = nil
}

func (x *CacheBehavior) ClearCacheKey() {
	x.CacheKey = nil
}

type CacheBehavior_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Path pattern for this behavior
	PathPattern *string
	// Cache TTL in seconds
	TtlSeconds *int64
	// Whether to compress objects
	Compress *bool
	// Allowed HTTP methods
	AllowedMethods []string
	// Cache key policy
	CacheKey *CacheKeyPolicy
}

func (b0 CacheBehavior_builder) Build() *CacheBehavior {
	m0 := &CacheBehavior{}
	b, x := &b0, m0
	_, _ = b, x
	x.PathPattern = b.PathPattern
	x.TtlSeconds = b.TtlSeconds
	x.Compress = b.Compress
	x.AllowedMethods = b.AllowedMethods
	x.CacheKey = b.CacheKey
	return m0
}

type OriginConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Origin domain name
	DomainName *string `protobuf:"bytes,1,opt,name=domain_name,json=domainName" json:"domain_name,omitempty"`
	// Origin path
	OriginPath *string `protobuf:"bytes,2,opt,name=origin_path,json=originPath" json:"origin_path,omitempty"`
	// Origin protocol policy
	ProtocolPolicy *string `protobuf:"bytes,3,opt,name=protocol_policy,json=protocolPolicy" json:"protocol_policy,omitempty"`
	// Custom headers to send to origin
	CustomHeaders []*types.KeyValue `protobuf:"bytes,4,rep,name=custom_headers,json=customHeaders" json:"custom_headers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OriginConfig) Reset() {
	*x = OriginConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OriginConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OriginConfig) ProtoMessage() {}

func (x *OriginConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *OriginConfig) GetDomainName() string {
	if x != nil && x.DomainName != nil {
		return *x.DomainName
	}
	return ""
}

func (x *OriginConfig) GetOriginPath() string {
	if x != nil && x.OriginPath != nil {
		return *x.OriginPath
	}
	return ""
}

func (x *OriginConfig) GetProtocolPolicy() string {
	if x != nil && x.ProtocolPolicy != nil {
		return *x.ProtocolPolicy
	}
	return ""
}

func (x *OriginConfig) GetCustomHeaders() []*types.KeyValue {
	if x != nil {
		return x.CustomHeaders
	}
	return nil
}

func (x *OriginConfig) SetDomainName(v string) {
	x.DomainName = &v
}

func (x *OriginConfig) SetOriginPath(v string) {
	x.OriginPath = &v
}

func (x *OriginConfig) SetProtocolPolicy(v string) {
	x.ProtocolPolicy = &v
}

func (x *OriginConfig) SetCustomHeaders(v []*types.KeyValue) {
	x.CustomHeaders = v
}

func (x *OriginConfig) HasDomainName() bool {
	if x == nil {
		return false
	}
	return x.DomainName != nil
}

func (x *OriginConfig) HasOriginPath() bool {
	if x == nil {
		return false
	}
	return x.OriginPath != nil
}

func (x *OriginConfig) HasProtocolPolicy() bool {
	if x == nil {
		return false
	}
	return x.ProtocolPolicy != nil
}

func (x *OriginConfig) ClearDomainName() {
	x.DomainName = nil
}

func (x *OriginConfig) ClearOriginPath() {
	x.OriginPath = nil
}

func (x *OriginConfig) ClearProtocolPolicy() {
	x.ProtocolPolicy = nil
}

type OriginConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Origin domain name
	DomainName *string
	// Origin path
	OriginPath *string
	// Origin protocol policy
	ProtocolPolicy *string
	// Custom headers to send to origin
	CustomHeaders []*types.KeyValue
}

func (b0 OriginConfig_builder) Build() *OriginConfig {
	m0 := &OriginConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.DomainName = b.DomainName
	x.OriginPath = b.OriginPath
	x.ProtocolPolicy = b.ProtocolPolicy
	x.CustomHeaders = b.CustomHeaders
	return m0
}

type DNSConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// DNS provider
	Provider *string `protobuf:"bytes,1,opt,name=provider" json:"provider,omitempty"`
	// DNS zone ID
	ZoneId *string `protobuf:"bytes,2,opt,name=zone_id,json=zoneId" json:"zone_id,omitempty"`
	// DNS records
	Records []*DNSRecord `protobuf:"bytes,3,rep,name=records" json:"records,omitempty"`
	// TTL for DNS records
	Ttl           *int32 `protobuf:"varint,4,opt,name=ttl" json:"ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DNSConfig) Reset() {
	*x = DNSConfig{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSConfig) ProtoMessage() {}

func (x *DNSConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DNSConfig) GetProvider() string {
	if x != nil && x.Provider != nil {
		return *x.Provider
	}
	return ""
}

func (x *DNSConfig) GetZoneId() string {
	if x != nil && x.ZoneId != nil {
		return *x.ZoneId
	}
	return ""
}

func (x *DNSConfig) GetRecords() []*DNSRecord {
	if x != nil {
		return x.Records
	}
	return nil
}

func (x *DNSConfig) GetTtl() int32 {
	if x != nil && x.Ttl != nil {
		return *x.Ttl
	}
	return 0
}

func (x *DNSConfig) SetProvider(v string) {
	x.Provider = &v
}

func (x *DNSConfig) SetZoneId(v string) {
	x.ZoneId = &v
}

func (x *DNSConfig) SetRecords(v []*DNSRecord) {
	x.Records = v
}

func (x *DNSConfig) SetTtl(v int32) {
	x.Ttl = &v
}

func (x *DNSConfig) HasProvider() bool {
	if x == nil {
		return false
	}
	return x.Provider != nil
}

func (x *DNSConfig) HasZoneId() bool {
	if x == nil {
		return false
	}
	return x.ZoneId != nil
}

func (x *DNSConfig) HasTtl() bool {
	if x == nil {
		return false
	}
	return x.Ttl != nil
}

func (x *DNSConfig) ClearProvider() {
	x.Provider = nil
}

func (x *DNSConfig) ClearZoneId() {
	x.ZoneId = nil
}

func (x *DNSConfig) ClearTtl() {
	x.Ttl = nil
}

type DNSConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// DNS provider
	Provider *string
	// DNS zone ID
	ZoneId *string
	// DNS records
	Records []*DNSRecord
	// TTL for DNS records
	Ttl *int32
}

func (b0 DNSConfig_builder) Build() *DNSConfig {
	m0 := &DNSConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.Provider = b.Provider
	x.ZoneId = b.ZoneId
	x.Records = b.Records
	x.Ttl = b.Ttl
	return m0
}

type DNSRecord struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Record type (A, CNAME, TXT, etc.)
	Type *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Record name
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Record value
	Value *string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	// Record TTL
	Ttl *int32 `protobuf:"varint,4,opt,name=ttl" json:"ttl,omitempty"`
	// Record priority (for MX records)
	Priority      *int32 `protobuf:"varint,5,opt,name=priority" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DNSRecord) Reset() {
	*x = DNSRecord{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSRecord) ProtoMessage() {}

func (x *DNSRecord) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DNSRecord) GetType() string {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return ""
}

func (x *DNSRecord) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *DNSRecord) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *DNSRecord) GetTtl() int32 {
	if x != nil && x.Ttl != nil {
		return *x.Ttl
	}
	return 0
}

func (x *DNSRecord) GetPriority() int32 {
	if x != nil && x.Priority != nil {
		return *x.Priority
	}
	return 0
}

func (x *DNSRecord) SetType(v string) {
	x.Type = &v
}

func (x *DNSRecord) SetName(v string) {
	x.Name = &v
}

func (x *DNSRecord) SetValue(v string) {
	x.Value = &v
}

func (x *DNSRecord) SetTtl(v int32) {
	x.Ttl = &v
}

func (x *DNSRecord) SetPriority(v int32) {
	x.Priority = &v
}

func (x *DNSRecord) HasType() bool {
	if x == nil {
		return false
	}
	return x.Type != nil
}

func (x *DNSRecord) HasName() bool {
	if x == nil {
		return false
	}
	return x.Name != nil
}

func (x *DNSRecord) HasValue() bool {
	if x == nil {
		return false
	}
	return x.Value != nil
}

func (x *DNSRecord) HasTtl() bool {
	if x == nil {
		return false
	}
	return x.Ttl != nil
}

func (x *DNSRecord) HasPriority() bool {
	if x == nil {
		return false
	}
	return x.Priority != nil
}

func (x *DNSRecord) ClearType() {
	x.Type = nil
}

func (x *DNSRecord) ClearName() {
	x.Name = nil
}

func (x *DNSRecord) ClearValue() {
	x.Value = nil
}

func (x *DNSRecord) ClearTtl() {
	x.Ttl = nil
}

func (x *DNSRecord) ClearPriority() {
	x.Priority = nil
}

type DNSRecord_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Record type (A, CNAME, TXT, etc.)
	Type *string
	// Record name
	Name *string
	// Record value
	Value *string
	// Record TTL
	Ttl *int32
	// Record priority (for MX records)
	Priority *int32
}

func (b0 DNSRecord_builder) Build() *DNSRecord {
	m0 := &DNSRecord{}
	b, x := &b0, m0
	_, _ = b, x
	x.Type = b.Type
	x.Name = b.Name
	x.Value = b.Value
	x.Ttl = b.Ttl
	x.Priority = b.Priority
	return m0
}

type CacheKeyPolicy struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Whether to include query strings in cache key
	IncludeQueryStrings *bool `protobuf:"varint,1,opt,name=include_query_strings,json=includeQueryStrings" json:"include_query_strings,omitempty"`
	// Query string whitelist
	QueryStringWhitelist []string `protobuf:"bytes,2,rep,name=query_string_whitelist,json=queryStringWhitelist" json:"query_string_whitelist,omitempty"`
	// Whether to include headers in cache key
	IncludeHeaders *bool `protobuf:"varint,3,opt,name=include_headers,json=includeHeaders" json:"include_headers,omitempty"`
	// Header whitelist
	HeaderWhitelist []string `protobuf:"bytes,4,rep,name=header_whitelist,json=headerWhitelist" json:"header_whitelist,omitempty"`
	// Whether to include cookies in cache key
	IncludeCookies *bool `protobuf:"varint,5,opt,name=include_cookies,json=includeCookies" json:"include_cookies,omitempty"`
	// Cookie whitelist
	CookieWhitelist []string `protobuf:"bytes,6,rep,name=cookie_whitelist,json=cookieWhitelist" json:"cookie_whitelist,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *CacheKeyPolicy) Reset() {
	*x = CacheKeyPolicy{}
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CacheKeyPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CacheKeyPolicy) ProtoMessage() {}

func (x *CacheKeyPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CacheKeyPolicy) GetIncludeQueryStrings() bool {
	if x != nil && x.IncludeQueryStrings != nil {
		return *x.IncludeQueryStrings
	}
	return false
}

func (x *CacheKeyPolicy) GetQueryStringWhitelist() []string {
	if x != nil {
		return x.QueryStringWhitelist
	}
	return nil
}

func (x *CacheKeyPolicy) GetIncludeHeaders() bool {
	if x != nil && x.IncludeHeaders != nil {
		return *x.IncludeHeaders
	}
	return false
}

func (x *CacheKeyPolicy) GetHeaderWhitelist() []string {
	if x != nil {
		return x.HeaderWhitelist
	}
	return nil
}

func (x *CacheKeyPolicy) GetIncludeCookies() bool {
	if x != nil && x.IncludeCookies != nil {
		return *x.IncludeCookies
	}
	return false
}

func (x *CacheKeyPolicy) GetCookieWhitelist() []string {
	if x != nil {
		return x.CookieWhitelist
	}
	return nil
}

func (x *CacheKeyPolicy) SetIncludeQueryStrings(v bool) {
	x.IncludeQueryStrings = &v
}

func (x *CacheKeyPolicy) SetQueryStringWhitelist(v []string) {
	x.QueryStringWhitelist = v
}

func (x *CacheKeyPolicy) SetIncludeHeaders(v bool) {
	x.IncludeHeaders = &v
}

func (x *CacheKeyPolicy) SetHeaderWhitelist(v []string) {
	x.HeaderWhitelist = v
}

func (x *CacheKeyPolicy) SetIncludeCookies(v bool) {
	x.IncludeCookies = &v
}

func (x *CacheKeyPolicy) SetCookieWhitelist(v []string) {
	x.CookieWhitelist = v
}

func (x *CacheKeyPolicy) HasIncludeQueryStrings() bool {
	if x == nil {
		return false
	}
	return x.IncludeQueryStrings != nil
}

func (x *CacheKeyPolicy) HasIncludeHeaders() bool {
	if x == nil {
		return false
	}
	return x.IncludeHeaders != nil
}

func (x *CacheKeyPolicy) HasIncludeCookies() bool {
	if x == nil {
		return false
	}
	return x.IncludeCookies != nil
}

func (x *CacheKeyPolicy) ClearIncludeQueryStrings() {
	x.IncludeQueryStrings = nil
}

func (x *CacheKeyPolicy) ClearIncludeHeaders() {
	x.IncludeHeaders = nil
}

func (x *CacheKeyPolicy) ClearIncludeCookies() {
	x.IncludeCookies = nil
}

type CacheKeyPolicy_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Whether to include query strings in cache key
	IncludeQueryStrings *bool
	// Query string whitelist
	QueryStringWhitelist []string
	// Whether to include headers in cache key
	IncludeHeaders *bool
	// Header whitelist
	HeaderWhitelist []string
	// Whether to include cookies in cache key
	IncludeCookies *bool
	// Cookie whitelist
	CookieWhitelist []string
}

func (b0 CacheKeyPolicy_builder) Build() *CacheKeyPolicy {
	m0 := &CacheKeyPolicy{}
	b, x := &b0, m0
	_, _ = b, x
	x.IncludeQueryStrings = b.IncludeQueryStrings
	x.QueryStringWhitelist = b.QueryStringWhitelist
	x.IncludeHeaders = b.IncludeHeaders
	x.HeaderWhitelist = b.HeaderWhitelist
	x.IncludeCookies = b.IncludeCookies
	x.CookieWhitelist = b.CookieWhitelist
	return m0
}

var File_pkg_organization_proto_types_tenant_isolation_proto protoreflect.FileDescriptor

const file_pkg_organization_proto_types_tenant_isolation_proto_rawDesc = "" +
	"\n" +
	"3pkg/organization/proto/types/tenant_isolation.proto\x12\x17gcommon.v1.organization\x1a!google/protobuf/go_features.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a2pkg/organization/proto/enums/isolation_level.proto\x1a&pkg/common/proto/types/key_value.proto\"\xba\x06\n" +
	"\x0fTenantIsolation\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12=\n" +
	"\x05level\x18\x02 \x01(\x0e2'.gcommon.v1.organization.IsolationLevelR\x05level\x12F\n" +
	"\bdatabase\x18\x03 \x01(\v2*.gcommon.v1.organization.DatabaseIsolationR\bdatabase\x12C\n" +
	"\anetwork\x18\x04 \x01(\v2).gcommon.v1.organization.NetworkIsolationR\anetwork\x12C\n" +
	"\astorage\x18\x05 \x01(\v2).gcommon.v1.organization.StorageIsolationR\astorage\x12C\n" +
	"\acompute\x18\x06 \x01(\v2).gcommon.v1.organization.ComputeIsolationR\acompute\x12I\n" +
	"\n" +
	"encryption\x18\a \x01(\v2).gcommon.v1.organization.EncryptionConfigR\n" +
	"encryption\x12M\n" +
	"\x0eaccess_control\x18\b \x01(\v2&.gcommon.v1.organization.AccessControlR\raccessControl\x12:\n" +
	"\x05audit\x18\t \x01(\v2$.gcommon.v1.organization.AuditConfigR\x05audit\x12;\n" +
	"\bmetadata\x18\n" +
	" \x03(\v2\x1b.gcommon.v1.common.KeyValueB\x02(\x01R\bmetadata\x12=\n" +
	"\n" +
	"created_at\x18\v \x01(\v2\x1a.google.protobuf.TimestampB\x02(\x01R\tcreatedAt\x12=\n" +
	"\n" +
	"updated_at\x18\f \x01(\v2\x1a.google.protobuf.TimestampB\x02(\x01R\tupdatedAt\x12#\n" +
	"\rconfigured_by\x18\r \x01(\tR\fconfiguredBy\"\xa9\x03\n" +
	"\x11DatabaseIsolation\x12+\n" +
	"\x11database_instance\x18\x01 \x01(\tR\x10databaseInstance\x12\x1f\n" +
	"\vschema_name\x18\x02 \x01(\tR\n" +
	"schemaName\x12L\n" +
	"\x11connection_params\x18\x03 \x03(\v2\x1b.gcommon.v1.common.KeyValueB\x02(\x01R\x10connectionParams\x12-\n" +
	"\x12dedicated_database\x18\x04 \x01(\bR\x11dedicatedDatabase\x12=\n" +
	"\x06backup\x18\x05 \x01(\v2%.gcommon.v1.organization.BackupConfigR\x06backup\x12-\n" +
	"\x12allowed_operations\x18\x06 \x03(\tR\x11allowedOperations\x12'\n" +
	"\x0fmax_connections\x18\a \x01(\x05R\x0emaxConnections\x122\n" +
	"\x15query_timeout_seconds\x18\b \x01(\x05R\x13queryTimeoutSeconds\"\xae\x03\n" +
	"\x10NetworkIsolation\x12\x15\n" +
	"\x06vpc_id\x18\x01 \x01(\tR\x05vpcId\x12\x1b\n" +
	"\tsubnet_id\x18\x02 \x01(\tR\bsubnetId\x12,\n" +
	"\x12security_group_ids\x18\x03 \x03(\tR\x10securityGroupIds\x12D\n" +
	"\tacl_rules\x18\x04 \x03(\v2'.gcommon.v1.organization.NetworkACLRuleR\baclRules\x12+\n" +
	"\x11dedicated_network\x18\x05 \x01(\bR\x10dedicatedNetwork\x12P\n" +
	"\rload_balancer\x18\x06 \x01(\v2+.gcommon.v1.organization.LoadBalancerConfigR\floadBalancer\x124\n" +
	"\x03cdn\x18\a \x01(\v2\".gcommon.v1.organization.CDNConfigR\x03cdn\x12=\n" +
	"\x06domain\x18\b \x01(\v2%.gcommon.v1.organization.DomainConfigR\x06domain\"\x9a\x03\n" +
	"\x10StorageIsolation\x12%\n" +
	"\x0estorage_bucket\x18\x01 \x01(\tR\rstorageBucket\x12\x1f\n" +
	"\vpath_prefix\x18\x02 \x01(\tR\n" +
	"pathPrefix\x12+\n" +
	"\x11dedicated_storage\x18\x03 \x01(\bR\x10dedicatedStorage\x12J\n" +
	"\n" +
	"encryption\x18\x04 \x01(\v2*.gcommon.v1.organization.StorageEncryptionR\n" +
	"encryption\x12B\n" +
	"\bpolicies\x18\x05 \x03(\v2&.gcommon.v1.organization.StoragePolicyR\bpolicies\x12D\n" +
	"\x06backup\x18\x06 \x01(\v2,.gcommon.v1.organization.StorageBackupConfigR\x06backup\x12;\n" +
	"\x05quota\x18\a \x01(\v2%.gcommon.v1.organization.StorageQuotaR\x05quota\"\x95\x03\n" +
	"\x10ComputeIsolation\x12)\n" +
	"\x10compute_instance\x18\x01 \x01(\tR\x0fcomputeInstance\x12\x1c\n" +
	"\tnamespace\x18\x02 \x01(\tR\tnamespace\x128\n" +
	"\x03cpu\x18\x03 \x01(\v2&.gcommon.v1.organization.CPUAllocationR\x03cpu\x12A\n" +
	"\x06memory\x18\x04 \x01(\v2).gcommon.v1.organization.MemoryAllocationR\x06memory\x12+\n" +
	"\x11dedicated_compute\x18\x05 \x01(\bR\x10dedicatedCompute\x12?\n" +
	"\x06limits\x18\x06 \x01(\v2'.gcommon.v1.organization.ResourceLimitsR\x06limits\x12M\n" +
	"\fauto_scaling\x18\a \x01(\v2*.gcommon.v1.organization.AutoScalingConfigR\vautoScaling\"\x85\x02\n" +
	"\x10EncryptionConfig\x12,\n" +
	"\x12encryption_at_rest\x18\x01 \x01(\bR\x10encryptionAtRest\x122\n" +
	"\x15encryption_in_transit\x18\x02 \x01(\bR\x13encryptionInTransit\x124\n" +
	"\x16key_management_service\x18\x03 \x01(\tR\x14keyManagementService\x12&\n" +
	"\x0fcustomer_key_id\x18\x04 \x01(\tR\rcustomerKeyId\x121\n" +
	"\x14encryption_algorithm\x18\x05 \x01(\tR\x13encryptionAlgorithm\"\xba\x02\n" +
	"\rAccessControl\x12!\n" +
	"\fip_whitelist\x18\x01 \x03(\tR\vipWhitelist\x12!\n" +
	"\fauth_methods\x18\x02 \x03(\tR\vauthMethods\x12'\n" +
	"\x0fsession_timeout\x18\x03 \x01(\x05R\x0esessionTimeout\x126\n" +
	"\x17max_concurrent_sessions\x18\x04 \x01(\x05R\x15maxConcurrentSessions\x12+\n" +
	"\x11allowed_countries\x18\x05 \x03(\tR\x10allowedCountries\x12U\n" +
	"\x11time_restrictions\x18\x06 \x03(\v2(.gcommon.v1.organization.TimeRestrictionR\x10timeRestrictions\"\x9a\x02\n" +
	"\vAuditConfig\x12#\n" +
	"\raudit_enabled\x18\x01 \x01(\bR\fauditEnabled\x12%\n" +
	"\x0eretention_days\x18\x02 \x01(\x05R\rretentionDays\x12)\n" +
	"\x10storage_location\x18\x03 \x01(\tR\x0fstorageLocation\x12%\n" +
	"\x0eaudited_events\x18\x04 \x03(\tR\rauditedEvents\x120\n" +
	"\x14real_time_monitoring\x18\x05 \x01(\bR\x12realTimeMonitoring\x12;\n" +
	"\x06alerts\x18\x06 \x03(\v2#.gcommon.v1.organization.AuditAlertR\x06alerts\"\xcd\x01\n" +
	"\fBackupConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1c\n" +
	"\tfrequency\x18\x02 \x01(\tR\tfrequency\x12%\n" +
	"\x0eretention_days\x18\x03 \x01(\x05R\rretentionDays\x12)\n" +
	"\x10storage_location\x18\x04 \x01(\tR\x0fstorageLocation\x123\n" +
	"\x16point_in_time_recovery\x18\x05 \x01(\bR\x13pointInTimeRecovery\"\xb9\x01\n" +
	"\x0eNetworkACLRule\x12\x16\n" +
	"\x06action\x18\x01 \x01(\tR\x06action\x12\x16\n" +
	"\x06source\x18\x02 \x01(\tR\x06source\x12 \n" +
	"\vdestination\x18\x03 \x01(\tR\vdestination\x12\x1a\n" +
	"\bprotocol\x18\x04 \x01(\tR\bprotocol\x12\x1d\n" +
	"\n" +
	"port_range\x18\x05 \x01(\tR\tportRange\x12\x1a\n" +
	"\bpriority\x18\x06 \x01(\x05R\bpriority\"\xcb\x01\n" +
	"\x12LoadBalancerConfig\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x1c\n" +
	"\talgorithm\x18\x02 \x01(\tR\talgorithm\x12M\n" +
	"\fhealth_check\x18\x03 \x01(\v2*.gcommon.v1.organization.HealthCheckConfigR\vhealthCheck\x124\n" +
	"\x03ssl\x18\x04 \x01(\v2\".gcommon.v1.organization.SSLConfigR\x03ssl\"\xe0\x01\n" +
	"\tCDNConfig\x12\x1a\n" +
	"\bprovider\x18\x01 \x01(\tR\bprovider\x12'\n" +
	"\x0fdistribution_id\x18\x02 \x01(\tR\x0edistributionId\x12O\n" +
	"\x0fcache_behaviors\x18\x03 \x03(\v2&.gcommon.v1.organization.CacheBehaviorR\x0ecacheBehaviors\x12=\n" +
	"\x06origin\x18\x04 \x01(\v2%.gcommon.v1.organization.OriginConfigR\x06origin\"\xbb\x01\n" +
	"\fDomainConfig\x12\x1f\n" +
	"\vdomain_name\x18\x01 \x01(\tR\n" +
	"domainName\x12'\n" +
	"\x0fssl_certificate\x18\x02 \x01(\tR\x0esslCertificate\x124\n" +
	"\x03dns\x18\x03 \x01(\v2\".gcommon.v1.organization.DNSConfigR\x03dns\x12+\n" +
	"\x11validation_status\x18\x04 \x01(\tR\x10validationStatus\"\x80\x01\n" +
	"\x11StorageEncryption\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x15\n" +
	"\x06key_id\x18\x02 \x01(\tR\x05keyId\x12\x1f\n" +
	"\vserver_side\x18\x03 \x01(\bR\n" +
	"serverSide\x12\x1f\n" +
	"\vclient_side\x18\x04 \x01(\bR\n" +
	"clientSide\"\x91\x01\n" +
	"\rStoragePolicy\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n" +
	"\tstatement\x18\x02 \x01(\tR\tstatement\x12\x16\n" +
	"\x06effect\x18\x03 \x01(\tR\x06effect\x12\x1c\n" +
	"\tresources\x18\x04 \x03(\tR\tresources\x12\x18\n" +
	"\aactions\x18\x05 \x03(\tR\aactions\"\xc4\x01\n" +
	"\x13StorageBackupConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1a\n" +
	"\bschedule\x18\x02 \x01(\tR\bschedule\x12%\n" +
	"\x0eretention_days\x18\x03 \x01(\x05R\rretentionDays\x12!\n" +
	"\fcross_region\x18\x04 \x01(\bR\vcrossRegion\x12-\n" +
	"\x12encryption_enabled\x18\x05 \x01(\bR\x11encryptionEnabled\"\xbe\x01\n" +
	"\fStorageQuota\x12$\n" +
	"\x0emax_size_bytes\x18\x01 \x01(\x03R\fmaxSizeBytes\x12\x1f\n" +
	"\vmax_objects\x18\x02 \x01(\x03R\n" +
	"maxObjects\x125\n" +
	"\x17max_requests_per_second\x18\x03 \x01(\x05R\x14maxRequestsPerSecond\x120\n" +
	"\x14transfer_quota_bytes\x18\x04 \x01(\x03R\x12transferQuotaBytes\"\x96\x01\n" +
	"\rCPUAllocation\x12\x14\n" +
	"\x05cores\x18\x01 \x01(\x05R\x05cores\x12#\n" +
	"\rfrequency_mhz\x18\x02 \x01(\x05R\ffrequencyMhz\x12.\n" +
	"\x13usage_limit_percent\x18\x03 \x01(\x05R\x11usageLimitPercent\x12\x1a\n" +
	"\bpriority\x18\x04 \x01(\x05R\bpriority\"t\n" +
	"\x10MemoryAllocation\x12\x17\n" +
	"\asize_mb\x18\x01 \x01(\x03R\x06sizeMb\x12.\n" +
	"\x13usage_limit_percent\x18\x02 \x01(\x05R\x11usageLimitPercent\x12\x17\n" +
	"\aswap_mb\x18\x03 \x01(\x03R\x06swapMb\"\x81\x02\n" +
	"\x0eResourceLimits\x12&\n" +
	"\x0fmax_cpu_percent\x18\x01 \x01(\x05R\rmaxCpuPercent\x12\"\n" +
	"\rmax_memory_mb\x18\x02 \x01(\x03R\vmaxMemoryMb\x12\"\n" +
	"\rmax_disk_iops\x18\x03 \x01(\x05R\vmaxDiskIops\x12(\n" +
	"\x10max_network_mbps\x18\x04 \x01(\x05R\x0emaxNetworkMbps\x12#\n" +
	"\rmax_processes\x18\x05 \x01(\x05R\fmaxProcesses\x120\n" +
	"\x14max_file_descriptors\x18\x06 \x01(\x05R\x12maxFileDescriptors\"\xb5\x02\n" +
	"\x11AutoScalingConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12#\n" +
	"\rmin_instances\x18\x02 \x01(\x05R\fminInstances\x12#\n" +
	"\rmax_instances\x18\x03 \x01(\x05R\fmaxInstances\x12,\n" +
	"\x12target_cpu_percent\x18\x04 \x01(\x05R\x10targetCpuPercent\x122\n" +
	"\x15target_memory_percent\x18\x05 \x01(\x05R\x13targetMemoryPercent\x12*\n" +
	"\x11scale_up_cooldown\x18\x06 \x01(\x05R\x0fscaleUpCooldown\x12.\n" +
	"\x13scale_down_cooldown\x18\a \x01(\x05R\x11scaleDownCooldown\"\x87\x01\n" +
	"\x0fTimeRestriction\x12\x1e\n" +
	"\vday_of_week\x18\x01 \x01(\x05R\tdayOfWeek\x12\x1d\n" +
	"\n" +
	"start_time\x18\x02 \x01(\tR\tstartTime\x12\x19\n" +
	"\bend_time\x18\x03 \x01(\tR\aendTime\x12\x1a\n" +
	"\btimezone\x18\x04 \x01(\tR\btimezone\"\xe6\x01\n" +
	"\n" +
	"AuditAlert\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12%\n" +
	"\x0eevent_patterns\x18\x02 \x03(\tR\reventPatterns\x12\x1a\n" +
	"\bseverity\x18\x03 \x01(\tR\bseverity\x123\n" +
	"\x15notification_channels\x18\x04 \x03(\tR\x14notificationChannels\x12\x1c\n" +
	"\tthreshold\x18\x05 \x01(\x05R\tthreshold\x12.\n" +
	"\x13time_window_minutes\x18\x06 \x01(\x05R\x11timeWindowMinutes\"\x89\x02\n" +
	"\x11HealthCheckConfig\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\x12\n" +
	"\x04port\x18\x02 \x01(\x05R\x04port\x12\x1a\n" +
	"\bprotocol\x18\x03 \x01(\tR\bprotocol\x12)\n" +
	"\x10interval_seconds\x18\x04 \x01(\x05R\x0fintervalSeconds\x12'\n" +
	"\x0ftimeout_seconds\x18\x05 \x01(\x05R\x0etimeoutSeconds\x12+\n" +
	"\x11healthy_threshold\x18\x06 \x01(\x05R\x10healthyThreshold\x12/\n" +
	"\x13unhealthy_threshold\x18\a \x01(\x05R\x12unhealthyThreshold\"\x9e\x01\n" +
	"\tSSLConfig\x12%\n" +
	"\x0ecertificate_id\x18\x01 \x01(\tR\rcertificateId\x12\x1d\n" +
	"\n" +
	"ssl_policy\x18\x02 \x01(\tR\tsslPolicy\x12#\n" +
	"\rredirect_http\x18\x03 \x01(\bR\fredirectHttp\x12&\n" +
	"\x0fmin_tls_version\x18\x04 \x01(\tR\rminTlsVersion\"\xde\x01\n" +
	"\rCacheBehavior\x12!\n" +
	"\fpath_pattern\x18\x01 \x01(\tR\vpathPattern\x12\x1f\n" +
	"\vttl_seconds\x18\x02 \x01(\x03R\n" +
	"ttlSeconds\x12\x1a\n" +
	"\bcompress\x18\x03 \x01(\bR\bcompress\x12'\n" +
	"\x0fallowed_methods\x18\x04 \x03(\tR\x0eallowedMethods\x12D\n" +
	"\tcache_key\x18\x05 \x01(\v2'.gcommon.v1.organization.CacheKeyPolicyR\bcacheKey\"\xbd\x01\n" +
	"\fOriginConfig\x12\x1f\n" +
	"\vdomain_name\x18\x01 \x01(\tR\n" +
	"domainName\x12\x1f\n" +
	"\vorigin_path\x18\x02 \x01(\tR\n" +
	"originPath\x12'\n" +
	"\x0fprotocol_policy\x18\x03 \x01(\tR\x0eprotocolPolicy\x12B\n" +
	"\x0ecustom_headers\x18\x04 \x03(\v2\x1b.gcommon.v1.common.KeyValueR\rcustomHeaders\"\x90\x01\n" +
	"\tDNSConfig\x12\x1a\n" +
	"\bprovider\x18\x01 \x01(\tR\bprovider\x12\x17\n" +
	"\azone_id\x18\x02 \x01(\tR\x06zoneId\x12<\n" +
	"\arecords\x18\x03 \x03(\v2\".gcommon.v1.organization.DNSRecordR\arecords\x12\x10\n" +
	"\x03ttl\x18\x04 \x01(\x05R\x03ttl\"w\n" +
	"\tDNSRecord\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x03 \x01(\tR\x05value\x12\x10\n" +
	"\x03ttl\x18\x04 \x01(\x05R\x03ttl\x12\x1a\n" +
	"\bpriority\x18\x05 \x01(\x05R\bpriority\"\xa2\x02\n" +
	"\x0eCacheKeyPolicy\x122\n" +
	"\x15include_query_strings\x18\x01 \x01(\bR\x13includeQueryStrings\x124\n" +
	"\x16query_string_whitelist\x18\x02 \x03(\tR\x14queryStringWhitelist\x12'\n" +
	"\x0finclude_headers\x18\x03 \x01(\bR\x0eincludeHeaders\x12)\n" +
	"\x10header_whitelist\x18\x04 \x03(\tR\x0fheaderWhitelist\x12'\n" +
	"\x0finclude_cookies\x18\x05 \x01(\bR\x0eincludeCookies\x12)\n" +
	"\x10cookie_whitelist\x18\x06 \x03(\tR\x0fcookieWhitelistB\xf1\x01\n" +
	"\x1bcom.gcommon.v1.organizationB\x14TenantIsolationProtoP\x01Z6github.com/jdfalk/gcommon/pkg/organization/proto/types\xa2\x02\x03GVO\xaa\x02\x17Gcommon.V1.Organization\xca\x02\x17Gcommon\\V1\\Organization\xe2\x02#Gcommon\\V1\\Organization\\GPBMetadata\xea\x02\x19Gcommon::V1::Organization\x92\x03\x05\xd2>\x02\x10\x02b\beditionsp\xe8\a"

var file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_pkg_organization_proto_types_tenant_isolation_proto_goTypes = []any{
	(*TenantIsolation)(nil),       // 0: gcommon.v1.organization.TenantIsolation
	(*DatabaseIsolation)(nil),     // 1: gcommon.v1.organization.DatabaseIsolation
	(*NetworkIsolation)(nil),      // 2: gcommon.v1.organization.NetworkIsolation
	(*StorageIsolation)(nil),      // 3: gcommon.v1.organization.StorageIsolation
	(*ComputeIsolation)(nil),      // 4: gcommon.v1.organization.ComputeIsolation
	(*EncryptionConfig)(nil),      // 5: gcommon.v1.organization.EncryptionConfig
	(*AccessControl)(nil),         // 6: gcommon.v1.organization.AccessControl
	(*AuditConfig)(nil),           // 7: gcommon.v1.organization.AuditConfig
	(*BackupConfig)(nil),          // 8: gcommon.v1.organization.BackupConfig
	(*NetworkACLRule)(nil),        // 9: gcommon.v1.organization.NetworkACLRule
	(*LoadBalancerConfig)(nil),    // 10: gcommon.v1.organization.LoadBalancerConfig
	(*CDNConfig)(nil),             // 11: gcommon.v1.organization.CDNConfig
	(*DomainConfig)(nil),          // 12: gcommon.v1.organization.DomainConfig
	(*StorageEncryption)(nil),     // 13: gcommon.v1.organization.StorageEncryption
	(*StoragePolicy)(nil),         // 14: gcommon.v1.organization.StoragePolicy
	(*StorageBackupConfig)(nil),   // 15: gcommon.v1.organization.StorageBackupConfig
	(*StorageQuota)(nil),          // 16: gcommon.v1.organization.StorageQuota
	(*CPUAllocation)(nil),         // 17: gcommon.v1.organization.CPUAllocation
	(*MemoryAllocation)(nil),      // 18: gcommon.v1.organization.MemoryAllocation
	(*ResourceLimits)(nil),        // 19: gcommon.v1.organization.ResourceLimits
	(*AutoScalingConfig)(nil),     // 20: gcommon.v1.organization.AutoScalingConfig
	(*TimeRestriction)(nil),       // 21: gcommon.v1.organization.TimeRestriction
	(*AuditAlert)(nil),            // 22: gcommon.v1.organization.AuditAlert
	(*HealthCheckConfig)(nil),     // 23: gcommon.v1.organization.HealthCheckConfig
	(*SSLConfig)(nil),             // 24: gcommon.v1.organization.SSLConfig
	(*CacheBehavior)(nil),         // 25: gcommon.v1.organization.CacheBehavior
	(*OriginConfig)(nil),          // 26: gcommon.v1.organization.OriginConfig
	(*DNSConfig)(nil),             // 27: gcommon.v1.organization.DNSConfig
	(*DNSRecord)(nil),             // 28: gcommon.v1.organization.DNSRecord
	(*CacheKeyPolicy)(nil),        // 29: gcommon.v1.organization.CacheKeyPolicy
	(enums.IsolationLevel)(0),     // 30: gcommon.v1.organization.IsolationLevel
	(*types.KeyValue)(nil),        // 31: gcommon.v1.common.KeyValue
	(*timestamppb.Timestamp)(nil), // 32: google.protobuf.Timestamp
}
var file_pkg_organization_proto_types_tenant_isolation_proto_depIdxs = []int32{
	30, // 0: gcommon.v1.organization.TenantIsolation.level:type_name -> gcommon.v1.organization.IsolationLevel
	1,  // 1: gcommon.v1.organization.TenantIsolation.database:type_name -> gcommon.v1.organization.DatabaseIsolation
	2,  // 2: gcommon.v1.organization.TenantIsolation.network:type_name -> gcommon.v1.organization.NetworkIsolation
	3,  // 3: gcommon.v1.organization.TenantIsolation.storage:type_name -> gcommon.v1.organization.StorageIsolation
	4,  // 4: gcommon.v1.organization.TenantIsolation.compute:type_name -> gcommon.v1.organization.ComputeIsolation
	5,  // 5: gcommon.v1.organization.TenantIsolation.encryption:type_name -> gcommon.v1.organization.EncryptionConfig
	6,  // 6: gcommon.v1.organization.TenantIsolation.access_control:type_name -> gcommon.v1.organization.AccessControl
	7,  // 7: gcommon.v1.organization.TenantIsolation.audit:type_name -> gcommon.v1.organization.AuditConfig
	31, // 8: gcommon.v1.organization.TenantIsolation.metadata:type_name -> gcommon.v1.common.KeyValue
	32, // 9: gcommon.v1.organization.TenantIsolation.created_at:type_name -> google.protobuf.Timestamp
	32, // 10: gcommon.v1.organization.TenantIsolation.updated_at:type_name -> google.protobuf.Timestamp
	31, // 11: gcommon.v1.organization.DatabaseIsolation.connection_params:type_name -> gcommon.v1.common.KeyValue
	8,  // 12: gcommon.v1.organization.DatabaseIsolation.backup:type_name -> gcommon.v1.organization.BackupConfig
	9,  // 13: gcommon.v1.organization.NetworkIsolation.acl_rules:type_name -> gcommon.v1.organization.NetworkACLRule
	10, // 14: gcommon.v1.organization.NetworkIsolation.load_balancer:type_name -> gcommon.v1.organization.LoadBalancerConfig
	11, // 15: gcommon.v1.organization.NetworkIsolation.cdn:type_name -> gcommon.v1.organization.CDNConfig
	12, // 16: gcommon.v1.organization.NetworkIsolation.domain:type_name -> gcommon.v1.organization.DomainConfig
	13, // 17: gcommon.v1.organization.StorageIsolation.encryption:type_name -> gcommon.v1.organization.StorageEncryption
	14, // 18: gcommon.v1.organization.StorageIsolation.policies:type_name -> gcommon.v1.organization.StoragePolicy
	15, // 19: gcommon.v1.organization.StorageIsolation.backup:type_name -> gcommon.v1.organization.StorageBackupConfig
	16, // 20: gcommon.v1.organization.StorageIsolation.quota:type_name -> gcommon.v1.organization.StorageQuota
	17, // 21: gcommon.v1.organization.ComputeIsolation.cpu:type_name -> gcommon.v1.organization.CPUAllocation
	18, // 22: gcommon.v1.organization.ComputeIsolation.memory:type_name -> gcommon.v1.organization.MemoryAllocation
	19, // 23: gcommon.v1.organization.ComputeIsolation.limits:type_name -> gcommon.v1.organization.ResourceLimits
	20, // 24: gcommon.v1.organization.ComputeIsolation.auto_scaling:type_name -> gcommon.v1.organization.AutoScalingConfig
	21, // 25: gcommon.v1.organization.AccessControl.time_restrictions:type_name -> gcommon.v1.organization.TimeRestriction
	22, // 26: gcommon.v1.organization.AuditConfig.alerts:type_name -> gcommon.v1.organization.AuditAlert
	23, // 27: gcommon.v1.organization.LoadBalancerConfig.health_check:type_name -> gcommon.v1.organization.HealthCheckConfig
	24, // 28: gcommon.v1.organization.LoadBalancerConfig.ssl:type_name -> gcommon.v1.organization.SSLConfig
	25, // 29: gcommon.v1.organization.CDNConfig.cache_behaviors:type_name -> gcommon.v1.organization.CacheBehavior
	26, // 30: gcommon.v1.organization.CDNConfig.origin:type_name -> gcommon.v1.organization.OriginConfig
	27, // 31: gcommon.v1.organization.DomainConfig.dns:type_name -> gcommon.v1.organization.DNSConfig
	29, // 32: gcommon.v1.organization.CacheBehavior.cache_key:type_name -> gcommon.v1.organization.CacheKeyPolicy
	31, // 33: gcommon.v1.organization.OriginConfig.custom_headers:type_name -> gcommon.v1.common.KeyValue
	28, // 34: gcommon.v1.organization.DNSConfig.records:type_name -> gcommon.v1.organization.DNSRecord
	35, // [35:35] is the sub-list for method output_type
	35, // [35:35] is the sub-list for method input_type
	35, // [35:35] is the sub-list for extension type_name
	35, // [35:35] is the sub-list for extension extendee
	0,  // [0:35] is the sub-list for field type_name
}

func init() { file_pkg_organization_proto_types_tenant_isolation_proto_init() }
func file_pkg_organization_proto_types_tenant_isolation_proto_init() {
	if File_pkg_organization_proto_types_tenant_isolation_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_pkg_organization_proto_types_tenant_isolation_proto_rawDesc), len(file_pkg_organization_proto_types_tenant_isolation_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_pkg_organization_proto_types_tenant_isolation_proto_goTypes,
		DependencyIndexes: file_pkg_organization_proto_types_tenant_isolation_proto_depIdxs,
		MessageInfos:      file_pkg_organization_proto_types_tenant_isolation_proto_msgTypes,
	}.Build()
	File_pkg_organization_proto_types_tenant_isolation_proto = out.File
	file_pkg_organization_proto_types_tenant_isolation_proto_goTypes = nil
	file_pkg_organization_proto_types_tenant_isolation_proto_depIdxs = nil
}
