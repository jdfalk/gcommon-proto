#!/usr/bin/env python3
# file: copilot_workflow_helper.py
# version: 1.0.0
# guid: b2c3d4e5-f6a7-8901-bcde-234567890123

"""
GitHub Copilot Workflow Helper

A companion script to fix_failing_workflows.py that provides better integration
with GitHub Copilot for automated workflow fixes.

This script can:
1. Process fix request files generated by fix_failing_workflows.py
2. Submit them via GitHub Copilot CLI if available
3. Create structured GitHub issues as fallback
4. Generate PR templates for manual fixes
"""

import argparse
import os
import subprocess
import sys
from datetime import datetime
from typing import Dict, List


class CopilotWorkflowHelper:
    """Helper class for GitHub Copilot workflow integration."""

    def __init__(self, repo: str = None):
        """Initialize the helper.

        Args:
            repo: Repository in format owner/repo (auto-detected if None)
        """
        self.repo = repo or self._get_current_repo()
        self.copilot_available = self._check_copilot_availability()

    def _get_current_repo(self) -> str:
        """Get the current repository from git remote."""
        try:
            result = subprocess.run(
                ["git", "remote", "get-url", "origin"],
                capture_output=True,
                text=True,
                check=True,
            )
            remote_url = result.stdout.strip()

            # Parse different URL formats
            if "github.com" in remote_url:
                if remote_url.startswith("git@"):
                    # git@github.com:owner/repo.git
                    repo_part = remote_url.split(":")[-1]
                else:
                    # https://github.com/owner/repo.git
                    repo_part = remote_url.split("github.com/")[-1]

                return repo_part.replace(".git", "")

            raise ValueError("Not a GitHub repository")

        except subprocess.CalledProcessError:
            raise ValueError("Could not determine repository from git remote")

    def _check_copilot_availability(self) -> bool:
        """Check if GitHub Copilot CLI is available."""
        try:
            result = subprocess.run(
                ["gh", "copilot", "--help"], capture_output=True, text=True
            )
            return result.returncode == 0
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False

    def _run_gh_command(self, args: List[str]) -> tuple[int, str, str]:
        """Run a GitHub CLI command and return result."""
        cmd = ["gh"] + args
        print(f"üîß Running: {' '.join(cmd)}")

        result = subprocess.run(cmd, capture_output=True, text=True)

        return result.returncode, result.stdout, result.stderr

    def process_fix_request(self, fix_file: str) -> Dict:
        """Process a fix request file and extract key information."""
        print(f"üìñ Processing fix request: {fix_file}")

        with open(fix_file, "r", encoding="utf-8") as f:
            content = f.read()

        # Extract metadata from the markdown file
        metadata = {
            "file_path": fix_file,
            "workflow_name": "Unknown",
            "run_id": "Unknown",
            "branch": "Unknown",
            "sha": "Unknown",
            "url": "",
            "errors": [],
            "files": [],
            "content": content,
        }

        lines = content.split("\n")
        in_error_section = False

        for line in lines:
            if "**Workflow**:" in line:
                metadata["workflow_name"] = line.split("**Workflow**:")[-1].strip()
            elif "**Run ID**:" in line:
                metadata["run_id"] = line.split("**Run ID**:")[-1].strip()
            elif "**Branch**:" in line:
                metadata["branch"] = line.split("**Branch**:")[-1].strip()
            elif "**SHA**:" in line:
                metadata["sha"] = line.split("**SHA**:")[-1].strip()
            elif "**URL**:" in line:
                metadata["url"] = line.split("**URL**:")[-1].strip()
            elif "## Error Summary" in line:
                in_error_section = True
            elif in_error_section and line.startswith("1.") and "**Error**:" in line:
                error = line.split("**Error**:")[-1].strip()
                metadata["errors"].append(error)
            elif "- `" in line and ".proto" not in line:  # File references
                file_ref = line.split("`")[1] if "`" in line else ""
                if file_ref and file_ref not in metadata["files"]:
                    metadata["files"].append(file_ref)

        return metadata

    def submit_to_copilot_chat(self, metadata: Dict) -> bool:
        """Submit the fix request to GitHub Copilot Chat."""
        if not self.copilot_available:
            print("‚ùå GitHub Copilot CLI not available")
            return False

        print("ü§ñ Submitting to GitHub Copilot Chat...")

        # Create a focused prompt for Copilot
        prompt = f"""Help me fix a failing GitHub Actions workflow:

Workflow: {metadata["workflow_name"]}
Branch: {metadata["branch"]}
Repository: {self.repo}

Main errors found:
{chr(10).join(f"- {error}" for error in metadata["errors"][:5])}

Files that may need attention:
{chr(10).join(f"- {file}" for file in metadata["files"][:10])}

Please provide specific fixes for this workflow failure, including:
1. Root cause analysis
2. Specific code changes needed
3. Updated workflow YAML if necessary
4. Any dependency or configuration changes required

The full analysis is in: {metadata["file_path"]}
"""

        # Try different Copilot commands based on what's available
        commands_to_try = [
            ["gh", "copilot", "explain", prompt],
            ["gh", "copilot", "suggest", "-t", "gh", prompt],
            ["gh", "copilot", "suggest", prompt],
        ]

        for cmd_args in commands_to_try:
            try:
                result = subprocess.run(
                    cmd_args, input=prompt, capture_output=True, text=True, timeout=60
                )

                if result.returncode == 0:
                    print("‚úÖ Copilot response received:")
                    print(result.stdout)

                    # Save the response
                    response_file = metadata["file_path"].replace(
                        ".md", "_copilot_response.md"
                    )
                    with open(response_file, "w", encoding="utf-8") as f:
                        f.write(
                            f"# Copilot Response for {metadata['workflow_name']}\n\n"
                        )
                        f.write(f"Generated: {datetime.now().isoformat()}\n\n")
                        f.write(result.stdout)

                    print(f"üìù Response saved to: {response_file}")
                    return True

            except (subprocess.TimeoutExpired, subprocess.CalledProcessError) as e:
                print(f"‚ö†Ô∏è Command failed: {e}")
                continue

        print("‚ùå All Copilot commands failed")
        return False

    def create_github_issue(self, metadata: Dict) -> bool:
        """Create a detailed GitHub issue for the workflow failure."""
        print("üìã Creating GitHub issue...")

        issue_title = (
            f"üîß Workflow Fix: {metadata['workflow_name']} (Run {metadata['run_id']})"
        )

        issue_body = f"""## Workflow Failure Analysis

**Workflow**: {metadata["workflow_name"]}
**Run ID**: {metadata["run_id"]}
**Branch**: {metadata["branch"]}
**SHA**: {metadata["sha"]}
**URL**: {metadata["url"]}

### Main Errors
{chr(10).join(f"- {error}" for error in metadata["errors"])}

### Files Requiring Attention
{chr(10).join(f"- `{file}`" for file in metadata["files"])}

### Next Steps
- [ ] Analyze the full logs in the attached file
- [ ] Identify root cause of the failure
- [ ] Apply necessary fixes to workflow or code
- [ ] Test the fixes in a feature branch
- [ ] Create PR with the fixes

### Full Analysis
The complete failure analysis is available in: `{os.path.basename(metadata["file_path"])}`

---
*This issue was automatically generated by the workflow fix tool.*
"""

        returncode, stdout, stderr = self._run_gh_command(
            [
                "issue",
                "create",
                "--repo",
                self.repo,
                "--title",
                issue_title,
                "--body",
                issue_body,
                "--label",
                "bug,workflow,automated-fix-request,priority-high",
            ]
        )

        if returncode == 0:
            issue_url = stdout.strip()
            print(f"‚úÖ Created GitHub issue: {issue_url}")

            # Try to upload the fix file as a comment
            self._add_issue_comment(issue_url, metadata["file_path"])
            return True
        else:
            print(f"‚ùå Error creating GitHub issue: {stderr}")
            return False

    def _add_issue_comment(self, issue_url: str, fix_file: str) -> bool:
        """Add the fix file content as a comment to the issue."""
        try:
            # Extract issue number from URL
            issue_number = issue_url.split("/")[-1]

            comment_body = """## Detailed Analysis

<details>
<summary>Click to view complete workflow failure analysis</summary>

```markdown
"""

            with open(fix_file, "r", encoding="utf-8") as f:
                content = f.read()
                # Truncate if too long (GitHub has limits)
                if len(content) > 60000:
                    content = (
                        content[:30000]
                        + "\n\n... (truncated for size) ...\n\n"
                        + content[-30000:]
                    )
                comment_body += content

            comment_body += """
```

</details>
"""

            returncode, stdout, stderr = self._run_gh_command(
                [
                    "issue",
                    "comment",
                    issue_number,
                    "--repo",
                    self.repo,
                    "--body",
                    comment_body,
                ]
            )

            if returncode == 0:
                print("üìé Added detailed analysis as comment")
                return True
            else:
                print(f"‚ö†Ô∏è Could not add comment: {stderr}")
                return False

        except Exception as e:
            print(f"‚ö†Ô∏è Error adding comment: {e}")
            return False

    def generate_pr_template(
        self, metadata: Dict, output_dir: str = "pr_templates"
    ) -> str:
        """Generate a pull request template for manual fixes."""
        os.makedirs(output_dir, exist_ok=True)

        safe_name = metadata["workflow_name"].replace(" ", "_").replace("/", "_")
        template_file = os.path.join(
            output_dir, f"fix_{safe_name}_{metadata['run_id']}.md"
        )

        template_content = f"""# Fix for {metadata["workflow_name"]} Workflow Failure

## Issue Description
This PR fixes the failing workflow: {metadata["workflow_name"]} (Run #{metadata["run_id"]})

**Branch**: {metadata["branch"]}
**SHA**: {metadata["sha"]}
**Run URL**: {metadata["url"]}

## Root Cause
<!-- Describe what caused the workflow to fail -->

## Changes Made
<!-- List the specific changes made to fix the issue -->

- [ ] Updated workflow YAML configuration
- [ ] Fixed code issues in affected files
- [ ] Updated dependencies
- [ ] Added missing environment variables
- [ ] Other: _______________

## Files Changed
<!-- List the files modified to fix the issue -->

{chr(10).join(f"- `{file}`" for file in metadata["files"])}

## Testing
<!-- Describe how the fix was tested -->

- [ ] Workflow runs successfully in feature branch
- [ ] All existing tests pass
- [ ] New tests added (if applicable)
- [ ] Manual testing completed

## Risk Assessment
<!-- Assess the risk level of this change -->

- [ ] Low risk - minor configuration change
- [ ] Medium risk - code changes but well tested
- [ ] High risk - significant changes, needs careful review

## Additional Notes
<!-- Any other relevant information -->

---

### Original Error Summary
{chr(10).join(f"- {error}" for error in metadata["errors"])}

### Related Issues
- Closes #[issue-number]

---
*Generated by workflow fix tool on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
"""

        with open(template_file, "w", encoding="utf-8") as f:
            f.write(template_content)

        print(f"üìù PR template created: {template_file}")
        return template_file

    def process_directory(self, fix_dir: str) -> bool:
        """Process all fix request files in a directory."""
        print(f"üìÅ Processing fix requests in: {fix_dir}")

        if not os.path.exists(fix_dir):
            print(f"‚ùå Directory not found: {fix_dir}")
            return False

        fix_files = [
            f
            for f in os.listdir(fix_dir)
            if f.endswith(".md") and not f.endswith("_copilot_response.md")
        ]

        if not fix_files:
            print("üì≠ No fix request files found")
            return True

        success_count = 0

        for fix_file in fix_files:
            file_path = os.path.join(fix_dir, fix_file)
            print(f"\n{'=' * 60}")
            print(f"Processing: {fix_file}")
            print(f"{'=' * 60}")

            try:
                metadata = self.process_fix_request(file_path)

                # Try Copilot first if available
                if self.copilot_available:
                    if self.submit_to_copilot_chat(metadata):
                        success_count += 1
                        continue

                # Fallback to GitHub issue
                if self.create_github_issue(metadata):
                    success_count += 1

                # Always generate PR template
                self.generate_pr_template(metadata)

            except Exception as e:
                print(f"‚ùå Error processing {fix_file}: {e}")

        print(
            f"\nüéâ Processed {success_count}/{len(fix_files)} fix requests successfully"
        )
        return success_count > 0


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Process workflow fix requests with GitHub Copilot",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python copilot_workflow_helper.py workflow_fixes/            # Process all files in directory
  python copilot_workflow_helper.py workflow_fixes/fix.md      # Process single file
  python copilot_workflow_helper.py --create-issues-only       # Only create GitHub issues
        """,
    )

    parser.add_argument(
        "input_path", help="Path to fix request file or directory containing fix files"
    )

    parser.add_argument(
        "--repo",
        help="Repository in format owner/repo (auto-detected if not specified)",
    )

    parser.add_argument(
        "--create-issues-only",
        action="store_true",
        help="Only create GitHub issues, skip Copilot submission",
    )

    parser.add_argument(
        "--pr-templates-only",
        action="store_true",
        help="Only generate PR templates, skip other actions",
    )

    args = parser.parse_args()

    try:
        helper = CopilotWorkflowHelper(repo=args.repo)

        if args.create_issues_only:
            helper.copilot_available = False

        if os.path.isfile(args.input_path):
            # Process single file
            metadata = helper.process_fix_request(args.input_path)

            if args.pr_templates_only:
                helper.generate_pr_template(metadata)
            elif args.create_issues_only or not helper.copilot_available:
                helper.create_github_issue(metadata)
                helper.generate_pr_template(metadata)
            else:
                # Try Copilot first, fallback to issue
                if not helper.submit_to_copilot_chat(metadata):
                    helper.create_github_issue(metadata)
                helper.generate_pr_template(metadata)

        elif os.path.isdir(args.input_path):
            # Process directory
            if args.pr_templates_only:
                # Only generate PR templates for all files
                fix_files = [
                    f for f in os.listdir(args.input_path) if f.endswith(".md")
                ]
                for fix_file in fix_files:
                    file_path = os.path.join(args.input_path, fix_file)
                    metadata = helper.process_fix_request(file_path)
                    helper.generate_pr_template(metadata)
            else:
                helper.process_directory(args.input_path)

        else:
            print(f"‚ùå Path not found: {args.input_path}")
            return 1

        return 0

    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Interrupted by user")
        return 1
    except Exception as e:
        print(f"‚ùå Error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
